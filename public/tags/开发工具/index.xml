<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fatedier blog </title>
    <link>http://blog.fatedier.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2016</rights>
    <updated>2016-07-25 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>使用gvm在不同go版本之间切换</title>
          <link>http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm</link>
          <pubDate>Mon, 25 Jul 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm</guid>
          <description>

&lt;p&gt;Centos7上通过 yum 从 epel 仓库里直接安装的 go 版本还是 1.4.2，从源码编译安装最新的 go 版本比较麻烦，而且开发中有时需要调试在不同编译环境下可能存在的问题，不能忽略使用最新版本是存在某些 bug 的可能性。&lt;/p&gt;

&lt;p&gt;Go 的更新速度比较快，2015年8月发布 1.5 版本，2016年2月发布 1.6 版本，2016年8月即将发布 1.7 版本，在性能以及GC方便都在不断优化，及时更新到新版本的 go 很有优势。&lt;/p&gt;

&lt;h3 id=&#34;go-版本切换的问题&#34;&gt;Go 版本切换的问题&lt;/h3&gt;

&lt;p&gt;二进制文件的管理比较简单，通过链接使用不同版本的程序即可，实际上主要是一些环境变量和标准库的设置问题，环境变量主要是 &lt;code&gt;GOPATH&lt;/code&gt; 以及 &lt;code&gt;GOROOT&lt;/code&gt;，标准库的话需要在切换 go 版本时也能跟着切换。&lt;strong&gt;gvm&lt;/strong&gt; 实际上就是帮助完成这些配置工作。&lt;/p&gt;

&lt;h3 id=&#34;安装-gvm&#34;&gt;安装 gvm&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;gvm&lt;/strong&gt; 的项目地址：&lt;a href=&#34;https://github.com/moovweb/gvm&#34;&gt;https://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash &amp;lt;&amp;lt; (curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你使用的是 &lt;code&gt;zsh&lt;/code&gt; 的话将前面的 &lt;code&gt;bash&lt;/code&gt; 改为 &lt;code&gt;zsh&lt;/code&gt; 即可，这条命令主要是下载 &lt;strong&gt;gvm&lt;/strong&gt; 相关的文件，创建所需目录，并且在 &lt;code&gt;.bashrc&lt;/code&gt; 或者 &lt;code&gt;.zshrc&lt;/code&gt; 中加入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[[ -s &amp;quot;/home/wcl/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;/home/wcl/.gvm/scripts/gvm&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使每次登录 shell 时都可以生效。&lt;/p&gt;

&lt;h3 id=&#34;安装指定-go-版本&#34;&gt;安装指定 go 版本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gvm install go1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意这里实际上是先执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://go.googlesource.com/go $GVM_ROOT/archive/go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个网站在墙外。&lt;/p&gt;

&lt;p&gt;我们可以通过配置使 git 可以通过 http 代理访问，修改 &lt;code&gt;.gitconfig&lt;/code&gt; 文件，加上 http 代理服务器的地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[http]
        proxy = http://[proxydomain]:[port]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载成功后，有可能提示编译失败，因为 go1.6.3 需要依赖于 go1.4 来编译，需要设置 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 变量。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;go env&lt;/code&gt; 查看 &lt;code&gt;GOROOT&lt;/code&gt; 的路径，通常 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 就设置成 &lt;code&gt;GOROOT&lt;/code&gt;，centos7 下需要注意 /usr/lib/golang/bin 下并没有 &lt;code&gt;go&lt;/code&gt; 的二进制文件，通过 cp 命令复制一个过去。&lt;/p&gt;

&lt;p&gt;之后再次执行 &lt;code&gt;gvm install go1.6.3&lt;/code&gt; 即可安装完成。&lt;/p&gt;

&lt;h3 id=&#34;修改配置信息方便使用&#34;&gt;修改配置信息方便使用&lt;/h3&gt;

&lt;p&gt;最初测试时发现每次切换 go 版本后都会被修改 &lt;code&gt;GOPATH&lt;/code&gt; 变量，而实际上我并不需要这个功能，只是希望用新版本来编译已有的项目，所以我们需要把 &lt;code&gt;~/.gvm/environments&lt;/code&gt; 文件夹下所有 &lt;code&gt;GOPATH&lt;/code&gt; 的设置全部删除。&lt;/p&gt;

&lt;p&gt;另外还需要将 &lt;code&gt;~/.zshrc&lt;/code&gt; 或者 &lt;code&gt;~/.bashrc&lt;/code&gt; 中的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[[ -s &amp;quot;~/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;~/.gvm/scripts/gvm&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移到设置 &lt;code&gt;GOPATH&lt;/code&gt; 变量之前，避免登录 shell 之后被修改 &lt;code&gt;GOPATH&lt;/code&gt; 变量。&lt;/p&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;h4 id=&#34;切换到安装好的指定-go-版本&#34;&gt;切换到安装好的指定 go 版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use go1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;go version&lt;/code&gt; 可以看到已经是新版本的二进制文件，通过 &lt;code&gt;go env&lt;/code&gt; 可以查看 &lt;code&gt;GOROOT&lt;/code&gt; 信息，例如我的就是 &lt;code&gt;~/.gvm/gos/go1.6.3&lt;/code&gt;，这样编译项目时就会在这个目录下找标准库中的文件。&lt;/p&gt;

&lt;h4 id=&#34;切换到原来的系统版本&#34;&gt;切换到原来的系统版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use system&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;查看当前已经安装的所有版本&#34;&gt;查看当前已经安装的所有版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gvm gos (installed)

=&amp;gt; go1.6.3
   system
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;设置某个版本为默认&#34;&gt;设置某个版本为默认&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use go1.6.3 --default&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样设置后，再登录 shell 就默认使用 &lt;code&gt;go1.6.3&lt;/code&gt; 的版本，而不是系统原来的版本了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用godep管理golang项目的第三方包</title>
          <link>http://blog.fatedier.com/2016/01/15/use-godep-to-manage-third-party-packages-of-golang-projects</link>
          <pubDate>Fri, 15 Jan 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/01/15/use-godep-to-manage-third-party-packages-of-golang-projects</guid>
          <description>

&lt;p&gt;go语言项目的第三方包资源现在十分丰富，使用起来也非常方便，直接在代码中 import 之后再使用 go get 命令下载到本地即可。但是在合作开发一个golang项目时，经常会遇到每个人在各自的机器上使用 go get 下载的第三方包版本不一致的情况（因为 go get 会下载指定包的最新版本），很有可能会遇到版本不兼容的情况。&lt;/p&gt;

&lt;p&gt;目前 go 自身的包管理体系比较薄弱，go 1.5 以后开始使用 vendor 机制来管理，但是依然缺乏对第三方包的版本的管理。&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;确保已经有go语言的环境并且设置好了 GOPATH 环境变量。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;go get -u github.com/tools/godep&lt;/code&gt; 下载 godep 包并自动安装。&lt;/li&gt;
&lt;li&gt;godep 可执行程序会放在 $GOPATH/bin 目录下。所以想直接用 godep 执行命令的话需要将该路径加入到全局的环境变量 PATH 中，可以将&lt;code&gt;export PATH=&amp;quot;$PATH:$GOPATH/bin&amp;quot;&lt;/code&gt;加入到系统启动脚本中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;进入go项目的根目录，需要该项目已经可以使用 go build 正常编译。&lt;/p&gt;

&lt;h4 id=&#34;godep-save&#34;&gt;godep save&lt;/h4&gt;

&lt;p&gt;执行 &lt;code&gt;godep save&lt;/code&gt; 或者 &lt;code&gt;godep save ./...&lt;/code&gt;，后者会递归地查找所有引用的第三方包。&lt;/p&gt;

&lt;p&gt;如果加上 -r 参数，则会替换原来代码中的第三包的路径为 godep 在该项目下copy过后的路径，例如 &lt;code&gt;C/Godeps/_workspace/src/D&lt;/code&gt;， 这样一来，以后直接执行 &lt;code&gt;go build&lt;/code&gt; 等就可以了，不需要使用 &lt;code&gt;godep go build&lt;/code&gt;。&lt;strong&gt;（这个特性在最新版本中已经被移除了）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个命令做了以下几件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查找项目中所用到的所有的第三方包&lt;/li&gt;
&lt;li&gt;在项目目录下创建 &lt;code&gt;Godeps&lt;/code&gt; 目录，&lt;code&gt;Godeps/Godeps.json&lt;/code&gt; 是依赖文件，包括了go的版本，用到的第三包的引入路径，版本号等信息，json文件需要一并加入到版本控制里。&lt;/li&gt;
&lt;li&gt;所有依赖的第三包的代码会被拷贝到 &lt;code&gt;Godeps/_workspace/src&lt;/code&gt; 下，并且移除了 &lt;code&gt;.git&lt;/code&gt; 这样的版本控制信息。&lt;code&gt;Godeps/_workspace&lt;/code&gt; 里的内容如果加到版本控制里，别人下载代码后可以直接编译，不需要另外再下依赖包，但是项目大小会变大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;godep-restore&#34;&gt;godep restore&lt;/h4&gt;

&lt;p&gt;这个命令是根据 &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; 文件把项目的依赖包下载到 &lt;code&gt;$GOPATH&lt;/code&gt; 目录下，需要注意这个命令是会修改 &lt;code&gt;$GOPATH&lt;/code&gt; 下依赖包的状态的，所以最好还是将 &lt;code&gt;Godeps/_workspace&lt;/code&gt; 里的内容直接加到自己项目的版本控制里。&lt;/p&gt;

&lt;h4 id=&#34;其他命令&#34;&gt;其他命令&lt;/h4&gt;

&lt;p&gt;其他的 go 命令基本上都可以通过 godep 执行，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;godep go build
godep go install
godep go fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;godep 封装的 go 命令其实就是将 Godeps/_workspace 加入到 GOPATH 中，这样编译的时候就会去 Godeps/_workspace 中寻找第三方包。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>终端利器 Tmux</title>
          <link>http://blog.fatedier.com/2015/12/18/terminal-multiplexer-tmux</link>
          <pubDate>Fri, 18 Dec 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2015/12/18/terminal-multiplexer-tmux</guid>
          <description>

&lt;p&gt;开发过程中通过ssh到服务器是很常见的，工作中基本上90%的时间在和终端打交道，如果没有一个称手的工具，将会在不停打开新的 tab 页，窗口切换中耗费大量的时间。Tmux 是终端复用器的意思，和 screen 类似，但是高度可定制，通过 tmux 可以方便地管理大量的 ssh 连接，并且灵活地在不同窗口，不同面板之间切换。&lt;/p&gt;

&lt;h3 id=&#34;界面&#34;&gt;界面&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2015/2015-12-18-terminal-multiplexer-tmux-tmux-overview.png&#34; alt=&#34;tmux&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我用了自己的配置文件，对界面做过一些优化，左下角是 &lt;strong&gt;session&lt;/strong&gt; 名称，中间是各个 &lt;strong&gt;window&lt;/strong&gt; 的名称，可以理解为一般 IDE 中的 Tab 页，右下角显示时间，这个窗口中打开了3个 &lt;strong&gt;pane&lt;/strong&gt;，通过快捷键，我就可以在不同的 &lt;strong&gt;session&lt;/strong&gt;, &lt;strong&gt;window&lt;/strong&gt;, &lt;strong&gt;pane&lt;/strong&gt; 之间来回切换，基本上脱离了鼠标的使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;session： 可以用于区分不同的项目，为每个项目建立一个 session。&lt;/li&gt;
&lt;li&gt;window： 对应于其他 IDE 的 Tab 标签页，一个 window 占据一个显示屏幕，一个 session 可以有多个 window。&lt;/li&gt;
&lt;li&gt;pane： 在一个 window 中可以有多个 pane，便于大屏幕显示屏将屏幕切分成多块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Centos下直接通过 &lt;code&gt;yum install -y tmux&lt;/code&gt; 来安装，其他系统也一样可以使用相应的包管理工具安装。&lt;/p&gt;

&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;

&lt;h4 id=&#34;快捷键前缀&#34;&gt;快捷键前缀&lt;/h4&gt;

&lt;p&gt;为了避免按键冲突，使用 tmux 的快捷键都需要加上一个&lt;strong&gt;前缀按键&lt;/strong&gt;，默认是 &lt;strong&gt;Ctrl-b&lt;/strong&gt; 的组合，可以通过配置修改为自定义的按键。&lt;/p&gt;

&lt;p&gt;例如要退出 tmux 的快捷键是前缀键 + d，那么就需要按 Ctrl-b + d：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按下组合键 Ctrl-b&lt;/li&gt;
&lt;li&gt;放开组合键 Ctrl-b&lt;/li&gt;
&lt;li&gt;按下 s 键&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我自己将 Ctrl-b 改成了 Ctrl-x ，感觉这样操作顺手一些。&lt;/p&gt;

&lt;h4 id=&#34;基本操作&#34;&gt;基本操作&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;创建一个叫做 &amp;ldquo;test&amp;rdquo; 的 session，并且进入 tmux 界面&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tmux new -s test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看开启了哪些 session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tmux ls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进入 session &amp;ldquo;test&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tmux attach -t test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;退出 tmux 环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + d  // 退出后 session 并不会被关闭，之后通过 attach 进入仍然会看到原来的界面&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切换 session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + s，之后按序号切换，或者通过方向键选择后按 Enter 键切换&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切换 window&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ctrl-b + &amp;lt;窗口号&amp;gt;
Ctrl-b + n  // 切换到下一个窗口
Ctrl-b + p  // 切换到上一个窗口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;切换 pane&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个我在配置文件中修改过，修改成了 vim 的使用习惯，具体配置见下节
Ctrl-b + h  // 左
Ctrl-b + j  // 下
Ctrl-b + k  // 上
Ctrl-b + l  // 右
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;关闭 pane&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + x  // 焦点在要关闭的 pane 内&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关闭 window&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + &amp;amp; // 焦点在要关闭的 window 内&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分割 window 成多个 pane&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个为了记忆方便也修改了原有的配置
Ctrl-b + _  // 竖直分割
Ctrl-b + |  // 水平分割
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重新加载配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个被我映射到了 r 键，修改完配置文件后不用关闭所有 session 重新打开，直接重新加载即可
Ctrl-b + r
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;小技巧&#34;&gt;小技巧&lt;/h3&gt;

&lt;h4 id=&#34;复制模式&#34;&gt;复制模式&lt;/h4&gt;

&lt;p&gt;如果要在不同 &lt;strong&gt;window&lt;/strong&gt; 或者 &lt;strong&gt;pane&lt;/strong&gt; 之间复制内容，又想实现全键盘的操作，就需要借助于 tmux 的复制功能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-b + [&lt;/strong&gt; 进入复制模式&lt;/li&gt;
&lt;li&gt;移动光标到要复制的地方，这里我配置成了 vim 的操作方式&lt;/li&gt;
&lt;li&gt;按下&lt;strong&gt;空格&lt;/strong&gt;开始复制&lt;/li&gt;
&lt;li&gt;再移动到结束的地方，按下 &lt;strong&gt;Enter&lt;/strong&gt; 键退出&lt;/li&gt;
&lt;li&gt;在需要粘贴的地方按下 &lt;strong&gt;Ctrl-b + ]&lt;/strong&gt; 粘贴&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;多-pane-批量操作&#34;&gt;多 pane 批量操作&lt;/h4&gt;

&lt;p&gt;有时候同时登录了多台机器，需要执行一样的命令来进行批量操作，借助于 tmux 同样可以实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:setw synchronize-panes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个是设置批量操作的开关，如果原来功能是关闭的，则打开，反之亦然，可以将其映射到一个快捷键方便操作。开启这个功能后，在当前 window 任意一个 pane 输入的命令，都会同时作用于该 window 中的其他 pane。&lt;/p&gt;

&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;配置文件需要自己在 $HOME 目录下创建，命名为 .tmux.conf，具体内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Use something easier to type as the prefix.
set -g prefix C-x
unbind C-b
bind C-x send-prefix

# 窗口计数从1开始，方便切换
set -g base-index 1
setw -g pane-base-index 1

# 启用和关闭status bar
bind S set status on
bind D set status off 

# 消息背景色
set -g message-bg white

set -g mode-keys vi

# 关闭自动重命名窗口
setw -g allow-rename off 
setw -g automatic-rename off 

# bind a reload key
bind r source-file ~/.tmux.conf \; display-message &amp;quot;Config reloaded...&amp;quot;

# I personally rebind the keys so &amp;quot;|&amp;quot; splits the current window vertically, and &amp;quot;-&amp;quot; splits it horizontally. Not the easiest things to type, though easy to remember.
bind | split-window -h
bind _ split-window -v

# fixes the delay problem
set -sg escape-time 0

# 面板切换
bind-key k select-pane -U
bind-key j select-pane -D
bind-key h select-pane -L
bind-key l select-pane -R

# 面板大小调整
bind -r ^k resizep -U 10  
bind -r ^j resizep -D 10
bind -r ^h resizep -L 10
bind -r ^l resizep -R 10

# 状态栏
# 颜色
set -g status-bg black
set -g status-fg white

# 对齐方式
set-option -g status-justify centre

# 左下角
set-option -g status-left &#39;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&#39;
set-option -g status-left-length 20

# 窗口列表
set-window-option -g window-status-format &#39;#[dim]#I:#[default]#W#[fg=grey,dim]&#39;
set-window-option -g window-status-current-format &#39;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&#39;

# 右下角
set -g status-right &#39;#[fg=green][#[fg=cyan]%H:%M#[fg=green]]&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配套工具&#34;&gt;配套工具&lt;/h3&gt;

&lt;h4 id=&#34;tmuxinator&#34;&gt;tmuxinator&lt;/h4&gt;

&lt;p&gt;使用 tmux 可以让我们不管在什么时候，什么地点登录服务器都能得到同样的工作界面，不用因为担心网络暂时中断而需要重新打开一大堆的 tab 页。&lt;/p&gt;

&lt;p&gt;但是如果有的时候服务器重启了，那么所有的 session 就都没了，必须重新打开，可以想象一下我开发时有4-5个 session，每个 session 中有多个 window，然后每个 winodw 中通常又有2-3个 pane，要重新一个个建立开发环境是一件多么痛苦的事。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tmuxinator/tmuxinator&#34;&gt;tmuxinator&lt;/a&gt; 可以稍微缓解一下这个问题，但是不彻底。tmuxinator 可以用于管理 tmux 的 session 和 window 布局等，便于在机器重启后能够快速恢复自己的工作环境。&lt;/p&gt;

&lt;h5 id=&#34;安装-1&#34;&gt;安装&lt;/h5&gt;

&lt;p&gt;先安装 gem， &lt;code&gt;yum install -y rubygems&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于天朝特殊的网络环境，gem的第三方包可能安装不了，可以替换成阿里提供的镜像源。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem sources --add [https://ruby.taobao.org/](https://ruby.taobao.org/) --remove [https://rubygems.org/](https://rubygems.org/)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;使用&#34;&gt;使用&lt;/h5&gt;

&lt;p&gt;创建一个 tmuxinator 的 project： &lt;code&gt;tmuxinator new [project]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;之后编写项目的配置文件，以后重新打开这个项目所显示的界面就是根据这个配置文件来生成。具体用法可以参考项目文档： &lt;a href=&#34;https://github.com/tmuxinator/tmuxinator。&#34;&gt;https://github.com/tmuxinator/tmuxinator。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当服务器重启了以后，执行 &lt;code&gt;tmuxinator start [project]&lt;/code&gt;，tmuxinator 就会自动根据配置文件创建一个指定布局的 tmux session。&lt;/p&gt;

&lt;h5 id=&#34;缺点&#34;&gt;缺点&lt;/h5&gt;

&lt;p&gt;布局是预先在配置文件中指定好的，你在使用 tmux 过程中修改了的布局是不会记录下来的。&lt;/p&gt;

&lt;h4 id=&#34;tmux-resurrect&#34;&gt;Tmux Resurrect&lt;/h4&gt;

&lt;p&gt;Tmux Resurrect 用于保存当前的session环境到磁盘上，用于以后恢复。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于这个插件需要 tmux 1.9 及以上的版本，而 centos7 的 yum 源里现在是1.8的版本，我的开发环境全是自动构建，不方便升级，所以暂时还没有尝试。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于 Tmux Resurrect 使用的相关文档： &lt;a href=&#34;http://www.linuxidc.com/Linux/2015-07/120304.htm&#34;&gt;http://www.linuxidc.com/Linux/2015-07/120304.htm&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>linux core文件调试</title>
          <link>http://blog.fatedier.com/2014/12/07/debug-with-linux-core-file</link>
          <pubDate>Sun, 07 Dec 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/12/07/debug-with-linux-core-file</guid>
          <description>

&lt;p&gt;在完成公司项目，测试进程的时候，经常会发现日志到了某一段特定的代码的时候就没了，进程直接退出，也没有捕获到任何的异常信息，如果日志打印的较多还可能比较容易发现问题
题，如果日志较少，就很难进行进一步的查错了。但是发现在该目录下生成了一个core文件，可以帮助我们查找程序崩溃的原因。&lt;/p&gt;

&lt;h3 id=&#34;什么是core文件&#34;&gt;什么是core文件&lt;/h3&gt;

&lt;p&gt;在linux系统下，如果进程不能正常运行，就可能会产生core文件。core文件就是当前内存状态的一个映像，同时加上一些调试信息。&lt;/p&gt;

&lt;p&gt;bug和操作系统或硬件的保护机制都会导致程序异常终止，操作系统会kill掉这些进程并产生core文件，比如常见的段错误等。&lt;/p&gt;

&lt;h3 id=&#34;为什么我的linux不会生成core文件&#34;&gt;为什么我的linux不会生成core文件&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;ulimit -a&lt;/code&gt; 命令可以查看当前系统资源的一些限制信息，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       3847
-n: file descriptors                1024
-l: locked-in-memory size (kbytes)  64
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 3847
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 &lt;strong&gt;-c: core file size&lt;/strong&gt; 如果设置为0的话，当程序崩溃的时候就不会产生core文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置core文件大小为无限&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;阻止系统生成core文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：这条命令只在当前生效，如果希望永久生效，就需要在 .bash_profile 或者类似文件中加上这条命令。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;设置core-dump的核心转储文件目录和命名规则&#34;&gt;设置Core Dump的核心转储文件目录和命名规则&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;/proc/sys/kernel/core_uses_pid&lt;/strong&gt; 可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0。需要有超级用户的权限才能进行修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;/proc/sys/kernel/core_pattern&lt;/strong&gt; 可以设置格式化的 core文件保存位置或文件名，默认的是 &lt;strong&gt;|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;需要修改的话，可以使用这条命令：&lt;code&gt;echo &amp;quot;/corefile/core-%e-%p-%t&amp;quot;&amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将会控制所产生的core文件会存放到 /corefile 目录下，产生的文件名为 &lt;strong&gt;core-命令名-pid-时间戳&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是参数列表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;%p - insert pid into filename 添加pid
%u - insert current uid into filename 添加当前uid
%g - insert current gid into filename 添加当前gid
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号
%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
%h - insert hostname where the coredump happened into filename 添加主机名
%e - insertcoredumping executable name into filename 添加命令名
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用core文件&#34;&gt;使用core文件&lt;/h3&gt;

&lt;p&gt;在linux上可以使用gdb来调试core文件，格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb [程序名] [core文件名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不知道这个core文件到底是哪个程序生成的，可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb -c[core 文件名] 来查看生成此core文件的程序名。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果中可以看出程序名，可能像下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Core wasgenerated by `./test&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后进入gdb调试状态，输入 where 就可以看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），我们可以借此找出是程序中的哪个部分导致了程序崩溃。注意：在编译程序的时候要加入选项-g。&lt;/p&gt;

&lt;h3 id=&#34;一个简单的例子&#34;&gt;一个简单的例子&lt;/h3&gt;

&lt;p&gt;编译如下的程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
 
class A
{
public:
    int a;
};
 
void fun()
{
    A*t = new A();
    t-&amp;gt;a = 1;
    cout &amp;lt;&amp;lt; t-&amp;gt;a &amp;lt;&amp;lt; endl;
    delete t;
    delete t;
}
 
int main()
{
    fun();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1
*** glibc detected *** ./test: double freeor corruption (fasttop): 0x09fd7008 ***
======= Backtrace: =========
/lib/libc.so.6[0x3ebe31]
/usr/lib/libstdc++.so.6(_ZdlPv+0x22)[0x43fc552]
./test[0x8048705]
./test[0x8048712]
/lib/libc.so.6(__libc_start_main+0xe6)[0x391d26]
./test[0x8048611]
======= Memory map: ========
00327000-00328000 r-xp 00000000 00:000          [vdso]
00334000-00351000 r-xp 00000000 08:02926955    /lib/libgcc_s-4.4.7-20120601.so.1
00351000-00352000 rw-p 0001d000 08:02926955    /lib/libgcc_s-4.4.7-20120601.so.1
00355000-00373000 r-xp 00000000 08:02926876     /lib/ld-2.12.so
00373000-00374000 r--p 0001d000 08:02926876     /lib/ld-2.12.so
00374000-00375000 rw-p 0001e000 08:02926876     /lib/ld-2.12.so
0037b000-0050c000 r-xp 00000000 08:02926877     /lib/libc-2.12.so
0050c000-0050e000 r--p 00191000 08:02926877     /lib/libc-2.12.so
0050e000-0050f000 rw-p 00193000 08:02926877     /lib/libc-2.12.so
0050f000-00512000 rw-p 00000000 00:00 0
00543000-0056b000 r-xp 00000000 08:02926889     /lib/libm-2.12.so
0056b000-0056c000 r--p 00027000 08:02926889     /lib/libm-2.12.so
0056c000-0056d000 rw-p 00028000 08:02926889     /lib/libm-2.12.so
0434d000-0442e000 r-xp 00000000 08:02155001     /usr/lib/libstdc++.so.6.0.13
0442e000-04432000 r--p 000e0000 08:02155001     /usr/lib/libstdc++.so.6.0.13
04432000-04434000 rw-p 000e4000 08:02155001     /usr/lib/libstdc++.so.6.0.13
04434000-0443a000 rw-p 00000000 00:00 0
08048000-08049000 r-xp 00000000 08:02419326    /home/wcl/fate/src/app/test/test
08049000-0804a000 rw-p 00000000 08:02419326    /home/wcl/fate/src/app/test/test
09fd7000-09ff8000 rw-p 00000000 00:000          [heap]
b7719000-b771c000 rw-p 00000000 00:00 0
b7727000-b772a000 rw-p 00000000 00:00 0
bfd2a000-bfd3f000 rw-p 00000000 00:000          [stack]
Aborted (core dumped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们对一个已经delete过了的指针再次delete，所以程序down掉了，可以看到在当前目录下已经生成了一个core.4377的文件，4377就是之前程序启动的PID。&lt;/p&gt;

&lt;p&gt;调试core文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb test core.4377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入gdb调试后，键入where命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(gdb) where
#0 0x00327424 in __kernel_vsyscall ()
#1 0x003a5b11 in raise () from /lib/libc.so.6
#2 0x003a73ea in abort () from /lib/libc.so.6
#3 0x003e59d5 in __libc_message () from /lib/libc.so.6
#4 0x003ebe31 in malloc_printerr () from /lib/libc.so.6
#5 0x043fc552 in operator delete(void*) () from/usr/lib/libstdc++.so.6
#6 0x08048705 in fun() ()
#7 0x08048712 in main ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以很明显的看出是在main函数中调用fun函数，之后delete指针的时候出错了，后面的函数调用栈就是程序输出错误信息的部分了，和我们的用户代码无关。到这一步，我们就能推断是是fun()这个函数中delete某个指针的时候出现了错误，就可以有的放矢地查找具体的问题了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用astyle进行代码格式化</title>
          <link>http://blog.fatedier.com/2014/11/10/use-astyle-to-format-code</link>
          <pubDate>Mon, 10 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/11/10/use-astyle-to-format-code</guid>
          <description>

&lt;p&gt;在参与团队的开发的时候，由于平台和编写代码的工具的不同等等问题，经常会遇到代码格式非常混乱的情况，严重影响了代码的阅读效率。后来发现了一款比较好的工具 &amp;ndash; &amp;ldquo;astyle&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;astyle这个工具可以将现有的代码格式转换为指定的风格，当你将乱七八糟的代码用astyle转换一下之后，就会感觉整个世界都清静了……&lt;/p&gt;

&lt;h3 id=&#34;如何获取&#34;&gt;如何获取&lt;/h3&gt;

&lt;p&gt;astyle是一个开放源码的项目，支持C/C++、C#和java的代码格式化&lt;/p&gt;

&lt;p&gt;SourceForge地址: &lt;a href=&#34;http://sourceforge.net/projects/astyle/&#34;&gt;http://sourceforge.net/projects/astyle/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的Github拷贝: &lt;a href=&#34;https://github.com/fatedier/fatedier-tools/tree/master/astyle&#34;&gt;https://github.com/fatedier/fatedier-tools/tree/master/astyle&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;

&lt;p&gt;直接写一个Makefile编译下源码，我的Github的拷贝里有写好的Makefile，直接用gmake命令编译一下就可以用了。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./astyle --style=ansi test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行之后会提示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Formatted  xxx/test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;astyle&lt;/strong&gt; 会在当前目录下生成一个备份文件，以 &lt;strong&gt;.orig&lt;/strong&gt; 结尾，例如 &amp;ldquo;test.cpp.orig&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;test.cpp&lt;/strong&gt; 就已经转换为了 &lt;strong&gt;ansi&lt;/strong&gt; 代码风格了。&lt;/p&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;注：使用 &amp;ndash;help 选项可以查看astyle的帮助文档&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;style风格设置&#34;&gt;style风格设置&lt;/h4&gt;

&lt;p&gt;常用的代码风格主要有三种: &lt;strong&gt;ansi&lt;/strong&gt; 和 &lt;strong&gt;k&amp;amp;r&lt;/strong&gt; 以及 &lt;strong&gt;java&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ndash;style=allman  OR &amp;ndash;style=ansi OR &amp;ndash;style=bsd OR &amp;ndash;style=break OR -A1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Foo()
{
   if (isBar)
    {
       bar();
       return 1;
    }
   else
    {
       return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;style=kr OR &amp;ndash;style=k&amp;amp;r OR &amp;ndash;style=k/r OR -A3&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Foo()
{
   if (isBar) {
       bar();
       return 1;
    }else {
       return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;style=java OR &amp;ndash;style=attach OR -A2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Foo() {
   if (isBar) {
       bar();
       return 1;
    }else {
       return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;tab选项&#34;&gt;Tab选项&lt;/h4&gt;

&lt;p&gt;默认是使用4个空格替换一个tab。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ndash;indent=spaces=# OR -s#&lt;/p&gt;

&lt;p&gt;指定用几个空格替换一个tab，例如 &amp;ndash;indent=spaces=8 ，指定用8个空格替换一个tab。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;indent=tab OR &amp;ndash;indent=tab=# OR -t OR -t#&lt;/p&gt;

&lt;p&gt;指定缩进使用tab，=#同上，指定一个tab占几个空格，不说明的话默认是4个。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;递归处理&#34;&gt;递归处理&lt;/h4&gt;

&lt;p&gt;&amp;ndash;recursive OR -r OR -R&lt;/p&gt;

&lt;p&gt;可以递归处理所有子目录的文件。&lt;/p&gt;

&lt;h4 id=&#34;排除不处理的文件&#34;&gt;排除不处理的文件&lt;/h4&gt;

&lt;p&gt;&amp;ndash;exclude=####&lt;/p&gt;

&lt;p&gt;指定哪些文件或者文件夹不需要进行处理。&lt;/p&gt;

&lt;h4 id=&#34;指定配置文件&#34;&gt;指定配置文件&lt;/h4&gt;

&lt;p&gt;&amp;ndash;options=####&lt;/p&gt;

&lt;p&gt;可以指定读取某个文件的内容作为参数选项。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用Vim打造自己的IDE</title>
          <link>http://blog.fatedier.com/2014/10/29/use-vim-to-make-my-ide</link>
          <pubDate>Wed, 29 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/29/use-vim-to-make-my-ide</guid>
          <description>

&lt;p&gt;之前一直使用UE的FTP功能编辑Linux虚拟机上的代码文件，之后再切换到Linux上去编译，调试程序，感觉这样比较麻烦，而且UE的功能也不像VS以及Eclipse的IDE那样强大，所以就查阅了一些资料，想要把Linux下最常用的文本编辑工具Vim打造成一个适合自己的IDE，可以直接ssh登陆到远程机器上直接进行开发。&lt;/p&gt;

&lt;p&gt;配置自己的Vim过程中参考了以下的blog和文档：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/fbfsber008/article/details/7055842&#34;&gt;http://blog.csdn.net/fbfsber008/article/details/7055842&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.douban.com/note/257815917/&#34;&gt;http://www.douban.com/note/257815917/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/vim-scripts/vundle&#34;&gt;https://github.com/vim-scripts/vundle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-10-29-use-vim-to-make-my-ide-overview.jpg&#34; alt=&#34;overview&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在把整个配置的过程记录下来，方便以后参考。&lt;/p&gt;

&lt;h3 id=&#34;前期准备&#34;&gt;前期准备&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;有一个github帐号&lt;/li&gt;
&lt;li&gt;Linux上安装git版本控制工具，可以使用命令安装，例如 yum install git&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;github是一个好地方，不仅可以浏览很多的开源程序，而且可以把自己正在开发的项目或者有用的文档托管在上面，不管在其他任何的计算机上都可以很容易的获取到。&lt;/p&gt;

&lt;p&gt;比如我的 .vimrc 的配置文件就放在了Github上，有一个版本库是专门用来存放配置文件的。&lt;/p&gt;

&lt;p&gt;地址为：&lt;a href=&#34;https://github.com/fatedier/dot_file&#34;&gt;https://github.com/fatedier/dot_file&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;vim常用配置&#34;&gt;vim常用配置&lt;/h3&gt;

&lt;p&gt;个人的vim配置文件一般是放在用户主目录下的.vimrc文件。&lt;/p&gt;

&lt;p&gt;配置文件中 &lt;code&gt;&amp;quot;&lt;/code&gt; 之后的部分都被当作注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;if v:lang =~ &amp;quot;utf8$&amp;quot; || v:lang =~&amp;quot;UTF-8$&amp;quot;
    set fileencodings=ucs-bom,utf-8,latin1
endif
       
set nocompatible            &amp;quot; Use Vim defaults (much better!)
set bs=indent,eol,start     &amp;quot; allow backspacing overeverything in insert mode
set viminfo=&#39;20,\&amp;quot;50        &amp;quot; read/write a .viminfo file, don&#39;t store more
                            &amp;quot; than 50 lines of registers
set history=50              &amp;quot; keep 50 lines of command line history
set ruler                   &amp;quot; show the cursor position all the time
                                    
&amp;quot; -----------个人设置-----------
filetype off

set ts=4          &amp;quot; tab所占空格数
set shiftwidth=4  &amp;quot; 自动缩进所使用的空格数
set expandtab     &amp;quot; 用空格替换tab
set autoindent    &amp;quot; 自动缩进
set smartindent   &amp;quot; C语言缩进
set number        &amp;quot; 显示行号
set ignorecase    &amp;quot; 搜索忽略大小写
set incsearch     &amp;quot; 输入字符串就显示匹配点
set showtabline=2 &amp;quot; 总是显示标签页
                                      
if has(&amp;quot;mouse&amp;quot;)
    set mouse=iv  &amp;quot; 在 insert 和 visual 模式使用鼠标定位
endif
      
&amp;quot; -------------颜色配置-------------
&amp;quot; 补全弹出窗口
hi Pmenu ctermbg=light magenta
&amp;quot; 补全弹出窗口选中条目
hi PmenuSel ctermbg=yellow ctermfg=black
       
&amp;quot; -------------键盘映射-------------
&amp;quot; Ctrl+S 映射为保存
nnoremap &amp;lt;C-S&amp;gt; :w&amp;lt;CR&amp;gt;
inoremap &amp;lt;C-S&amp;gt;&amp;lt;Esc&amp;gt;:w&amp;lt;CR&amp;gt;a
        
&amp;quot; Ctrl+C 复制，Ctrl+V 粘贴
inoremap &amp;lt;C-C&amp;gt; y
inoremap &amp;lt;C-V&amp;gt; &amp;lt;Esc&amp;gt;pa
vnoremap &amp;lt;C-C&amp;gt; y
vnoremap &amp;lt;C-V&amp;gt; p
nnoremap &amp;lt;C-V&amp;gt; p

&amp;quot; F3 查找当前高亮的单词
inoremap &amp;lt;F3&amp;gt;*&amp;lt;Esc&amp;gt;:noh&amp;lt;CR&amp;gt;:match Todo /\k*\%#\k*/&amp;lt;CR&amp;gt;v
vnoremap &amp;lt;F3&amp;gt;*&amp;lt;Esc&amp;gt;:noh&amp;lt;CR&amp;gt;:match Todo /\k*\%#\k*/&amp;lt;CR&amp;gt;v

&amp;quot; Ctrl+\ 取消缩进
inoremap &amp;lt;C-\&amp;gt; &amp;lt;Esc&amp;gt;&amp;lt;&amp;lt;i
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用vundle管理vim插件&#34;&gt;使用vundle管理vim插件&lt;/h3&gt;

&lt;p&gt;很多时候我们的vim都需要安装大量的插件，需要进行各种配置，而且插件路径下面的文件也会变的非常混乱，这个时候使用 &lt;strong&gt;vundle&lt;/strong&gt; 就是一个不错的选择。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vim-scripts/vundle&#34;&gt;vundle&lt;/a&gt; 是可以算是一个用来管理各种vim插件的插件。&lt;/p&gt;

&lt;h4 id=&#34;安装ctags&#34;&gt;安装ctags&lt;/h4&gt;

&lt;p&gt;直接使用命令 yuminstall ctags 进行安装。&lt;/p&gt;

&lt;p&gt;之后在你的项目文件的根目录中执行如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ctags -R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会发现当前目录下生成了一个名为tags的文件。&lt;/p&gt;

&lt;p&gt;tags文件是由ctags程序产生的一个索引文件，如果你在读程序时看了一个函数调用, 或者一个变量, 或者一个宏等等, 你想知道它们的定义在哪儿，tags文件就起作用了。使用把光标移动到你想查的地方，按下&amp;rdquo;Ctrl + ]&amp;ldquo;，就可以跳转到定义处。&lt;/p&gt;

&lt;p&gt;最后需要在vim配置文件中将tags文件加入到vim中来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;set tags=~/tags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：这里需要填具体的tags文件所在路径。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;先安装vundle这个插件&#34;&gt;先安装vundle这个插件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后其他的插件也都会被放在~/.vim/bundle这个目录下。&lt;/p&gt;

&lt;h4 id=&#34;安装其他需要的插件&#34;&gt;安装其他需要的插件&lt;/h4&gt;

&lt;p&gt;以后当你需要安装其他的vim插件的时候，直接在.vimrc中加上如下部分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;filetype off
 
setrtp+=~/.vim/bundle/vundle/
call vundle#rc()
&amp;quot; Bundles
&amp;quot; 显示变量、函数列表等
Bundle&amp;quot;taglist.vim&amp;quot;
&amp;quot; 窗口管理器
Bundle&amp;quot;winmanager&amp;quot;
&amp;quot; 标签工具
Bundle&amp;quot;Visual-Mark&amp;quot;
&amp;quot; 代码补全工具
Bundle&amp;quot;neocomplcache&amp;quot;
  
filetype pluginindent on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bundle 后面的插件名称用引号引起来，最后在vim中输入:BundleInstall就会完成自动安装，实际上是也是从github上下载各种插件，因为大多数的插件已经备份在了github上的vim-scripts上。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:PluginSearch&lt;/code&gt; 命令可以查看有哪些插件可以直接使用插件名下载的。&lt;/p&gt;

&lt;p&gt;如果你需要的插件在这个里面没有找到，那么在.vimrc配置文件中可以直接用git远程仓库的地址，例如要安装command-t这个插件，可以在配置文件中加上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Bundle &amp;quot;git://git.wincent.com/command-t.git&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就会直接从这个地址上下载所需插件。&lt;/p&gt;

&lt;h3 id=&#34;其他插件的配置与使用&#34;&gt;其他插件的配置与使用&lt;/h3&gt;

&lt;h4 id=&#34;快速浏览源码-taglist&#34;&gt;快速浏览源码：TagList&lt;/h4&gt;

&lt;p&gt;在Windows平台我经常用来浏览项目源码的工具就是SourceInsight，会在窗口左边列出当前文件中的变量、宏、函数名等等，点击以后就会快速跳转到页面相应的地方，使用taglist就可以在vim中实现相同的效果。&lt;/p&gt;

&lt;p&gt;通过vundle安装完成后，在vim中使用 &lt;code&gt;:Tlist&lt;/code&gt; 命令就可以打开TagList窗口。&lt;/p&gt;

&lt;h4 id=&#34;窗口管理器-winmanager&#34;&gt;窗口管理器：WinManager&lt;/h4&gt;

&lt;p&gt;WinManager可以帮助我们管理在屏幕上显示的多个窗口。&lt;/p&gt;

&lt;p&gt;之后我们需要设置一下在normal模式下可以直接输入wm来打开文件管理窗口以及TagList，.vimrc文件增加如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:winManagerWindowLayout=&#39;FileExplorer|TagList&#39;
nnoremap wm:WMToggle&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：nnoremap是设置键盘映射。第一个字母n是normal模式，i是insert模式，v是visual模式。加上nore表示不会递归替换命令，比如a映射到b，b映射到c，那么按a不会得到按c的效果。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;高亮标签-visualmark&#34;&gt;高亮标签：VisualMark&lt;/h4&gt;

&lt;p&gt;这个插件的作用就是在浏览代码的时候在指定的行上添加标签，之后可以快速跳转回来，方便快捷。&lt;/p&gt;

&lt;p&gt;安装完成之后直接就可以在vim中使用。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;mm&amp;rdquo; 命令会在当前行添加标签，再次按 &amp;ldquo;mm&amp;rdquo; 会取消标签。&lt;/p&gt;

&lt;p&gt;按下“F2”可以在多个标签之间进行快速跳转。&lt;/p&gt;

&lt;h4 id=&#34;自动补全-neocomplcache&#34;&gt;自动补全：neocomplcache&lt;/h4&gt;

&lt;p&gt;这个补全插件需要tags文件的支持，所以需要安装ctags，并且在项目根目录生成tags文件，之后在.vimrc中加入这个tags文件。&lt;/p&gt;

&lt;p&gt;并且在配置文件中加上如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:neocomplcache_enable_at_startup = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行是设置是否自动启用补全，为1代表启用。这样就不需要每次都使用Ctrl+P或者Ctrl+N来弹出补全列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:neocomplcache_enable_auto_select = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行是设置是否启用自动选择，为1代表启用。这个时候弹出补全列表的时候会自动选择第一个，按下Enter键就会使用列表的第一项，否则每一次都需要自己多按一次进行选择。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>vimdiff常用命令</title>
          <link>http://blog.fatedier.com/2014/10/24/vimdiff-common-commands</link>
          <pubDate>Fri, 24 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/24/vimdiff-common-commands</guid>
          <description>

&lt;p&gt;整理了一下在使用vimdiff进行文件合并的时候用到的一些常用的命令，方便以后查询。&lt;/p&gt;

&lt;p&gt;可以有多种方式使用vimdiff，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vimdiff [file1] [file2]

vim -d [file1] [file2]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;其他的一些的编辑命令与vim相同，这里主要记录一些常用的合并文件需要用到的命令：&lt;/p&gt;

&lt;h4 id=&#34;ctrl-w之后按w&#34;&gt;Ctrl+w之后按w&lt;/h4&gt;

&lt;p&gt;可以切换到另外一个文件&lt;/p&gt;

&lt;h4 id=&#34;c&#34;&gt;[c&lt;/h4&gt;

&lt;p&gt;跳转到上一个差异点&lt;/p&gt;

&lt;h4 id=&#34;c-1&#34;&gt;]c&lt;/h4&gt;

&lt;p&gt;跳转到下一个差一点&lt;/p&gt;

&lt;h4 id=&#34;zo或者i&#34;&gt;zo或者i&lt;/h4&gt;

&lt;p&gt;展开折叠区域，或者使用i进入插入模式也会进行展开&lt;/p&gt;

&lt;h4 id=&#34;zc&#34;&gt;zc&lt;/h4&gt;

&lt;p&gt;重新折叠，可以把使用zo展开折叠的区域恢复原样&lt;/p&gt;

&lt;h4 id=&#34;dp-diff-put的意思&#34;&gt;dp（diff put的意思）&lt;/h4&gt;

&lt;p&gt;把当前文件的差异点内容复制到另一个文件&lt;/p&gt;

&lt;h4 id=&#34;do-diff-obtain的意思&#34;&gt;do（diff obtain的意思）&lt;/h4&gt;

&lt;p&gt;把另一个文件的差异点内容复制到当前文件&lt;/p&gt;

&lt;h4 id=&#34;diffupdate&#34;&gt;:diffupdate&lt;/h4&gt;

&lt;p&gt;有时候修改了文件之后不会立即刷新重新比对，使用该命令可以重新进行文件比较。&lt;/p&gt;

&lt;h4 id=&#34;qa&#34;&gt;qa&lt;/h4&gt;

&lt;p&gt;退出所有打开的文件，但是不保存&lt;/p&gt;

&lt;h4 id=&#34;wqa&#34;&gt;wqa&lt;/h4&gt;

&lt;p&gt;退出并保存所有已打开的文件&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Git常用命令</title>
          <link>http://blog.fatedier.com/2014/10/17/git-usually-command</link>
          <pubDate>Fri, 17 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/17/git-usually-command</guid>
          <description>

&lt;p&gt;在用Git进行项目管理的时候有一些经常会遇到的问题处理起来比较复杂，本文记录了一些常用的命令和操作。&lt;/p&gt;

&lt;h3 id=&#34;修改某一次提交的说明信息&#34;&gt;修改某一次提交的说明信息&lt;/h3&gt;

&lt;p&gt;有时候我们需要修改之前提交的时候的说明信息，没有操作命令可以直接完成，但是使用rebase命令可以实现。&lt;/p&gt;

&lt;p&gt;例如我们要修改倒数第二次的提交的说明信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：这里HEAD~后面跟着的是3而不是2，因为这里指的是要修改的提交的父提交。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;之后会进入到文本编辑界面，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-10-17-git-usually-command-git-reset-commit-message.jpg&#34; alt=&#34;reset-commit-message&#34; /&gt;&lt;/p&gt;

&lt;p&gt;将要修改的提交前面的 &lt;strong&gt;pick&lt;/strong&gt; 改为 &lt;strong&gt;edit&lt;/strong&gt; ，保存后退出。&lt;/p&gt;

&lt;p&gt;这个时候执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以修改该次提交的说明了，修改完成后保存并退出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git rebase --continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行这条命令后，后续的提交说明将不会改变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：不要修改已经push到远程仓库的提交！！！会引起版本混乱，使提交历史变的不清晰！&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看-删除-重命名远程分支&#34;&gt;查看、删除、重命名远程分支&lt;/h3&gt;

&lt;p&gt;查看所有的分支（包括远程分支）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git branch -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个分支已经被合并到主分支后，我们通常会删除这个分支，如果仅仅 git branch -d 是删除本地分支&lt;/p&gt;

&lt;p&gt;删除远程分支的话可以使用如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push origin --delete &amp;lt;branchName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重命名一个分支不是很常用，可以先删除远程分支，再重命名本地分支，之后将重命名后的本地分支推送到远程仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push --delete origin &amp;lt;branchName&amp;gt;

$ git branch -m &amp;lt;branchName&amp;gt; &amp;lt;newBranchName&amp;gt;

$ git push origin &amp;lt;newBranchName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;合并多个提交&#34;&gt;合并多个提交&lt;/h3&gt;

&lt;p&gt;比如要合并最后两次的提交，其实和修改某一次提交的说明信息有点类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git rebase -i HEAD~2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后同样会进入到文本编辑界面，将第二行开头的 &lt;strong&gt;pick&lt;/strong&gt; 改为 &lt;strong&gt;squash&lt;/strong&gt; 或 &lt;strong&gt;s&lt;/strong&gt;，保存后退出。&lt;/p&gt;

&lt;p&gt;这时git会把两次提交合并，并且提示让你输入新的提交信息，保存后退出就成功完成两次提交的合并了。&lt;/p&gt;

&lt;h3 id=&#34;强制回退远程仓库到指定提交&#34;&gt;强制回退远程仓库到指定提交&lt;/h3&gt;

&lt;p&gt;当我们在开发的时候出现一些关键性的错误，并且确认现在已经做的开发工作是无意义的时候，可能需要回退到之前的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git reset --hard &amp;lt;commit_id&amp;gt;

$ git push origin HEAD --force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，reset命令还有几个可选参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;git reset &amp;ndash;mixed&lt;/strong&gt;：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;git reset &amp;ndash;soft&lt;/strong&gt;：回退到某个版本，只回退了commit的信息，不会恢复到indexfile一级。如果还要提交，直接commit即可。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;git reset &amp;ndash;hard&lt;/strong&gt;：彻底回退到某个版本，本地的源码也会变为上一个版本的内容。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;reset-hard之后的恢复&#34;&gt;reset &amp;ndash;hard之后的恢复&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;git reset --hard&lt;/code&gt; 之后，也许才发现这是一次错误的操作，那么我们就想要恢复到之前的版本。&lt;/p&gt;

&lt;p&gt;这个时候用git log是看不到之前的提交历史记录的。&lt;/p&gt;

&lt;p&gt;需要使用 &lt;code&gt;$ git reflog&lt;/code&gt; 找到我们需要恢复的HEAD的ID，然后使用reset命令恢复回去。&lt;/p&gt;

&lt;h3 id=&#34;查看指定版本的某个文件的内容&#34;&gt;查看指定版本的某个文件的内容&lt;/h3&gt;

&lt;p&gt;例如要查看 f4869b0 这次提交的 test.cpp 文件的内容，test.cpp的路径需要使用相对于git目录的路径名，使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git show f4869b0:test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件的内容会全部显示在界面上，可以使用文件重定向到另外的文件，再进行后续操作。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Git使用备忘</title>
          <link>http://blog.fatedier.com/2014/10/16/git-use-for-remind</link>
          <pubDate>Thu, 16 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/16/git-use-for-remind</guid>
          <description>

&lt;p&gt;Git是一款免费、开源的分布式版本控制系统，由于 GitHub 的存在，我们很方便的用于管理我们平时的开发项目。&lt;/p&gt;

&lt;p&gt;Git的命令较多，虽然大多数都不是很常用，但是还是需要记下来方便日后查看。&lt;/p&gt;

&lt;h3 id=&#34;git的配置&#34;&gt;Git的配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 &amp;ndash;system 选项，读写的就是这个文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 &amp;ndash;global 选项，读写的就是这个文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所.git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。&lt;/p&gt;

&lt;h4 id=&#34;设置用户信息&#34;&gt;设置用户信息&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git config --globaluser.name  &amp;quot;your-uasername&amp;quot;
$ git config --global user.email example@example.com
$ git config --global core.editor vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;设置差异分析工具&#34;&gt;设置差异分析工具&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git config --global merge.tool vimdiff
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;如何获取帮助文档&#34;&gt;如何获取帮助文档&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help
$ man git-&amp;lt;verb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如 &lt;code&gt;man git-config&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;git基础操作&#34;&gt;Git基础操作&lt;/h3&gt;

&lt;h4 id=&#34;取得git仓库-从现有仓库克隆&#34;&gt;取得Git仓库（从现有仓库克隆）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/schacon/fatest.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会在当前目录下创建一个fatest的目录，其中的.git目录保存所有的版本记录。fatest下是项目的所有文件。&lt;/p&gt;

&lt;p&gt;如果要自定义目录名称，可以在末尾指定，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/schacon/fatest.git fatestnew
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在创建的目录就是fatestnew而不是fatest了，其他的都一样。&lt;/p&gt;

&lt;h4 id=&#34;检查当前项目文件状态&#34;&gt;检查当前项目文件状态&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到有哪些文件是没有加入到版本中的，哪些是修改了还没提交的等等。&lt;/p&gt;

&lt;h4 id=&#34;将新文件加入到版本中&#34;&gt;将新文件加入到版本中&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git add test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;git add&lt;/code&gt;命令对于不同状态的文件有不同的效果，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。&lt;/p&gt;

&lt;p&gt;*注意*修改过后的文件处于未暂存状态，提交的时候处于未暂存状态的文件将不会提交，需要使用git add命令更改为暂存状态，之后再提交就会提交到仓库中了。&lt;/p&gt;

&lt;h4 id=&#34;忽略某些文件&#34;&gt;忽略某些文件&lt;/h4&gt;

&lt;p&gt;对于不需要加入到版本中，并且使用git status时不再提示的文件。&lt;/p&gt;

&lt;p&gt;在 .gitignore 文件中进行配置，例如*.exe&lt;/p&gt;

&lt;p&gt;那么所有的以.exe结尾的文件都会被忽略，而不再提醒。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 此为注释，将被 Git 忽略
# 忽略所有 .a 结尾的文件
*.a
# 但 lib.a 除外
!lib.a
# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO
# 忽略 build/ 目录下的所有文件
build/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看已暂存和未暂存的更新文件差异&#34;&gt;查看已暂存和未暂存的更新文件差异&lt;/h4&gt;

&lt;p&gt;未暂存：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git diff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已暂存：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git diff --staged
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;提交更新&#34;&gt;提交更新&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后进入vim编辑提交说明，保存即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git commit --m &amp;quot;comment&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;em&gt;-m&lt;/em&gt; 命令可以直接在一行命令中写说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git commit -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;em&gt;-a&lt;/em&gt; 命令，会把未暂存和已暂存的文件一起提交，不然只会提交已暂存的文件。&lt;/p&gt;

&lt;h4 id=&#34;删除文件和取消跟踪&#34;&gt;删除文件和取消跟踪&lt;/h4&gt;

&lt;p&gt;可以先本地使用rm命令删掉，这时候放在未暂存区域，之后用“git rm文件名”删掉。&lt;/p&gt;

&lt;p&gt;也可以直接使用 &lt;code&gt;git rm 文件名&lt;/code&gt; 删掉。&lt;/p&gt;

&lt;p&gt;另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 &amp;ndash;cached 选项即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git rm --cached readme.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动文件&#34;&gt;移动文件&lt;/h4&gt;

&lt;p&gt;例如要把 test.cpp 改为 tt.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git mv test.cpp tt.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就相当于是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mv README.txt README
$ git rm README.txt
$ git add README
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看提交历史&#34;&gt;查看提交历史&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git log
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;撤销操作&#34;&gt;撤销操作&lt;/h4&gt;

&lt;h5 id=&#34;覆盖上一次的提交&#34;&gt;覆盖上一次的提交&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会将上次提交和这次提交合并起来，算作一次提交。&lt;/p&gt;

&lt;h5 id=&#34;取消已暂存文件&#34;&gt;取消已暂存文件&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git reset HEAD &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候文件状态就从已暂存变为未暂存&lt;/p&gt;

&lt;h5 id=&#34;取消对文件的修改-还没有放到暂存区&#34;&gt;取消对文件的修改（还没有放到暂存区）&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout -- &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;运程仓库的使用&#34;&gt;运程仓库的使用&lt;/h4&gt;

&lt;h5 id=&#34;查看当前的远程库&#34;&gt;查看当前的远程库&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会列出每个远程库的简短的名字，默认使用origin表示原始仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会额外列出远程库对应的克隆地址&lt;/p&gt;

&lt;h5 id=&#34;添加远程仓库&#34;&gt;添加远程仓库&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote add [shortname] [url]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;从远程仓库抓取数据&#34;&gt;从远程仓库抓取数据&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git fetch [remote-name]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抓取数据，但并不合并到当前分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git pull
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动抓取数据，并自动合并到当前分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git branch -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看所有远程分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout -b test origin/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取远程分支到本地新的分支上，并切换到新分支&lt;/p&gt;

&lt;h5 id=&#34;推送数据到远程仓库&#34;&gt;推送数据到远程仓库&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push [remote-name] [branch-name]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推送操作会默认使用origin和master名字&lt;/p&gt;

&lt;h5 id=&#34;查看远程仓库信息&#34;&gt;查看远程仓库信息&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote show [remote-name]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 git pull 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。&lt;/p&gt;

&lt;h5 id=&#34;远程仓库的删除&#34;&gt;远程仓库的删除&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git remote rm [remote-name]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;标签的使用&#34;&gt;标签的使用&lt;/h4&gt;

&lt;h5 id=&#34;显示已有的标签&#34;&gt;显示已有的标签&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git tag
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;新建标签&#34;&gt;新建标签&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git tag v1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建一个简单的标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git tag -a v1.0 -m &#39;my version 1.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-m 指定了对应标签的说明&lt;/p&gt;

&lt;h5 id=&#34;后期加注标签&#34;&gt;后期加注标签&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git log --pretty=oneline --abbrev-commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先显示提交历史&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git tag -a v1.1 9fceb02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补加标签&lt;/p&gt;

&lt;h5 id=&#34;推送标签&#34;&gt;推送标签&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push origin [tagname]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;设置命令别名&#34;&gt;设置命令别名&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git config --global alias.co checkout
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;git分支&#34;&gt;Git分支&lt;/h3&gt;

&lt;h4 id=&#34;新建分支&#34;&gt;新建分支&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git branch testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会在当前commit对象上新建一个分支指针&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：HEAD这个特别的指针是指向正在工作中的本地分支的指针&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;切换分支&#34;&gt;切换分支&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换到testing分支上&lt;/p&gt;

&lt;h4 id=&#34;分支的合并&#34;&gt;分支的合并&lt;/h4&gt;

&lt;p&gt;在master分支上，执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git merge testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将tesing分支合并回master&lt;/p&gt;

&lt;h4 id=&#34;使用合并工具-可以自己设置-例如设置成vimdiff&#34;&gt;使用合并工具（可以自己设置，例如设置成vimdiff）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git mergetool
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分支的管理&#34;&gt;分支的管理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git branch --merged
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看哪些分支已经被并入当前分支，通常这些都可以删除了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git branch -d testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除一个分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git branch -D testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果该分支尚没有合并，可以使用-D选项强制删除。&lt;/p&gt;

&lt;h4 id=&#34;推送本地分支&#34;&gt;推送本地分支&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push origin testing
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分支的衍合&#34;&gt;分支的衍合&lt;/h4&gt;

&lt;p&gt;例如现在有两个分支，一个master，一个testing&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout testing
$ git rebase master
$ git checkout master
$ git merge testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常在贡献自己的代码之前先衍合，再提交，会让历史提交记录更清晰。&lt;/p&gt;

&lt;h3 id=&#34;git调试&#34;&gt;Git调试&lt;/h3&gt;

&lt;h4 id=&#34;文件标注&#34;&gt;文件标注&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git blame -L 12,22 test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看test.cpp文件对每一行进行修改的最近一次提交。&lt;/p&gt;

&lt;h4 id=&#34;查看文件的历史提交&#34;&gt;查看文件的历史提交&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git log --pretty=oneline test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看test.cpp文件的历史提交记录&lt;/p&gt;

&lt;h4 id=&#34;查看文件的历史版本&#34;&gt;查看文件的历史版本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git show [commit] [file]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;code&gt;$ git show 7da7c23 test.cpp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看7da7c23这次提交的test.cpp文件。&lt;/p&gt;

&lt;h4 id=&#34;查看历史提交的详细文件变化&#34;&gt;查看历史提交的详细文件变化&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git log -p -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这条命令可以看到最近两次提交的文件变化情况，删除的部分会以 &amp;ldquo;-&amp;rdquo; 开头，新增的部分会以 &amp;ldquo;+&amp;rdquo; 开头，方便查看。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>学习Git的常用网站</title>
          <link>http://blog.fatedier.com/2014/10/16/learn-git-website</link>
          <pubDate>Thu, 16 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/16/learn-git-website</guid>
          <description>

&lt;p&gt;学习Git的使用的过程中参考了很多的网站，主要是两个地方讲的比较清楚，例子也很丰富，特别记录一下。&lt;/p&gt;

&lt;h4 id=&#34;git官方文档&#34;&gt;Git官方文档&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://git-scm.com/book/zh/&#34;&gt;http://git-scm.com/book/zh/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;廖雪峰git教程&#34;&gt;廖雪峰Git教程&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
