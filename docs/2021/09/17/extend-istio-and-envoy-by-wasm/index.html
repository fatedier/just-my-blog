<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Istio 在 1.5 版本(2020年5月)中宣布支持 WebAssembly 扩展，通过定制化的 envoy 实现。">
<meta property="og:url" content="https://blog.fatedier.com/"><meta property="og:type" content="article">
<meta property="og:title" content="通过 WebAssembly 扩展 Istio 和 Envoy - fatedier blog"><meta property="og:site_name" content="fatedier blog">

<title>
    
    通过 WebAssembly 扩展 Istio 和 Envoy
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">fatedier blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/诗与远方/">诗与远方</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="blog.fatedier.com"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2021年09月17日 
                </div>
                <h1 class="post-title">通过 WebAssembly 扩展 Istio 和 Envoy</h1>
            </header>

            <div class="post-content">
                <p>Istio 在 1.5 版本(2020年5月)中宣布支持 WebAssembly 扩展，通过定制化的 envoy 实现。</p>
<p>Enovy 对 WASM 支持相关的修改在 2020年10月 被合入到上游社区。</p>
<p>Istio 在 1.9，1.10 中都对 WASM 模块的分发做了优化。</p>
<h3 id="背景">背景</h3>
<p>WebAssembly 给 Istio 这样的项目带来了非常大的可扩展性，且没有增加太多的性能损失。</p>
<p>目前一些主流的方向，包括 Mesh(典型的例如 <a href="https://github.com/dapr/dapr">Dapr</a>)，以及 Serverless，对可扩展性和性能的需求都比较强烈。WebAssembly 可以做到高性能，跨平台，多语言，易于分发，非常适合这些场景。相比于 Docker，WebAssembly 拥有更快的启动速度。</p>
<h4 id="wasmwasi">WASM/WASI</h4>
<p>WebAssembly 是一种新的字节码格式，旨在成为高级语言的编译目标，目前可以使用 C、C++、Rust、Go、Java 等语言来创建 wasm 模块。该模块以二进制的格式发送到浏览器，并在专有虚拟机上执行，与 JavaScript 虚拟机共享内存和线程等资源。</p>
<p>WASM 的初衷应该是解决 JS 在前端执行效率低的问题。并且，也附带着，可以让前端开发使用更多的其他语言的现成的库。</p>
<p><a href="https://github.com/WebAssembly/WASI">WASI</a> 全称是 WebAssembly System Interface，这个标准从 2019 年开始建立，可以简单的理解成是一套操作系统接口。原先 WebAssembly 在前端只需要和浏览器（JS）交互，但是 WASI 提供了一种可能性，可以使 WASM 模块运行于浏览器之外的环境，应用到后端服务上。这套接口定义了诸如文件存取，网络访问等等需要操作系统提供的能力，之后在不同的平台上，或者不同的语言里，去实现这些 ABI 接口。</p>
<p>目前 WASI 仍然处于迭代阶段，特性也不稳定，可能随时会有调整，整个社区都处于摸索，试验的过程中。</p>
<h4 id="proxy-wasm">proxy-wasm</h4>
<p>WebAssembly for Proxies，是 Istio/Envoy 社区针对网络代理设计的一套 ABI 接口，用于定义代理和 WASM 扩展之间的通信协议。</p>
<p>proxy-wasm ABI 定义主要分为两部分，Host Environment 函数和 Wasm 模块函数。</p>
<p>Host Environment 函数是代理需要暴露给 Wasm 模块调用的。比如通过暴露 <code>proxy_log</code> 函数，在用户编写的 Wasm 模块中就可以调用这个函数来在 enovy 的标准输出中打印日志信息。这部分函数由代理实现。</p>
<p>Wasm 模块函数是用户需要自己编写的实际处理函数，比如在有请求到来时，需要增加一个 header 字段，就需要实现 <code>proxy_on_http_request_headers</code> 函数。</p>
<p>另外，由于 runtime 和 wasm 之间的交互性能问题，通常会采用传递字符串内存地址，而不是在函数入参中传递字符串的方式来进行函数调用。比如 proxy_log 的入参是 <code>i32 (proxy_log_level_t) log_level i32 (const char*) message_data i32 (size_t) message_size</code>。</p>
<p>Map 类型也是一个特例，由于内存模型的问题，也不能直接传递 map 的指针来使用。拿 <code>proxy_on_http_request_headers</code> 举例，它的入参是 <code>i32 (uint32_t) context_id i32 (size_t) num_headers i32 (bool) end_of_stream</code>。并没有传入 map 类型的 header 信息。用户实现该函数时，需要调用 <code>proxy_get_map</code> 或者 <code>proxy_get_map_value</code> 这两个 Host Environment 函数来获取 header 信息。<code>proxy_get_map_value</code> 获取到的是一个字符串，比较好理解，直接传字符串指针就可以了。<code>proxy_get_map</code> 比较特殊，需要传递整个 map，又不能直接传指针，所以就需要做一次转换，重新序列化成字符串来传递。格式为 <code>key-size,value-size,key-size,value-size... key,value,key,value...</code>。在用户自己编写的 WASM 模块中，需要重新反序列化成 map 的形式。</p>
<p>总而言之，proxy-wasm 定义了一套代理和扩展之间交互的接口的细节，相比于高级语言之间的简单的函数调用，和 wasm 扩展之间的交互显然要更复杂一些。</p>
<p>所以社区提供了 <a href="https://github.com/tetratelabs/proxy-wasm-go-sdk">proxy-wasm-go-sdk</a>, <a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk">proxy-wasm-rust-sdk</a> 这样的开发框架，将 wasm 模块和 Host Environment 函数之间的交互细节屏蔽，提供了更易于用户使用的接口。</p>
<h3 id="编写-proxy-wasm-扩展">编写 proxy-wasm 扩展</h3>
<p>目前 C++ 和 Rust 是支持的比较好的两种语言，生态也比较完善。Istio 自身的一些监测，统计的扩展也是使用 C++ 开发 WASM 模块来实现(目前是以 webassembly 的形式预编译进 enovy，wasm runtime 是 envoy.wasm.runtime.null，比较特殊)。</p>
<p>WebAssembly 的很多定义都和 rust 强相关，rust 在这方面的生态也比较完善，但是相对来说，rust 在整体的语言生态方面还不是很成熟，缺乏丰富、成熟度高的第三方库的支持，质量也层次不齐。</p>
<p>Go 在 wasm 方面的成熟度非常低，但是标准库和语言生态相对比较完善，可复用的库比较多。</p>
<h4 id="rust">Rust</h4>
<p>使用 <a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk">https://github.com/proxy-wasm/proxy-wasm-rust-sdk</a></p>
<h5 id="环境">环境</h5>
<p>安装 rust 相关工具</p>
<p><code>curl https://sh.rustup.rs -sSf | sh</code></p>
<p>更新 rust 版本</p>
<p><code>rustup update</code></p>
<p>增加编译 wasm target</p>
<p><code>rustup target add wasm32-unknown-unknown</code></p>
<h5 id="创建项目">创建项目</h5>
<p>cargo 是 rust 的包管理工具，rust 中的包叫做 crate。</p>
<p><code>cargo init --lib</code></p>
<p>编辑 Cargo.toml 文件，配置依赖版本。</p>
<pre tabindex="0"><code>[dependencies]
log = &#34;0.4&#34;
proxy-wasm = &#34;0.1.4&#34; # The Rust SDK for proxy-wasm
</code></pre><p>修改 crate 类型为动态链接库</p>
<pre tabindex="0"><code>[lib]
path = &#34;src/lib.rs&#34;
crate-type = [&#34;cdylib&#34;]
</code></pre><p>编辑 src/lib.rs 文件，copy 如下的官方示例代码</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#cdcd00">use</span> log::trace;
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">use</span> proxy_wasm::traits::<span style="color:#39c">*</span>;
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">use</span> proxy_wasm::types::<span style="color:#39c">*</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#000080">#[no_mangle]</span>
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">pub</span> <span style="color:#cdcd00">fn</span> _start() {
</span></span><span style="display:flex;"><span>    proxy_wasm::set_log_level(LogLevel::Trace);
</span></span><span style="display:flex;"><span>    proxy_wasm::set_root_context(<span style="color:#39c">|</span>_<span style="color:#39c">|</span> -&gt; <span style="color:#cd00cd">Box</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">dyn</span> RootContext<span style="color:#39c">&gt;</span> { <span style="color:#cd00cd">Box</span>::new(HttpHeadersRoot) });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">HttpHeadersRoot</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">impl</span> Context <span style="color:#cdcd00">for</span> HttpHeadersRoot {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">impl</span> RootContext <span style="color:#cdcd00">for</span> HttpHeadersRoot {
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">fn</span> get_type(<span style="color:#39c">&amp;</span>self) -&gt; <span style="color:#cd00cd">Option</span><span style="color:#39c">&lt;</span>ContextType<span style="color:#39c">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#cd00cd">Some</span>(ContextType::HttpContext)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">fn</span> create_http_context(<span style="color:#39c">&amp;</span>self, context_id: <span style="color:#00cd00">u32</span>) -&gt; <span style="color:#cd00cd">Option</span><span style="color:#39c">&lt;</span><span style="color:#cd00cd">Box</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">dyn</span> HttpContext<span style="color:#39c">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#cd00cd">Some</span>(<span style="color:#cd00cd">Box</span>::new(HttpHeaders { context_id }))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">HttpHeaders</span> {
</span></span><span style="display:flex;"><span>    context_id: <span style="color:#00cd00">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">impl</span> Context <span style="color:#cdcd00">for</span> HttpHeaders {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cdcd00">impl</span> HttpContext <span style="color:#cdcd00">for</span> HttpHeaders {
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">fn</span> on_http_request_headers(<span style="color:#39c">&amp;</span><span style="color:#cdcd00">mut</span> self, _: <span style="color:#00cd00">usize</span>) -&gt; <span style="color:#00cdcd">Action</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#cdcd00">for</span> (name, value) <span style="color:#cdcd00">in</span> <span style="color:#39c">&amp;</span>self.get_http_request_headers() {
</span></span><span style="display:flex;"><span>            trace<span style="color:#39c">!</span>(<span style="color:#cd0000">&#34;#{} -&gt; {}: {}&#34;</span>, self.context_id, name, value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#cdcd00">match</span> self.get_http_request_header(<span style="color:#cd0000">&#34;:path&#34;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#cd00cd">Some</span>(path) <span style="color:#cdcd00">if</span> path <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;/hello&#34;</span> <span style="color:#39c">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.send_http_response(
</span></span><span style="display:flex;"><span>                    <span style="color:#cd00cd">200</span>,
</span></span><span style="display:flex;"><span>                    vec![(<span style="color:#cd0000">&#34;Hello&#34;</span>, <span style="color:#cd0000">&#34;World&#34;</span>), (<span style="color:#cd0000">&#34;Powered-By&#34;</span>, <span style="color:#cd0000">&#34;proxy-wasm&#34;</span>)],
</span></span><span style="display:flex;"><span>                    <span style="color:#cd00cd">Some</span>(<span style="color:#cd0000">b&#34;Hello, World!</span><span style="color:#cd0000">\n</span><span style="color:#cd0000">&#34;</span>),
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>                Action::Pause
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#39c">=&gt;</span> Action::Continue,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">fn</span> on_log(<span style="color:#39c">&amp;</span><span style="color:#cdcd00">mut</span> self) {
</span></span><span style="display:flex;"><span>        trace<span style="color:#39c">!</span>(<span style="color:#cd0000">&#34;#{} completed.&#34;</span>, self.context_id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码，会在收到请求的 rquest path 为 <code>/hello</code> 时，直接返回 Hello World 以及指定的 header，否则透传请求。</p>
<p>我们需要实现的就是 <code>on_http_request_headers</code> 这个函数中的内容，通过 <code>self.get_http_request_headers</code> 和 <code>self.get_http_request_header</code> 进行与代理之间的数据交互。</p>
<h5 id="编译">编译</h5>
<p>编译出 wasm 文件</p>
<p><code>cargo build --target wasm32-unknown-unknown --release</code></p>
<p>生成的 wasm 文件被放在 <code>target/wasm32-unknown-unknown/release</code> 下，以 <code>.wasm</code> 为后缀。</p>
<p>文件大小大约 250KB。</p>
<h4 id="go">Go</h4>
<p>使用 <a href="https://github.com/tetratelabs/proxy-wasm-go-sdk">https://github.com/tetratelabs/proxy-wasm-go-sdk</a></p>
<p>由于 Go 官方并不支持直接编译出 WASI 适配的 wasm 模块，目前官方支持的只有 js/wasm，仅用于在浏览器环境中运行，且从社区 issue 中来看，最近几年内可能都不会有进展。官方可能认为 WASI 目前的 spec 仍然不成熟，可能随时会有变化，不太适合在早期就在标准库中做支持。</p>
<p>我们需要借助于 <a href="https://github.com/tinygo-org/tinygo">tinygo</a> 这个项目来编译出支持 wasi 的模块。</p>
<p>需要注意的是，tinygo 目前在协程，反射等方面支持的不完全，可能会影响到某些库的使用。比如标准库的 json 依赖反射，所以并不是所有的结构体都可以使用标准库来做 json 序列化。</p>
<h5 id="环境-1">环境</h5>
<p>TinyGo 当前 0.19.0 版本不支持 Go1.17，我们需要切换到 Go1.16。</p>
<p>安装 TinyGo，可以从 Github Release 页面下载对应系统平台的压缩包。</p>
<p>解压缩到 home 目录下并且将 <code>{HOME}/tinygo/bin</code> 加入到 PATH 环境变量中。</p>
<p>执行 <code>tinygo env</code> 查看 <code>TINYGOROOT</code> 是否是 <code>{HOME}/tinygo/bin</code>，如果不是，则需要自己手动配置一下。</p>
<h5 id="创建项目-1">创建项目</h5>
<p>生成 go.mod 文件</p>
<p><code>go mod init test</code></p>
<p>编辑 main.go 文件</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cd00cd">package</span> main
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#cd00cd">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#cd0000">&#34;github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#cd0000">&#34;github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00cd00">func</span> main() {
</span></span><span style="display:flex;"><span>    proxywasm.SetVMContext(<span style="color:#39c">&amp;</span>vmContext{})
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00cd00">type</span> vmContext <span style="color:#00cd00">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000080">// Embed the default VM context here,
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>    <span style="color:#000080">// so that we don&#39;t need to reimplement all the methods.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>    types.DefaultVMContext
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#000080">// Override types.DefaultVMContext.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (<span style="color:#39c">*</span>vmContext) NewPluginContext(contextID <span style="color:#00cd00">uint32</span>) types.PluginContext {
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">return</span> <span style="color:#39c">&amp;</span>pluginContext{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00cd00">type</span> pluginContext <span style="color:#00cd00">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000080">// Embed the default plugin context here,
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>    <span style="color:#000080">// so that we don&#39;t need to reimplement all the methods.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>    types.DefaultPluginContext
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#000080">// Override types.DefaultPluginContext.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (<span style="color:#39c">*</span>pluginContext) NewHttpContext(contextID <span style="color:#00cd00">uint32</span>) types.HttpContext {
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">return</span> <span style="color:#39c">&amp;</span>httpHeaders{contextID: contextID}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00cd00">type</span> httpHeaders <span style="color:#00cd00">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000080">// Embed the default http context here,
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>    <span style="color:#000080">// so that we don&#39;t need to reimplement all the methods.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>    types.DefaultHttpContext
</span></span><span style="display:flex;"><span>    contextID <span style="color:#00cd00">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#000080">// Override types.DefaultHttpContext.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (ctx <span style="color:#39c">*</span>httpHeaders) OnHttpRequestHeaders(numHeaders <span style="color:#00cd00">int</span>, endOfStream <span style="color:#00cd00">bool</span>) types.Action {
</span></span><span style="display:flex;"><span>    err <span style="color:#39c">:=</span> proxywasm.ReplaceHttpRequestHeader(<span style="color:#cd0000">&#34;test&#34;</span>, <span style="color:#cd0000">&#34;best&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
</span></span><span style="display:flex;"><span>        proxywasm.LogCritical(<span style="color:#cd0000">&#34;failed to set request header: test&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    hs, err <span style="color:#39c">:=</span> proxywasm.GetHttpRequestHeaders()
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
</span></span><span style="display:flex;"><span>        proxywasm.LogCriticalf(<span style="color:#cd0000">&#34;failed to get request headers: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">for</span> _, h <span style="color:#39c">:=</span> <span style="color:#cdcd00">range</span> hs {
</span></span><span style="display:flex;"><span>        proxywasm.LogWarnf(<span style="color:#cd0000">&#34;request header --&gt; %s: %s&#34;</span>, h[<span style="color:#cd00cd">0</span>], h[<span style="color:#cd00cd">1</span>])
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">return</span> types.ActionContinue
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#000080">// Override types.DefaultHttpContext.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (ctx <span style="color:#39c">*</span>httpHeaders) OnHttpStreamDone() {
</span></span><span style="display:flex;"><span>    proxywasm.LogWarnf(<span style="color:#cd0000">&#34;%d finished&#34;</span>, ctx.contextID)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>OnHttpRequestHeaders</code> 函数是实现我们具体逻辑的地方，通过 <code>proxywasm.ReplaceHttpRequestHeader</code> 和 <code>proxywasm.GetHttpRequestHeaders</code> 函数来和代理进行数据交互。</p>
<p>这里用了 <code>proxywasm.LogWarnf</code> 常规日志，是因为 Istio 默认安装的情况下不输出 Info 级别的日志，这里为了调试方便，用了 warn 级别，生产环境中需要根据实际需要设置日志级别。</p>
<p>下载依赖，更新 go.sum</p>
<p><code>go mod tidy</code></p>
<h5 id="编译-1">编译</h5>
<p>编译出 wasm 文件</p>
<p><code>tinygo build -o test.wasm -target=wasi .</code></p>
<p>文件大小大约 250KB。</p>
<h4 id="模块配置">模块配置</h4>
<p>目前 Enovy 支持在启动 wasm 模块时注入用户自定义的配置，之后在 wasm 模块中使用。</p>
<p>比如我们实现一个设置真实 IP 的需求，需要将 <code>X-Forwarded-For</code> 中可信代理的 IP 网段过滤掉。这个可信代理的 IP 网段就可以通过模块配置传入，且可以在后续被修改，也不需要重新加载模块。</p>
<p>示例代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000080">// Override types.DefaultPluginContext.
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (ctx <span style="color:#39c">*</span>pluginContext) OnPluginStart(pluginConfigurationSize <span style="color:#00cd00">int</span>) types.OnPluginStartStatus {
</span></span><span style="display:flex;"><span>    data, err <span style="color:#39c">:=</span> proxywasm.GetPluginConfiguration()
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
</span></span><span style="display:flex;"><span>        proxywasm.LogCriticalf(<span style="color:#cd0000">&#34;error reading plugin configuration: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>        <span style="color:#cdcd00">return</span> types.OnPluginStartStatusFailed
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">if</span> <span style="color:#cd00cd">len</span>(data) <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#cdcd00">return</span> types.OnPluginStartStatusOK
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    proxywasm.LogWarnf(<span style="color:#cd0000">&#34;plugin config: %s&#34;</span>, <span style="color:#cd00cd">string</span>(data))
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">return</span> types.OnPluginStartStatusOK
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以在 <code>OnPluginStart</code> 函数中通过 <code>proxywasm.GetPluginConfiguration</code> 获取到用户的自定义配置并存储在 pluginContext 中，在后续创建 HTTPContext 时注入进去。再然后就可以在 <code>OnHttpRequestHeaders</code> 这样的函数中使用了。</p>
<h4 id="proxy-wasm-架构模型">Proxy-Wasm 架构模型</h4>
<p>上述代码中出现了 VMContext，PluginContext，HTTPContext 这样的类型，如果不清楚具体的架构，层级的话，很容易误用。</p>
<p><img src="https://image.fatedier.com/pic/2021/2021-09-17-extend-istio-and-envoy-by-wasm-proxy-wasm.jpg" alt="proxy-wasm"></p>
<p>VMContext 对应一个 wasm vm 实例，在 envoy 中通过 <code>vm_config</code> 配置。</p>
<p>通过 VMContext 可以创建 PluginContext，一对多的关系。通常一个 PluginContext 对应于 enovy 中的一个 Filter，也就是说，不同的 Filter 可以复用一个 VM 实例，然后使用不同的 PluginConfiguration。</p>
<p>通过 PluginContext 会为每一个 HTTP 和 TCP 流创建 HTTPContext 或 TCPContext 用于处理实际的请求。</p>
<h3 id="istio-中通过-enovyfilter-部署-wasm-扩展">Istio 中通过 EnovyFilter 部署 wasm 扩展</h3>
<p>当我们编译出了 wasm 文件后，需要能够部署到 sidecar 中让 enovy 使用。</p>
<p>这里可能会关注的一些问题:</p>
<ol>
<li>哪些服务的 sidecar 需要注入这些 wasm 模块。</li>
<li>哪一个 wasm 文件需要被使用。</li>
<li>wasm 扩展需要被注入到 Filter Chain 中的什么位置。</li>
<li>插件依赖的初始化配置文件在 Istio 中如何配置。</li>
<li>如何动态更新 wasm 文件。</li>
<li>如何动态更新配置文件。</li>
</ol>
<h4 id="envoyfilter-的配置">EnvoyFilter 的配置</h4>
<p>在 Istio 中，我们目前需要使用 EnovyFilter 来动态修改注入到 Istio 下发到 sidecar 中的 Enovy 配置来使用 wasm 扩展。（以后应该会有抽象的独立的 CRD 来实现）</p>
<p>Enovy 中 wasm 插件相关的官方文档: <a href="https://www.envoyproxy.io/docs/envoy/v1.18.4/configuration/http/http_filters/wasm_filter.html">https://www.envoyproxy.io/docs/envoy/v1.18.4/configuration/http/http_filters/wasm_filter.html</a></p>
<p>从本地磁盘中加载 wasm 文件的完整配置:</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>apiVersion: networking.istio.io/v1alpha3
</span></span><span style="display:flex;"><span>kind: EnvoyFilter
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: ingressgateway-real-ip
</span></span><span style="display:flex;"><span>  namespace: istio-system
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  workloadSelector:
</span></span><span style="display:flex;"><span>    labels:
</span></span><span style="display:flex;"><span>      app: istio-ingressgateway
</span></span><span style="display:flex;"><span>  configPatches:
</span></span><span style="display:flex;"><span>    - applyTo: EXTENSION_CONFIG
</span></span><span style="display:flex;"><span>      match:
</span></span><span style="display:flex;"><span>        context: GATEWAY
</span></span><span style="display:flex;"><span>      patch:
</span></span><span style="display:flex;"><span>        operation: ADD
</span></span><span style="display:flex;"><span>        value:
</span></span><span style="display:flex;"><span>          name: realip
</span></span><span style="display:flex;"><span>          typed_config:
</span></span><span style="display:flex;"><span>            &#39;@type&#39;: type.googleapis.com/udpa.type.v1.TypedStruct
</span></span><span style="display:flex;"><span>            type_url: type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
</span></span><span style="display:flex;"><span>            value:
</span></span><span style="display:flex;"><span>              config:
</span></span><span style="display:flex;"><span>                configuration:
</span></span><span style="display:flex;"><span>                  &#39;@type&#39;: type.googleapis.com/google.protobuf.StringValue
</span></span><span style="display:flex;"><span>                  value: |<span style="color:#cd0000">
</span></span></span><span style="display:flex;"><span><span style="color:#cd0000">                    </span>                    <span style="color:#cd00cd">10.0.0.0</span>/8,172.16.0.0/12,192.168.0.0/16
</span></span><span style="display:flex;"><span>                vm_config:
</span></span><span style="display:flex;"><span>                  vm_id: realip
</span></span><span style="display:flex;"><span>                  code:
</span></span><span style="display:flex;"><span>                    local:
</span></span><span style="display:flex;"><span>                      filename: /wasm/realip-go.wasm
</span></span><span style="display:flex;"><span>                  runtime: envoy.wasm.runtime.v8
</span></span><span style="display:flex;"><span>    - applyTo: HTTP_FILTER
</span></span><span style="display:flex;"><span>      match:
</span></span><span style="display:flex;"><span>        context: GATEWAY
</span></span><span style="display:flex;"><span>        listener:
</span></span><span style="display:flex;"><span>          filterChain:
</span></span><span style="display:flex;"><span>            filter:
</span></span><span style="display:flex;"><span>              name: envoy.http_connection_manager
</span></span><span style="display:flex;"><span>      patch:
</span></span><span style="display:flex;"><span>        operation: INSERT_BEFORE
</span></span><span style="display:flex;"><span>        value:
</span></span><span style="display:flex;"><span>          name: realip
</span></span><span style="display:flex;"><span>          config_discovery:
</span></span><span style="display:flex;"><span>            config_source:
</span></span><span style="display:flex;"><span>              ads: {}
</span></span><span style="display:flex;"><span>              initial_fetch_timeout: 0s
</span></span><span style="display:flex;"><span>            type_urls: [ <span style="color:#cd0000">&#34;type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm&#34;</span>]
</span></span></code></pre></div><p>workloadSelector 指定了该配置需要应用在哪些 pod 上，比如这里可以限定只在网关生效。</p>
<p>configuration 中我们可以配置任意的字符串，该部分配置信息会被传入 wasm 模块中使用。</p>
<p>上述 yaml 配置中包含了两个 Filter。</p>
<p>第二个 HTTP_FILTER 作用于 gateway 代理中，这里使用了 enovy 的 configDiscovery 的功能，可以从 ads 中获取配置信息，而不是直接定义，后面会说明为什么这么做。这里要获取的配置名称为 <code>realip</code>。需要注意的是 <code>initial_fetch_timeout</code> 被设置为 0s，这个是必须的，这样在初始化配置时，如果没有从 ads 中拉取到这个 Filter 的配置，则会一直等待，避免了由于拉取配置失败而启动后响应出错的问题。</p>
<p>第一个 EXTENSION_CONFIG Patch 中，则是实际的 realip 这个 filter 的定义。格式参考 enovy 的 API 即可。目前支持 local 和 remote 两种拉取 wasm 文件的方式，local 就是指定本地磁盘的路径(需要采用其他方式将 wasm 文件注入到 sidecar 容器的指定目录上)，remote 可以指定一个远端的 HTTP/HTTPS URL。</p>
<p>Remote 的配置如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>vm_config:
</span></span><span style="display:flex;"><span>  vm_id: realip
</span></span><span style="display:flex;"><span>  code:
</span></span><span style="display:flex;"><span>    remote:
</span></span><span style="display:flex;"><span>      http_uri:
</span></span><span style="display:flex;"><span>        uri: http://storage.example.com/realip.wasm
</span></span><span style="display:flex;"><span>        timeout: 10s
</span></span><span style="display:flex;"><span>        sha256: &lt;WASM-MODULE-SHA&gt;
</span></span><span style="display:flex;"><span>  runtime: envoy.wasm.runtime.v8
</span></span></code></pre></div><p>采用 remote 的方式，可以直接拉取远端的 wasm 文件到容器中。sha256 值非必须，但是建议配置，不仅是校验的作用，还对于文件缓存有帮助，这样当配置有变更时，如果 wasm 文件没有变化，istio-agent 就不需要重新去拉取文件。</p>
<p>在 Istio 1.9 版本之前，没有采用 configDiscovery 的方式配置，会有潜在的拉取 wasm 文件失败从而导致影响到入口请求的问题。Istio 1.9 版本中对这一部分做了优化，关于如何拉取 wasm 文件这部分的优化，可以在 <a href="https://istio.io/latest/blog/2021/wasm-progress/">https://istio.io/latest/blog/2021/wasm-progress/</a> 这篇文章中找到更详细的说明。</p>
<p>设计文档: <a href="https://docs.google.com/document/d/1-IFziAJYaxQdcbXGyenF6gvVFB-20aPTm5XkwlmcNac/edit#heading=h.xw1gqgyqs5b">https://docs.google.com/document/d/1-IFziAJYaxQdcbXGyenF6gvVFB-20aPTm5XkwlmcNac/edit#heading=h.xw1gqgyqs5b</a></p>
<p><img src="https://image.fatedier.com/pic/2021/2021-09-17-extend-istio-and-envoy-by-wasm-module-fetch.jpg" alt="module-fetch"></p>
<ol>
<li>Istiod 获取到 EnvoyFilter 中关于 wasm 的配置。</li>
<li>通过 ECDS config 指定 wasm 模块配置，下发给 sidecar 中的 istio-agent。</li>
<li>istio-agent 会检查 cache 中是否已经存在该 wasm 文件。</li>
<li>istio-agent 检查如果 cache 中没有，则从远端下载，并存入 cache。</li>
<li>确保 wasm 文件下载完成后再将配置更新到 envoy。enovy 如果在启动过程中，没有获取到 wasm 配置前不会接收请求。</li>
</ol>
<h4 id="模块与配置更新">模块与配置更新</h4>
<p>EnovyFilter 中的 wasm 文件路径以及 configuration 都可以被动态修改。</p>
<p>配置的更新不需要重新启动 wasm 的 vm，相对来说比较轻量。wasm 文件的更新需要启动新的 vm。如果模块拉取失败，则仍然会使用旧的 vm，后续的请求不会失败。</p>
<h3 id="istio-中如何分发-wasm-文件">Istio 中如何分发 WASM 文件</h3>
<p>在 Istio 中，需要有一套稳定可靠的机制，将指定版本的 wasm 文件推送给 sidecar，供 enovy 使用。</p>
<h4 id="init-container">Init Container</h4>
<p>将 wasm 文件打包为镜像，可以使用体积很小的基础镜像。</p>
<p>在需要注入此插件的服务的 Deployment 中增加 init container，将 wasm 文件拷贝到一处共享目录。Enovy sidecar 也 mount 这个共享目录。</p>
<p>在 EnovyFilter 中指定 wasm 文件路径为这个共享目录。</p>
<p>优点: 简单，安全可靠，利用镜像来存储和分发 wasm 文件，不需要额外的开发和管理成本。
缺点: wasm 文件后续无法动态更新，更新版本需要更新服务的 Deployment。并且增加 init container 增加了少量的容器启动时间。</p>
<h4 id="daemonset-and-local-filesystem">Daemonset and Local FileSystem</h4>
<p>目前 Istio 社区和阿里云的 ASM 提供的方案，社区的版本还不是很成熟。</p>
<p>在集群中创建一个 DaemonSet，每一个节点有一个 Pod 负责根据 CRD 拉取对应的 wasm 文件(目前主流的方案是以 OCI Image Spec 的格式存储)，以及反馈拉取信息，文件存放到宿主机的指定目录中。</p>
<p>EnovySidecar 固定挂载宿主机的指定目录到容器中。</p>
<p>EnovyFilter 中指定 wasm 文件路径为挂载到容器中的路径。</p>
<p>另外定义一个新的 CRD，指定 EnovyFilter 配置和 wasm 镜像。由一个独立的控制器，根据 wasm 文件拉取信息进行管理，只有当所有需要的节点都拉取完成后，才会去创建 EnovyFilter。</p>
<p>优点: 支持动态更新，节点级别的 cache，减少重复的拉取和存储。
缺点: 需要额外的开发和维护成本。</p>
<h4 id="remote-http-url">Remote HTTP URL</h4>
<p>在集群内部部署一个 wasm 文件的存储服务，对外提供 HTTP 接口。</p>
<p>EnvoyFilter 中配置 remote 地址为这个内部服务的 service 地址。</p>
<p>Istio sidecar 中的 istio-agent 会做拉取和缓存的工作。并且确保在拉取成功后才将 wasm 扩展的配置推送给 enovy。</p>
<p>优点: 使用简单，支持动态更新扩展版本。
缺点: 可靠性还是稍差，主要体现在容器启动过程中。如果 wasm 扩展存储服务出现问题，会导致所有包含 istio sidecar 的 pod 都无法正常工作。</p>
<h3 id="性能测试">性能测试</h3>
<p>这里通过 golang 实现了一个类似 nginx 中获取真实 IP 的扩展，可以通过配置指定可信代理的 IP 段，大概 50 个左右。之后从 X-Forwarded-For 的 IP 列表中，从后往前，过滤掉在可信 IP 段的 IP，之后将最右边保留下的 IP 作为真实 IP 重新写会 X-Forwarded-For header 中传递给后续的服务。</p>
<p>我们测试单线程发送 20000 个请求，响应 body 体为 10KB，同时记录总耗时和一些资源消耗，调整网关副本数为 1，便于观测 CPU 和内存消耗。</p>
<p>无 wasm 扩展注入: 0.24C 28.7s 平均 1.435ms</p>
<p>注入 wasm 扩展后: 0.25C 29.6s 平均 1.48ms</p>
<p>可以看出，引入 wasm 扩展后，CPU 消耗增加了约 5% ，延迟增加了 0.045ms。由于计算真实 IP 的功能本身也需要一定的计算量，会引入一些延迟，所以同样的功能，使用原生代码扩展和使用 wasm 的扩展之间的差距应该更小。目前在一些基础功能的实现上，性能是完全可以接受的。</p>
<h3 id="istio-关于-wasm-未来的计划">Istio 关于 wasm 未来的计划</h3>
<ul>
<li>目前是通过 EnvoyFilter 来配置，之后计划会提供独立的 CRD/API 来方便使用。</li>
<li>标准化 wasm 模块的定义，分发。目前有一套 OCI Image Spec，定义好后，可以标准化模块的编译，上传，下载和执行，有利于统一这一部分的基础设施的实现。</li>
<li>通过 CSI Ephemeral Inline Volumes 实现 wasm 模块的分发，类似于上面提到的通过 Daemonset 统一下载然后挂载到 sidecar 容器的方式。</li>
</ul>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">fatedier</a>
                    <br />本文出处：<a target="_blank" href="https://blog.fatedier.com/2021/09/17/extend-istio-and-envoy-by-wasm/">https://blog.fatedier.com/2021/09/17/extend-istio-and-envoy-by-wasm/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/istio/">
                            <i class="fa fa-tags"></i>
                            istio
                        </a>
                    </li>
                    
                    <li>
                        <a href="/tags/service-mesh/">
                            <i class="fa fa-tags"></i>
                            service mesh
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/2022/10/11/istio-grpc-gateway-disable-http1/">Istio GRPC Gateway 禁用 HTTP1.1 请求</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年10月11日)</span></li><li id="li-rels"><a href="/2022/10/09/istio-inbound-http-request-idletimeout/">Istio Inbound HTTP 请求的 IdleTimeout 问题</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年10月09日)</span></li><li id="li-rels"><a href="/2022/08/15/istio-pods-crash-cause-full-push/">Istio 中服务实例频繁 crash 导致一直触发 Full Push 的问题</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年08月15日)</span></li><li id="li-rels"><a href="/2022/07/13/headless-service-cause-istiod-overloading/">Headless Service 导致 Istio 控制面负载过高</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年07月13日)</span></li><li id="li-rels"><a href="/2022/07/07/istio-duplicated-transfer-encoding-causes-request-502/">应用侧返回 Duplicated Transfer-Encoding 导致接入 Istio 后请求 502</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年07月07日)</span></li><li id="li-rels"><a href="/2022/06/01/istio-control-plane-config-push-optimization/">Istio 控制面配置推送分析与优化</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年06月01日)</span></li><li id="li-rels"><a href="/2022/05/22/istio-dns-proxying/">Istio DNS Proxying</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年05月22日)</span></li><li id="li-rels"><a href="/2022/04/18/istio-tcp-idle-connection-disconnect-after-one-hour/">Istio sidecar TCP 空闲连接 1 小时自动断开</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年04月18日)</span></li><li id="li-rels"><a href="/2022/01/11/istio-service-send-request-failed-even-dns-switched/">Istio 服务请求外部域名持续出错，切换 DNS 后也无法恢复</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2022年01月11日)</span></li><li id="li-rels"><a href="/2021/12/24/reduce-istio-control-panel-push-config/">减少 Istio 控制面下发的配置</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2021年12月24日)</span></li></ul>
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="/2021/11/17/macos-iptables-block-address/"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/2021/09/07/istio-gateway-support-gzip/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
  <ul>
    <li><a href="#背景">背景</a>
      <ul>
        <li><a href="#wasmwasi">WASM/WASI</a></li>
        <li><a href="#proxy-wasm">proxy-wasm</a></li>
      </ul>
    </li>
    <li><a href="#编写-proxy-wasm-扩展">编写 proxy-wasm 扩展</a>
      <ul>
        <li><a href="#rust">Rust</a>
          <ul>
            <li><a href="#环境">环境</a></li>
            <li><a href="#创建项目">创建项目</a></li>
            <li><a href="#编译">编译</a></li>
          </ul>
        </li>
        <li><a href="#go">Go</a>
          <ul>
            <li><a href="#环境-1">环境</a></li>
            <li><a href="#创建项目-1">创建项目</a></li>
            <li><a href="#编译-1">编译</a></li>
          </ul>
        </li>
        <li><a href="#模块配置">模块配置</a></li>
        <li><a href="#proxy-wasm-架构模型">Proxy-Wasm 架构模型</a></li>
      </ul>
    </li>
    <li><a href="#istio-中通过-enovyfilter-部署-wasm-扩展">Istio 中通过 EnovyFilter 部署 wasm 扩展</a>
      <ul>
        <li><a href="#envoyfilter-的配置">EnvoyFilter 的配置</a></li>
        <li><a href="#模块与配置更新">模块与配置更新</a></li>
      </ul>
    </li>
    <li><a href="#istio-中如何分发-wasm-文件">Istio 中如何分发 WASM 文件</a>
      <ul>
        <li><a href="#init-container">Init Container</a></li>
        <li><a href="#daemonset-and-local-filesystem">Daemonset and Local FileSystem</a></li>
        <li><a href="#remote-http-url">Remote HTTP URL</a></li>
      </ul>
    </li>
    <li><a href="#性能测试">性能测试</a></li>
    <li><a href="#istio-关于-wasm-未来的计划">Istio 关于 wasm 未来的计划</a></li>
  </ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2022  fatedier blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

