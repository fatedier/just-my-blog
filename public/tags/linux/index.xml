<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fatedier blog </title>
    <link>http://blog.fatedier.com/tags/linux/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2016</rights>
    <updated>2016-07-18 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>linux下查看指定进程的所有连接信息</title>
          <link>http://blog.fatedier.com/2016/07/18/stat-all-connection-info-of-special-process-in-linux</link>
          <pubDate>Mon, 18 Jul 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/07/18/stat-all-connection-info-of-special-process-in-linux</guid>
          <description>&lt;p&gt;定位某个进程的网络故障时经常需要用到的一个功能就是查找所有连接的信息。通常查找某个端口的连接信息使用 ss 或者 netstat 可以轻松拿到，如果是主动与别的机器建立的连接信息则可以通过 lsof 命令来获得。&lt;/p&gt;

&lt;p&gt;例如我想要查看进程 &lt;code&gt;frps&lt;/code&gt; 当前的所有连接信息，先获得进程的 pid：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps -ef|grep frps&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wcl       4721     1  0 10:27 ?        00:00:01 ./frps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到进程 pid 为 &lt;strong&gt;4721&lt;/strong&gt;，之后通过 lsof 命令查看所有 TCP 连接信息：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lsof -p 4721 -nP | grep TCP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;frps    4721  wcl    4u     IPv6 117051764      0t0     TCP *:7000 (LISTEN)
frps    4721  wcl    6u     IPv6 117051765      0t0     TCP *:7003 (LISTEN)
frps    4721  wcl    7u     IPv6 117092563      0t0     TCP 139.129.11.120:7000-&amp;gt;116.231.70.223:61545 (ESTABLISHED)
frps    4721  wcl    8u     IPv6 117092565      0t0     TCP *:6000 (LISTEN)
frps    4721  wcl    9u     IPv6 117334426      0t0     TCP 139.129.11.120:7000-&amp;gt;116.237.93.230:64898 (ESTABLISHED)
frps    4721  wcl   10u     IPv6 117053538      0t0     TCP 139.129.11.120:7000-&amp;gt;115.231.20.123:41297 (ESTABLISHED)
frps    4721  wcl   11u     IPv6 117053540      0t0     TCP *:6005 (LISTEN)
frps    4721  wcl   12u     IPv6 117334428      0t0     TCP *:6004 (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 &lt;strong&gt;lsof&lt;/strong&gt; 的输出结果中可以清楚的看到 &lt;strong&gt;frps&lt;/strong&gt; 进程监听了 5 个端口，并且在 7000 端口上建立了 3 个连接，连接两端的 ip 信息也都可以查到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;lsof&lt;/strong&gt; 的 &lt;strong&gt;-nP&lt;/strong&gt; 参数用于将 ip 地址和端口号显示为正常的数值类型，否则可能会用别名表示。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>简记用sed对文件执行批量替换字符串的方法</title>
          <link>http://blog.fatedier.com/2016/03/25/using-sed-to-batch-replace-strings-in-files</link>
          <pubDate>Fri, 25 Mar 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/03/25/using-sed-to-batch-replace-strings-in-files</guid>
          <description>

&lt;p&gt;每次要进行一些批量的文本处理，例如 sed, awk 处理数据或者涉及到正则表达式的时候，都需要临时去再查一遍资料，看一下怎么用。这里简要记录一下对大量文件进行正则匹配后批量替换文本的方法，方便以后要用的时候回顾一下。&lt;/p&gt;

&lt;p&gt;因为 blog 的图片迁到了七牛云上（提供CDN加速服务），原来的图片链接必然要替换成七牛云提供的二级域名，在 markdown 文件中有很多图片的标签，也不可能一个一个手动改，最好是能一个命令下去直接全部修改完毕并且以后也可以很轻松地改成其他域名。&lt;/p&gt;

&lt;p&gt;执行的命令如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sed -i &amp;quot;s?](.*|pic|?](http://xxx.clouddn.com|pic|?g&amp;quot; `grep &amp;quot;|pic|&amp;quot; -rl ./`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：本文中所有的 &lt;code&gt;|pic|&lt;/code&gt; 其实是 &lt;code&gt;/pic/&lt;/code&gt;，这样是为了避免被误替换。也可以通过 &lt;code&gt;grep -v&lt;/code&gt; 来手动指定不替换的文件。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;markdown 中的图片标签一般的格式是 &lt;code&gt;![label](http://www.xxx.com/a.jpg)&lt;/code&gt;，我的图片链接则是都会有一个 &lt;code&gt;pic&lt;/code&gt; 的目录前缀。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;grep&#34;&gt;grep&lt;/h4&gt;

&lt;p&gt;先看后面，&lt;code&gt;grep &amp;quot;|pic|&amp;quot; -rl ./&lt;/code&gt; 用于递归查找所有含有 &lt;code&gt;|pic|&lt;/code&gt; 这个字符串的文件所在路径的路径名，按行显示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 参数表示会对目录进行递归查找。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; 参数会输出匹配的文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;sed&#34;&gt;sed&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;sed&lt;/strong&gt; 和 &lt;strong&gt;awk&lt;/strong&gt; 都是文本处理的利器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sed&lt;/code&gt; 进行文本替换的常用的格式是 &lt;code&gt;sed &amp;quot;s/aa/bb/g&amp;quot; ./testfile&lt;/code&gt;，表示将文件中所有的 &lt;strong&gt;aa&lt;/strong&gt; 替换成 &lt;strong&gt;bb&lt;/strong&gt;， 最后的 &lt;code&gt;g&lt;/code&gt; 表示作用域是全局。&lt;/p&gt;

&lt;p&gt;这里分隔符用的 &lt;code&gt;/&lt;/code&gt;，也可以换成其他符号，比如上面我用的是 &lt;code&gt;?&lt;/code&gt;，只要保证这三个地方的符号一致并且没有歧义即可。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;](.*|pic|&lt;/code&gt; 是一个正则匹配， &lt;code&gt;.&lt;/code&gt; 表示匹配任意一个字符，&lt;code&gt;*&lt;/code&gt; 表示匹配0个或多个前面的字符，这里两个合起来就是匹配任意字符串。完整的意思就是匹配以 &lt;code&gt;](&lt;/code&gt; 开头，以 &lt;code&gt;|pic|&lt;/code&gt; 结尾的任意字符串。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;](http://xxx.clouddn.com|pic|&lt;/code&gt; 是替换后的字符串。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-i&lt;/code&gt; 表示将替换后的结果写入文件中，而不是直接输出。&lt;/p&gt;

&lt;h4 id=&#34;查看修改结果&#34;&gt;查看修改结果&lt;/h4&gt;

&lt;p&gt;一开始不确定修改是否正确最好不要给予使用 &lt;code&gt;-i&lt;/code&gt; 参数将修改后的结果写入文件，可以将上面的命令换成如下的内容来检查是否替换正确：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sed -n &amp;quot;s?](.*|pic|?](http://xxx.clouddn.com|pic|?gp&amp;quot; `grep &amp;quot;|pic|&amp;quot; -rl ./`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 表示静默模式，如果有输出内容的话，不会输出整个文件的内容，而仅仅是匹配的内容。&lt;/p&gt;

&lt;p&gt;后面的 &lt;code&gt;gp&lt;/code&gt;，&lt;code&gt;g&lt;/code&gt; 前面说过是表示作用域是全局，&lt;code&gt;p&lt;/code&gt; 表示会输出匹配的内容。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>终端利器 Tmux</title>
          <link>http://blog.fatedier.com/2015/12/18/terminal-multiplexer-tmux</link>
          <pubDate>Fri, 18 Dec 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2015/12/18/terminal-multiplexer-tmux</guid>
          <description>

&lt;p&gt;开发过程中通过ssh到服务器是很常见的，工作中基本上90%的时间在和终端打交道，如果没有一个称手的工具，将会在不停打开新的 tab 页，窗口切换中耗费大量的时间。Tmux 是终端复用器的意思，和 screen 类似，但是高度可定制，通过 tmux 可以方便地管理大量的 ssh 连接，并且灵活地在不同窗口，不同面板之间切换。&lt;/p&gt;

&lt;h3 id=&#34;界面&#34;&gt;界面&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2015/2015-12-18-terminal-multiplexer-tmux-tmux-overview.png&#34; alt=&#34;tmux&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我用了自己的配置文件，对界面做过一些优化，左下角是 &lt;strong&gt;session&lt;/strong&gt; 名称，中间是各个 &lt;strong&gt;window&lt;/strong&gt; 的名称，可以理解为一般 IDE 中的 Tab 页，右下角显示时间，这个窗口中打开了3个 &lt;strong&gt;pane&lt;/strong&gt;，通过快捷键，我就可以在不同的 &lt;strong&gt;session&lt;/strong&gt;, &lt;strong&gt;window&lt;/strong&gt;, &lt;strong&gt;pane&lt;/strong&gt; 之间来回切换，基本上脱离了鼠标的使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;session： 可以用于区分不同的项目，为每个项目建立一个 session。&lt;/li&gt;
&lt;li&gt;window： 对应于其他 IDE 的 Tab 标签页，一个 window 占据一个显示屏幕，一个 session 可以有多个 window。&lt;/li&gt;
&lt;li&gt;pane： 在一个 window 中可以有多个 pane，便于大屏幕显示屏将屏幕切分成多块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Centos下直接通过 &lt;code&gt;yum install -y tmux&lt;/code&gt; 来安装，其他系统也一样可以使用相应的包管理工具安装。&lt;/p&gt;

&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;

&lt;h4 id=&#34;快捷键前缀&#34;&gt;快捷键前缀&lt;/h4&gt;

&lt;p&gt;为了避免按键冲突，使用 tmux 的快捷键都需要加上一个&lt;strong&gt;前缀按键&lt;/strong&gt;，默认是 &lt;strong&gt;Ctrl-b&lt;/strong&gt; 的组合，可以通过配置修改为自定义的按键。&lt;/p&gt;

&lt;p&gt;例如要退出 tmux 的快捷键是前缀键 + d，那么就需要按 Ctrl-b + d：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按下组合键 Ctrl-b&lt;/li&gt;
&lt;li&gt;放开组合键 Ctrl-b&lt;/li&gt;
&lt;li&gt;按下 s 键&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我自己将 Ctrl-b 改成了 Ctrl-x ，感觉这样操作顺手一些。&lt;/p&gt;

&lt;h4 id=&#34;基本操作&#34;&gt;基本操作&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;创建一个叫做 &amp;ldquo;test&amp;rdquo; 的 session，并且进入 tmux 界面&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tmux new -s test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看开启了哪些 session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tmux ls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进入 session &amp;ldquo;test&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tmux attach -t test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;退出 tmux 环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + d  // 退出后 session 并不会被关闭，之后通过 attach 进入仍然会看到原来的界面&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切换 session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + s，之后按序号切换，或者通过方向键选择后按 Enter 键切换&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切换 window&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ctrl-b + &amp;lt;窗口号&amp;gt;
Ctrl-b + n  // 切换到下一个窗口
Ctrl-b + p  // 切换到上一个窗口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;切换 pane&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个我在配置文件中修改过，修改成了 vim 的使用习惯，具体配置见下节
Ctrl-b + h  // 左
Ctrl-b + j  // 下
Ctrl-b + k  // 上
Ctrl-b + l  // 右
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;关闭 pane&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + x  // 焦点在要关闭的 pane 内&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关闭 window&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ctrl-b + &amp;amp; // 焦点在要关闭的 window 内&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分割 window 成多个 pane&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个为了记忆方便也修改了原有的配置
Ctrl-b + _  // 竖直分割
Ctrl-b + |  // 水平分割
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重新加载配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个被我映射到了 r 键，修改完配置文件后不用关闭所有 session 重新打开，直接重新加载即可
Ctrl-b + r
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;小技巧&#34;&gt;小技巧&lt;/h3&gt;

&lt;h4 id=&#34;复制模式&#34;&gt;复制模式&lt;/h4&gt;

&lt;p&gt;如果要在不同 &lt;strong&gt;window&lt;/strong&gt; 或者 &lt;strong&gt;pane&lt;/strong&gt; 之间复制内容，又想实现全键盘的操作，就需要借助于 tmux 的复制功能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-b + [&lt;/strong&gt; 进入复制模式&lt;/li&gt;
&lt;li&gt;移动光标到要复制的地方，这里我配置成了 vim 的操作方式&lt;/li&gt;
&lt;li&gt;按下&lt;strong&gt;空格&lt;/strong&gt;开始复制&lt;/li&gt;
&lt;li&gt;再移动到结束的地方，按下 &lt;strong&gt;Enter&lt;/strong&gt; 键退出&lt;/li&gt;
&lt;li&gt;在需要粘贴的地方按下 &lt;strong&gt;Ctrl-b + ]&lt;/strong&gt; 粘贴&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;多-pane-批量操作&#34;&gt;多 pane 批量操作&lt;/h4&gt;

&lt;p&gt;有时候同时登录了多台机器，需要执行一样的命令来进行批量操作，借助于 tmux 同样可以实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:setw synchronize-panes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个是设置批量操作的开关，如果原来功能是关闭的，则打开，反之亦然，可以将其映射到一个快捷键方便操作。开启这个功能后，在当前 window 任意一个 pane 输入的命令，都会同时作用于该 window 中的其他 pane。&lt;/p&gt;

&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;配置文件需要自己在 $HOME 目录下创建，命名为 .tmux.conf，具体内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Use something easier to type as the prefix.
set -g prefix C-x
unbind C-b
bind C-x send-prefix

# 窗口计数从1开始，方便切换
set -g base-index 1
setw -g pane-base-index 1

# 启用和关闭status bar
bind S set status on
bind D set status off 

# 消息背景色
set -g message-bg white

set -g mode-keys vi

# 关闭自动重命名窗口
setw -g allow-rename off 
setw -g automatic-rename off 

# bind a reload key
bind r source-file ~/.tmux.conf \; display-message &amp;quot;Config reloaded...&amp;quot;

# I personally rebind the keys so &amp;quot;|&amp;quot; splits the current window vertically, and &amp;quot;-&amp;quot; splits it horizontally. Not the easiest things to type, though easy to remember.
bind | split-window -h
bind _ split-window -v

# fixes the delay problem
set -sg escape-time 0

# 面板切换
bind-key k select-pane -U
bind-key j select-pane -D
bind-key h select-pane -L
bind-key l select-pane -R

# 面板大小调整
bind -r ^k resizep -U 10  
bind -r ^j resizep -D 10
bind -r ^h resizep -L 10
bind -r ^l resizep -R 10

# 状态栏
# 颜色
set -g status-bg black
set -g status-fg white

# 对齐方式
set-option -g status-justify centre

# 左下角
set-option -g status-left &#39;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&#39;
set-option -g status-left-length 20

# 窗口列表
set-window-option -g window-status-format &#39;#[dim]#I:#[default]#W#[fg=grey,dim]&#39;
set-window-option -g window-status-current-format &#39;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&#39;

# 右下角
set -g status-right &#39;#[fg=green][#[fg=cyan]%H:%M#[fg=green]]&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配套工具&#34;&gt;配套工具&lt;/h3&gt;

&lt;h4 id=&#34;tmuxinator&#34;&gt;tmuxinator&lt;/h4&gt;

&lt;p&gt;使用 tmux 可以让我们不管在什么时候，什么地点登录服务器都能得到同样的工作界面，不用因为担心网络暂时中断而需要重新打开一大堆的 tab 页。&lt;/p&gt;

&lt;p&gt;但是如果有的时候服务器重启了，那么所有的 session 就都没了，必须重新打开，可以想象一下我开发时有4-5个 session，每个 session 中有多个 window，然后每个 winodw 中通常又有2-3个 pane，要重新一个个建立开发环境是一件多么痛苦的事。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tmuxinator/tmuxinator&#34;&gt;tmuxinator&lt;/a&gt; 可以稍微缓解一下这个问题，但是不彻底。tmuxinator 可以用于管理 tmux 的 session 和 window 布局等，便于在机器重启后能够快速恢复自己的工作环境。&lt;/p&gt;

&lt;h5 id=&#34;安装-1&#34;&gt;安装&lt;/h5&gt;

&lt;p&gt;先安装 gem， &lt;code&gt;yum install -y rubygems&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于天朝特殊的网络环境，gem的第三方包可能安装不了，可以替换成阿里提供的镜像源。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem sources --add [https://ruby.taobao.org/](https://ruby.taobao.org/) --remove [https://rubygems.org/](https://rubygems.org/)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;使用&#34;&gt;使用&lt;/h5&gt;

&lt;p&gt;创建一个 tmuxinator 的 project： &lt;code&gt;tmuxinator new [project]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;之后编写项目的配置文件，以后重新打开这个项目所显示的界面就是根据这个配置文件来生成。具体用法可以参考项目文档： &lt;a href=&#34;https://github.com/tmuxinator/tmuxinator。&#34;&gt;https://github.com/tmuxinator/tmuxinator。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当服务器重启了以后，执行 &lt;code&gt;tmuxinator start [project]&lt;/code&gt;，tmuxinator 就会自动根据配置文件创建一个指定布局的 tmux session。&lt;/p&gt;

&lt;h5 id=&#34;缺点&#34;&gt;缺点&lt;/h5&gt;

&lt;p&gt;布局是预先在配置文件中指定好的，你在使用 tmux 过程中修改了的布局是不会记录下来的。&lt;/p&gt;

&lt;h4 id=&#34;tmux-resurrect&#34;&gt;Tmux Resurrect&lt;/h4&gt;

&lt;p&gt;Tmux Resurrect 用于保存当前的session环境到磁盘上，用于以后恢复。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于这个插件需要 tmux 1.9 及以上的版本，而 centos7 的 yum 源里现在是1.8的版本，我的开发环境全是自动构建，不方便升级，所以暂时还没有尝试。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于 Tmux Resurrect 使用的相关文档： &lt;a href=&#34;http://www.linuxidc.com/Linux/2015-07/120304.htm&#34;&gt;http://www.linuxidc.com/Linux/2015-07/120304.htm&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>epoll使用说明</title>
          <link>http://blog.fatedier.com/2015/01/25/introduction-of-using-epoll</link>
          <pubDate>Sun, 25 Jan 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2015/01/25/introduction-of-using-epoll</guid>
          <description>

&lt;p&gt;在《UNIX网络编程》一书中介绍了如何使用select/poll来实现I/O多路复用，简而言之就是通过内核的一种机制，监视多个文件描述符，一旦某个文件描述符处于就绪状态，就通知用户程序进行相应的读写操作，这样用户程序就不用阻塞在每一个文件描述符上。&lt;/p&gt;

&lt;p&gt;epoll相对于select/poll来说有很大优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不再需要每次把fd集合从用户态拷贝到内核态。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;不再需要在每次就绪时遍历fd集合中的所有fd来检查哪些fd处于就绪状态，epoll只返回就绪的fd集合。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;select一般只支持1024个文件描述符，而epoll没有类似的限制。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;epoll相关函数&#34;&gt;epoll相关函数&lt;/h3&gt;

&lt;p&gt;使用epoll只需要记住3个系统调用函数。&lt;/p&gt;

&lt;h4 id=&#34;int-epoll-create-int-size&#34;&gt;int epoll_create(int size)&lt;/h4&gt;

&lt;p&gt;创建一个epoll实例，从2.68的Linux内核开始，size参数不再生效，内核会动态分配所需的数据结构。失败返回-1，成功则该函数会返回一个文件描述符，并占用一个fd值，所以在使用完之后要记得close该文件描述符。&lt;/p&gt;

&lt;h4 id=&#34;int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event&#34;&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)&lt;/h4&gt;

&lt;p&gt;用于对epoll实例执行不同的操作的函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;epfd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用epoll_create()返回的文件描述符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;op&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用三个宏表示不同的操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;EPOLL_CTL_ADD：注册新的fd到epfd中；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EPOLL_CTL_MOD：修改已经注册的fd的监听事件；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EPOLL_CTL_DEL：从epfd中删除指定fd；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;fd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要监听的文件描述符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;event&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;event 是与指定fd关联的epoll_event结构，包含了监听事件，附加数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;struct epoll_event&lt;/strong&gt; 的结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef union epoll_data {
    void        *ptr;
    int          fd;
    __uint32_t   u32;
    __uint64_t   u64;
}epoll_data_t;
 
struct epoll_event {
    __uint32_t  events;      /* Epoll events */
    epoll_data_t data;       /* User data variable */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这里需要特别注意的是epoll_data_t是一个union结构，fd和ptr指针只能使用一个，通常我们使用void *ptr存储需要附加的用户数据结构，然后在用户数据结构中存储int型的fd，这样在epoll_wait调用后就仍然能获得该注册事件对应的文件描述符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;events可以是如下值的集合&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
EPOLLOUT：表示对应的文件描述符可以写
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
EPOLLERR：表示对应的文件描述符发生错误
EPOLLHUP：表示对应的文件描述符被挂断
EPOLLET： 将EPOLL设为边缘触发(EdgeTriggered)模式，这是相对于水平触发(Level Triggered)来说的
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout&#34;&gt;int epoll_wait(int epfd, struct epoll_event * events, int maxevents,int timeout)&lt;/h4&gt;

&lt;p&gt;该函数等待epoll实例中的fd集合有就绪事件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;epfd：使用epoll_create()返回的文件描述符
events：指向处于就绪状态的事件集合
maxevents：最多maxevents数量的事件集合会被返回
timeout：超时时间，单位为毫秒；指定为-1没有超时时间，指定为0则立即返回并返回0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果成功，返回已就绪的事件的个数；如果达到超时时间仍然没有就绪事件，返回0；如果出现错误，返回-1并置errno值&lt;/p&gt;

&lt;h3 id=&#34;lt和et两种工作方式&#34;&gt;LT和ET两种工作方式&lt;/h3&gt;

&lt;p&gt;epoll 默认使用LT的工作方式，当指定事件就绪时，内核通知用户进行操作，如果你只处理了部分数据，只要对应的套接字缓冲区中还有剩余数据，下一次内核仍然还会继续通知用户去进行处理，所以使用这种模式来写程序较为简单。&lt;/p&gt;

&lt;p&gt;ET工作方式是一种高速工作方式，只能使用非阻塞socket，它的效率要比LT方式高。当一个新事件就绪时，内核通知用户进行操作，如果这时用户没有处理完缓冲区的数据，缓冲区中剩余的数据就会丢失，用户无法从下一次epoll_wait调用中获取到这个事件。&lt;/p&gt;

&lt;p&gt;举个例子，可以指定事件为 EPOLLIN| EPOLLET 来使用ET工作方式获取指定文件描述符的可读事件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在该事件就绪后，需要不断调用read函数来获取缓冲区数据，直到产生一个EAGAIN错误或者read函数返回的读取到的数据长度小于请求的数据长度时才认为此事件处理完成。write也是一样的处理方式。&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>如何处理僵尸进程</title>
          <link>http://blog.fatedier.com/2014/12/16/how-to-deal-with-zombie-process</link>
          <pubDate>Tue, 16 Dec 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/12/16/how-to-deal-with-zombie-process</guid>
          <description>

&lt;p&gt;在使用c/c++开发过程中经常会用到多进程，需要fork一些子进程，但是如果不注意的话，就有可能导致子进程结束后变成了僵尸进程。从而逐渐耗尽系统资源。&lt;/p&gt;

&lt;h3 id=&#34;什么是僵尸进程&#34;&gt;什么是僵尸进程&lt;/h3&gt;

&lt;p&gt;如果父进程在子进程之前终止，则所有的子进程的父进程都会改变为init进程，我们称这些进程由init进程领养。这时使用ps命令查看后可以看到子进程的父进程ppid已经变为了1。&lt;/p&gt;

&lt;p&gt;而当子进程在父进程之前终止时，&lt;strong&gt;内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时&lt;/strong&gt;，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态、以及该进程使用的CPU时间总量。其他的进程所使用的存储区，打开的文件都会被内核释放。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程被称为僵尸进程。&lt;/strong&gt; ps命令将僵尸进程的状态打印为Z。&lt;/p&gt;

&lt;p&gt;可以设想一下，比如一个web服务器端，假如每次接收到一个连接都创建一个子进程去处理，处理完毕后结束子进程。假如在父进程中没有使用wait或waitpid函数进行善后，这些子进程将全部变为僵尸进程，Linux系统的进程数一般有一个固定限制值，僵尸进程将会逐渐耗尽系统资源。&lt;/p&gt;

&lt;h3 id=&#34;查看僵尸进程的例子&#34;&gt;查看僵尸进程的例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
 
int main(int argc, char **argv)
{
    pid_t pid;
    for (int i=0; i&amp;lt;5; i++) {
        if ((pid = fork()) &amp;lt; 0) {
            printf(&amp;quot;fork error,%s\n&amp;quot;, strerror(errno));
            return -1;
        }
        
        /* child */
        if (pid == 0) {
            sleep(1);
            exit(0);
        }
    }  
    /* parent */
    sleep(20);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译完成后，在执行程序的命令后加上 &amp;ldquo;&amp;amp;&amp;rdquo; 符号，表示让当前程序在后台运行。&lt;/p&gt;

&lt;p&gt;之后输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps –e –o pid,ppid,stat,command|grep [程序名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到如下的结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2915  1961 S    ./dd
2917  2915 Z    [dd] &amp;lt;defunct&amp;gt;
2918  2915 Z    [dd] &amp;lt;defunct&amp;gt;
2919  2915 Z    [dd] &amp;lt;defunct&amp;gt;
2920  2915 Z    [dd] &amp;lt;defunct&amp;gt;
2921  2915 Z    [dd] &amp;lt;defunct&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到5个子进程都已经是僵尸进程了。&lt;/p&gt;

&lt;h3 id=&#34;sigchld信号和处理僵尸进程&#34;&gt;SIGCHLD信号和处理僵尸进程&lt;/h3&gt;

&lt;p&gt;当子进程终止时，内核就会向它的父进程发送一个SIGCHLD信号，父进程可以选择忽略该信号，&lt;strong&gt;也可以提供一个接收到信号以后的处理函数&lt;/strong&gt;。对于这种信号的系统默认动作是忽略它。&lt;/p&gt;

&lt;p&gt;我们不希望有过多的僵尸进程产生，所以当父进程接收到SIGCHLD信号后就应该调用 wait 或 waitpid 函数对子进程进行善后处理，释放子进程占用的资源。&lt;/p&gt;

&lt;p&gt;下面是一个捕获SIGCHLD信号以后使用wait函数进行处理的简单例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
 
void deal_child(int sig_no)
{
    wait(NULL);
}
 
int main(int argc, char **argv)
{
    signal(SIGCHLD, deal_child);
 
    pid_t pid;
    for (int i=0; i&amp;lt;5; i++) {
        if ((pid = fork()) &amp;lt; 0) {
            printf(&amp;quot;fork error,%s\n&amp;quot;,strerror(errno));
            return -1;
        }  
 
        /* child */
        if (pid == 0) {
            sleep(1);
            exit(0);
        }  
    }  
    /* parent */
    for(int i=0; i&amp;lt;100000; i++) {
        for (int j=0; j&amp;lt;100000; j++) {
            int temp = 0;
        }  
    }  
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样在后台运行后使用ps命令查看进程状态，结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;6622  1961 R    ./dd
6627  6622 Z    [dd] &amp;lt;defunct&amp;gt;
6628  6622 Z    [dd] &amp;lt;defunct&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现创建的5个进程，有3个已经被彻底销毁，但是还有2个仍然处于僵尸进程的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这是因为当5个进程同时终止的时候，内核都会向父进程发送SIGCHLD信号，而父进程此时有可能仍然处于信号处理的deal_child函数中，那么在处理完之前，中间接收到的SIGCHLD信号就会丢失，内核并没有使用队列等方式来存储同一种信号。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;正确地处理僵尸进程的方法&#34;&gt;正确地处理僵尸进程的方法&lt;/h3&gt;

&lt;p&gt;为了解决上面出现的这种问题，我们需要使用waitpid函数。&lt;/p&gt;

&lt;p&gt;函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;pid_t waitpid(pid_t pid, int *statloc, int options);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若成功则返回进程ID，如果设置为非阻塞方式，返回0表示子进程状态未改变，出错时返回-1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;options参数可以设置为WNOHANG常量，表示waitpid不阻塞，如果由pid指定的子进程不是立即可用的，则立即返回0。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只需要修改一下SIGCHLD信号的处理函数即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void deal_child(int sig_no)
{
    for (;;) {
        if (waitpid(-1, NULL, WNOHANG) == 0)
            break;
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次执行程序后使用ps命令查看，发现已经不会产生僵尸进程了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>linux core文件调试</title>
          <link>http://blog.fatedier.com/2014/12/07/debug-with-linux-core-file</link>
          <pubDate>Sun, 07 Dec 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/12/07/debug-with-linux-core-file</guid>
          <description>

&lt;p&gt;在完成公司项目，测试进程的时候，经常会发现日志到了某一段特定的代码的时候就没了，进程直接退出，也没有捕获到任何的异常信息，如果日志打印的较多还可能比较容易发现问题
题，如果日志较少，就很难进行进一步的查错了。但是发现在该目录下生成了一个core文件，可以帮助我们查找程序崩溃的原因。&lt;/p&gt;

&lt;h3 id=&#34;什么是core文件&#34;&gt;什么是core文件&lt;/h3&gt;

&lt;p&gt;在linux系统下，如果进程不能正常运行，就可能会产生core文件。core文件就是当前内存状态的一个映像，同时加上一些调试信息。&lt;/p&gt;

&lt;p&gt;bug和操作系统或硬件的保护机制都会导致程序异常终止，操作系统会kill掉这些进程并产生core文件，比如常见的段错误等。&lt;/p&gt;

&lt;h3 id=&#34;为什么我的linux不会生成core文件&#34;&gt;为什么我的linux不会生成core文件&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;ulimit -a&lt;/code&gt; 命令可以查看当前系统资源的一些限制信息，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       3847
-n: file descriptors                1024
-l: locked-in-memory size (kbytes)  64
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 3847
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 &lt;strong&gt;-c: core file size&lt;/strong&gt; 如果设置为0的话，当程序崩溃的时候就不会产生core文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置core文件大小为无限&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;阻止系统生成core文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：这条命令只在当前生效，如果希望永久生效，就需要在 .bash_profile 或者类似文件中加上这条命令。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;设置core-dump的核心转储文件目录和命名规则&#34;&gt;设置Core Dump的核心转储文件目录和命名规则&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;/proc/sys/kernel/core_uses_pid&lt;/strong&gt; 可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0。需要有超级用户的权限才能进行修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;/proc/sys/kernel/core_pattern&lt;/strong&gt; 可以设置格式化的 core文件保存位置或文件名，默认的是 &lt;strong&gt;|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;需要修改的话，可以使用这条命令：&lt;code&gt;echo &amp;quot;/corefile/core-%e-%p-%t&amp;quot;&amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将会控制所产生的core文件会存放到 /corefile 目录下，产生的文件名为 &lt;strong&gt;core-命令名-pid-时间戳&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是参数列表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;%p - insert pid into filename 添加pid
%u - insert current uid into filename 添加当前uid
%g - insert current gid into filename 添加当前gid
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号
%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
%h - insert hostname where the coredump happened into filename 添加主机名
%e - insertcoredumping executable name into filename 添加命令名
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用core文件&#34;&gt;使用core文件&lt;/h3&gt;

&lt;p&gt;在linux上可以使用gdb来调试core文件，格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb [程序名] [core文件名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不知道这个core文件到底是哪个程序生成的，可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb -c[core 文件名] 来查看生成此core文件的程序名。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果中可以看出程序名，可能像下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Core wasgenerated by `./test&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后进入gdb调试状态，输入 where 就可以看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），我们可以借此找出是程序中的哪个部分导致了程序崩溃。注意：在编译程序的时候要加入选项-g。&lt;/p&gt;

&lt;h3 id=&#34;一个简单的例子&#34;&gt;一个简单的例子&lt;/h3&gt;

&lt;p&gt;编译如下的程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
 
class A
{
public:
    int a;
};
 
void fun()
{
    A*t = new A();
    t-&amp;gt;a = 1;
    cout &amp;lt;&amp;lt; t-&amp;gt;a &amp;lt;&amp;lt; endl;
    delete t;
    delete t;
}
 
int main()
{
    fun();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1
*** glibc detected *** ./test: double freeor corruption (fasttop): 0x09fd7008 ***
======= Backtrace: =========
/lib/libc.so.6[0x3ebe31]
/usr/lib/libstdc++.so.6(_ZdlPv+0x22)[0x43fc552]
./test[0x8048705]
./test[0x8048712]
/lib/libc.so.6(__libc_start_main+0xe6)[0x391d26]
./test[0x8048611]
======= Memory map: ========
00327000-00328000 r-xp 00000000 00:000          [vdso]
00334000-00351000 r-xp 00000000 08:02926955    /lib/libgcc_s-4.4.7-20120601.so.1
00351000-00352000 rw-p 0001d000 08:02926955    /lib/libgcc_s-4.4.7-20120601.so.1
00355000-00373000 r-xp 00000000 08:02926876     /lib/ld-2.12.so
00373000-00374000 r--p 0001d000 08:02926876     /lib/ld-2.12.so
00374000-00375000 rw-p 0001e000 08:02926876     /lib/ld-2.12.so
0037b000-0050c000 r-xp 00000000 08:02926877     /lib/libc-2.12.so
0050c000-0050e000 r--p 00191000 08:02926877     /lib/libc-2.12.so
0050e000-0050f000 rw-p 00193000 08:02926877     /lib/libc-2.12.so
0050f000-00512000 rw-p 00000000 00:00 0
00543000-0056b000 r-xp 00000000 08:02926889     /lib/libm-2.12.so
0056b000-0056c000 r--p 00027000 08:02926889     /lib/libm-2.12.so
0056c000-0056d000 rw-p 00028000 08:02926889     /lib/libm-2.12.so
0434d000-0442e000 r-xp 00000000 08:02155001     /usr/lib/libstdc++.so.6.0.13
0442e000-04432000 r--p 000e0000 08:02155001     /usr/lib/libstdc++.so.6.0.13
04432000-04434000 rw-p 000e4000 08:02155001     /usr/lib/libstdc++.so.6.0.13
04434000-0443a000 rw-p 00000000 00:00 0
08048000-08049000 r-xp 00000000 08:02419326    /home/wcl/fate/src/app/test/test
08049000-0804a000 rw-p 00000000 08:02419326    /home/wcl/fate/src/app/test/test
09fd7000-09ff8000 rw-p 00000000 00:000          [heap]
b7719000-b771c000 rw-p 00000000 00:00 0
b7727000-b772a000 rw-p 00000000 00:00 0
bfd2a000-bfd3f000 rw-p 00000000 00:000          [stack]
Aborted (core dumped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们对一个已经delete过了的指针再次delete，所以程序down掉了，可以看到在当前目录下已经生成了一个core.4377的文件，4377就是之前程序启动的PID。&lt;/p&gt;

&lt;p&gt;调试core文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb test core.4377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入gdb调试后，键入where命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(gdb) where
#0 0x00327424 in __kernel_vsyscall ()
#1 0x003a5b11 in raise () from /lib/libc.so.6
#2 0x003a73ea in abort () from /lib/libc.so.6
#3 0x003e59d5 in __libc_message () from /lib/libc.so.6
#4 0x003ebe31 in malloc_printerr () from /lib/libc.so.6
#5 0x043fc552 in operator delete(void*) () from/usr/lib/libstdc++.so.6
#6 0x08048705 in fun() ()
#7 0x08048712 in main ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以很明显的看出是在main函数中调用fun函数，之后delete指针的时候出错了，后面的函数调用栈就是程序输出错误信息的部分了，和我们的用户代码无关。到这一步，我们就能推断是是fun()这个函数中delete某个指针的时候出现了错误，就可以有的放矢地查找具体的问题了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>linux shell中的条件判断</title>
          <link>http://blog.fatedier.com/2014/11/24/conditional-judgement-in-linux-shell</link>
          <pubDate>Mon, 24 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/11/24/conditional-judgement-in-linux-shell</guid>
          <description>

&lt;p&gt;在日常开发中经常需要编写一些简单的部署或者测试统计之类的脚本，直接用shell来编写几条命令就可以实现一些较为复杂的功能，十分方便。不过 linux shell 中的条件判断和其他编程语言略有不同，有一些需要特别注意的地方。&lt;/p&gt;

&lt;h3 id=&#34;退出状态&#34;&gt;退出状态&lt;/h3&gt;

&lt;p&gt;在Linux系统中，每当一条命令执行完成后，系统都会返回一个退出状态，这个状态被存放在$? 这个变量中，是一个整数值，我们可以根据这个值来判断命令运行的结果是否正确。&lt;/p&gt;

&lt;p&gt;通常情况下，退出状态值为0，表示执行成功，不为0的时候表示执行失败。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;POSIX规定的退出状态和退出状态的含义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;0 （运行成功）&lt;/p&gt;

&lt;p&gt;1-255 （运行失败，脚本命令、系统命令错误或参数传递错误）&lt;/p&gt;

&lt;p&gt;126 （找到了该命令但无法执行）&lt;/p&gt;

&lt;p&gt;127 （未找到要运行的命令）&lt;/p&gt;

&lt;p&gt;128 （命令被系统强行结束）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;测试命令&#34;&gt;测试命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test expression
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用test命令进行测试，expression是一个表达式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[ expression ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了提高可读性，可以使用简化的这种格式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是大括号和表达式之间需要有一个空格，不能省略。这种方式和if、case、while等语句结合，可以作为shell脚本中的判断条件。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;整数比较运算符&#34;&gt;整数比较运算符&lt;/h3&gt;

&lt;p&gt;在shell中对两个数进行比较，不像在C/C++中可以使用 &amp;ldquo;&amp;gt;&amp;rdquo; 之类的运算符，而是使用类似参数选项的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-eq  # 如果等于则为真
-ge  # 如果大于或等于则为真
-gt  # 如果大于则为真
-le  # 如果小于或等于则为真
-lt  # 如果小于则为真
-ne  # 如果不等于则为真
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;其中的参数可以这样理解e(equal)，g(greater)，t(than)，l(less)，n(not)，这样方便记忆。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;字符串相关运算符&#34;&gt;字符串相关运算符&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-n string            # 字符串不为空则为真
-z string            # 字符串为空则为真
string1 = string2    # 字符串相等则为真 （或者 == 也可以）
string1 != string2   # 字符串不等则为真
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这里有一个需要注意的地方，就是使用 -n 这个运算符进行判断的时候需要注意在变量两边加上双引号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例如 if [ -n $string ] 应该写成 if [ -n “$string” ] ，不然该表达式总是会返回真，因为当string变量为空的时候就相当于是 if [ -n ]。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;文件操作符&#34;&gt;文件操作符&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-d file # 测试file是否为目录
-e file # 测试file是否存在
-f file # 测试file是否为普通文件
-r file # 测试file是否是进程可读文件
-s file # 测试file的长度是否不为0
-w file # 测试file是否是进程可写文件
-x file # 测试file是否是进程可执行文件
-L file # 测试file是否符号化链接
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;逻辑运算符&#34;&gt;逻辑运算符&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;! expression                # 非
expression1 -a expression2  # 与
expression1 -o expression2  # 或
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多重的嵌套&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [ $a == 1 ] &amp;amp;&amp;amp; [ $b == 1 -o $b == 3 ]
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用astyle进行代码格式化</title>
          <link>http://blog.fatedier.com/2014/11/10/use-astyle-to-format-code</link>
          <pubDate>Mon, 10 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/11/10/use-astyle-to-format-code</guid>
          <description>

&lt;p&gt;在参与团队的开发的时候，由于平台和编写代码的工具的不同等等问题，经常会遇到代码格式非常混乱的情况，严重影响了代码的阅读效率。后来发现了一款比较好的工具 &amp;ndash; &amp;ldquo;astyle&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;astyle这个工具可以将现有的代码格式转换为指定的风格，当你将乱七八糟的代码用astyle转换一下之后，就会感觉整个世界都清静了……&lt;/p&gt;

&lt;h3 id=&#34;如何获取&#34;&gt;如何获取&lt;/h3&gt;

&lt;p&gt;astyle是一个开放源码的项目，支持C/C++、C#和java的代码格式化&lt;/p&gt;

&lt;p&gt;SourceForge地址: &lt;a href=&#34;http://sourceforge.net/projects/astyle/&#34;&gt;http://sourceforge.net/projects/astyle/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的Github拷贝: &lt;a href=&#34;https://github.com/fatedier/fatedier-tools/tree/master/astyle&#34;&gt;https://github.com/fatedier/fatedier-tools/tree/master/astyle&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;

&lt;p&gt;直接写一个Makefile编译下源码，我的Github的拷贝里有写好的Makefile，直接用gmake命令编译一下就可以用了。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./astyle --style=ansi test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行之后会提示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Formatted  xxx/test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;astyle&lt;/strong&gt; 会在当前目录下生成一个备份文件，以 &lt;strong&gt;.orig&lt;/strong&gt; 结尾，例如 &amp;ldquo;test.cpp.orig&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;test.cpp&lt;/strong&gt; 就已经转换为了 &lt;strong&gt;ansi&lt;/strong&gt; 代码风格了。&lt;/p&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;注：使用 &amp;ndash;help 选项可以查看astyle的帮助文档&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;style风格设置&#34;&gt;style风格设置&lt;/h4&gt;

&lt;p&gt;常用的代码风格主要有三种: &lt;strong&gt;ansi&lt;/strong&gt; 和 &lt;strong&gt;k&amp;amp;r&lt;/strong&gt; 以及 &lt;strong&gt;java&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ndash;style=allman  OR &amp;ndash;style=ansi OR &amp;ndash;style=bsd OR &amp;ndash;style=break OR -A1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Foo()
{
   if (isBar)
    {
       bar();
       return 1;
    }
   else
    {
       return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;style=kr OR &amp;ndash;style=k&amp;amp;r OR &amp;ndash;style=k/r OR -A3&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Foo()
{
   if (isBar) {
       bar();
       return 1;
    }else {
       return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;style=java OR &amp;ndash;style=attach OR -A2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Foo() {
   if (isBar) {
       bar();
       return 1;
    }else {
       return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;tab选项&#34;&gt;Tab选项&lt;/h4&gt;

&lt;p&gt;默认是使用4个空格替换一个tab。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ndash;indent=spaces=# OR -s#&lt;/p&gt;

&lt;p&gt;指定用几个空格替换一个tab，例如 &amp;ndash;indent=spaces=8 ，指定用8个空格替换一个tab。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;indent=tab OR &amp;ndash;indent=tab=# OR -t OR -t#&lt;/p&gt;

&lt;p&gt;指定缩进使用tab，=#同上，指定一个tab占几个空格，不说明的话默认是4个。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;递归处理&#34;&gt;递归处理&lt;/h4&gt;

&lt;p&gt;&amp;ndash;recursive OR -r OR -R&lt;/p&gt;

&lt;p&gt;可以递归处理所有子目录的文件。&lt;/p&gt;

&lt;h4 id=&#34;排除不处理的文件&#34;&gt;排除不处理的文件&lt;/h4&gt;

&lt;p&gt;&amp;ndash;exclude=####&lt;/p&gt;

&lt;p&gt;指定哪些文件或者文件夹不需要进行处理。&lt;/p&gt;

&lt;h4 id=&#34;指定配置文件&#34;&gt;指定配置文件&lt;/h4&gt;

&lt;p&gt;&amp;ndash;options=####&lt;/p&gt;

&lt;p&gt;可以指定读取某个文件的内容作为参数选项。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Linux下如何进行文件编码格式转换</title>
          <link>http://blog.fatedier.com/2014/11/03/how-to-convert-file-encoding-format-on-linux</link>
          <pubDate>Mon, 03 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/11/03/how-to-convert-file-encoding-format-on-linux</guid>
          <description>

&lt;p&gt;最近把项目放到github上，但是发现代码中注释的中文部分有些是乱码，检查后发现是因为我的Centos装在虚拟机上，而我是在Windows环境下通过UE来写代码的，而UE默认是使用ASCII编码。为了避免在UE里对一个个文件进行手动修改，希望在Linux上使用命令来批量转换编码格式。&lt;/p&gt;

&lt;p&gt;查了资料后发现可以使用 &lt;strong&gt;iconv&lt;/strong&gt; 命令。&lt;/p&gt;

&lt;p&gt;首先使用 &lt;strong&gt;file&lt;/strong&gt; 命令来检测文件的类型&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;file test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ISO-8859 Cprogram text
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iconv命令的参数说明&#34;&gt;iconv命令的参数说明&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-l  列出所有已知的字符集
-f  原始文本编码
-t  输出文本编码
-o  输出文件名
-s  关闭警告
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iconv -f GB2312 -t UTF-8 test.cpp &amp;gt; test_utf.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为iconv默认输出到标准输出，所以我们需要重定向到一个其他文件。&lt;strong&gt;（这里不能重定向到自身，否则会清空文件内容）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想要把输出内容直接输出到当前文件，可以这样用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iconv -f GB2312 -t UTF-8 -o test.cpp test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;附上我自己用的编码转换脚本-iconvfa-sh&#34;&gt;附上我自己用的编码转换脚本 iconvfa.sh&lt;/h3&gt;

&lt;h4 id=&#34;使用说明&#34;&gt;使用说明&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage:
    iconvfa.sh [option] [file|dir]
    from GB2312 to UTF-8, the old file will be replaced by the new converted file

Options:
    -R: convert files recursively, the following parameter should be the directory name
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;脚本代码&#34;&gt;脚本代码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/env bash

function show_help
{
    echo &amp;quot;Usage:&amp;quot;
    echo &amp;quot;  iconvfa.sh [option] [file|dir]&amp;quot;
    echo -e &amp;quot;  from GB2312 to UTF-8, the old file will be replaced by the new converted file\n&amp;quot;
    echo &amp;quot;Options:&amp;quot;
    echo &amp;quot;  -R: convert files recursively, the following parameter should be the directory name&amp;quot;
}

# param 1: directory name
function convert_rescursive()
{
   local dir_path=`echo $1 | sed &#39;s/\(.*\)\/$/\1/g&#39;`
   local dir_names=`ls ${dir_path} -l | awk &#39;/^d/{print $NF}&#39;`
   
   # convert files in this directory
   local file_names=`ls ${dir_path} -l | awk &#39;/^-/{print $NF}&#39;`
   for file in ${file_names}
   do
       iconv -f ${from_code} -t ${to_code} ${dir_path}/${file} &amp;amp;&amp;gt; /dev/null
       if [ $? == 0 ]; then
           iconv -f ${from_code} -t ${to_code} &amp;lt; ${dir_path}/${file} &amp;gt; $@.$$$$
           cp $@.$$$$ ${dir_path}/${file}
           rm -f $@.$$$$
           echo &amp;quot;File ${dir_path}/${file} is formatted.&amp;quot;
       fi
   done

   # if the directory has no other directory, return 0
   if [ &amp;quot;${dir_names}X&amp;quot; == &amp;quot;X&amp;quot; ]; then
       return 0
   fi

   # continue convert files in directories recursively
   for dir in ${dir_names}
   do
       convert_rescursive &amp;quot;${dir_path}/${dir}&amp;quot;
   done 
}

# defines
from_code=&amp;quot;GB2312&amp;quot;
to_code=&amp;quot;UTF-8&amp;quot;

case &amp;quot;$1&amp;quot; in
&amp;quot;-R&amp;quot;)
    ls $2 &amp;amp;&amp;gt; /dev/null
    if [ $? != 0 -o &amp;quot;$2X&amp;quot; == &amp;quot;X&amp;quot; ]; then
        echo &amp;quot;#### error: please check the directory name following the &#39;-R&#39; option!&amp;quot;
        exit 1
    fi
    convert_rescursive $2
    ;;
&amp;quot;&amp;quot;)
    show_help
    ;;
*)
    iconv -f ${from_code} -t ${to_code} $1 &amp;amp;&amp;gt; /dev/null
    if [ $? == 0 ]; then
        iconv -f ${from_code} -t ${to_code} &amp;lt; $1 &amp;gt; $@.$$$$
        cp $@.$$$$ $1
        rm -f $@.$$$$
        echo &amp;quot;File $1 is formatted.&amp;quot;
    else
        echo &amp;quot;Convert wrong!&amp;quot;
    fi
    ;;
esac
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用Vim打造自己的IDE</title>
          <link>http://blog.fatedier.com/2014/10/29/use-vim-to-make-my-ide</link>
          <pubDate>Wed, 29 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/29/use-vim-to-make-my-ide</guid>
          <description>

&lt;p&gt;之前一直使用UE的FTP功能编辑Linux虚拟机上的代码文件，之后再切换到Linux上去编译，调试程序，感觉这样比较麻烦，而且UE的功能也不像VS以及Eclipse的IDE那样强大，所以就查阅了一些资料，想要把Linux下最常用的文本编辑工具Vim打造成一个适合自己的IDE，可以直接ssh登陆到远程机器上直接进行开发。&lt;/p&gt;

&lt;p&gt;配置自己的Vim过程中参考了以下的blog和文档：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/fbfsber008/article/details/7055842&#34;&gt;http://blog.csdn.net/fbfsber008/article/details/7055842&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.douban.com/note/257815917/&#34;&gt;http://www.douban.com/note/257815917/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/vim-scripts/vundle&#34;&gt;https://github.com/vim-scripts/vundle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-10-29-use-vim-to-make-my-ide-overview.jpg&#34; alt=&#34;overview&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在把整个配置的过程记录下来，方便以后参考。&lt;/p&gt;

&lt;h3 id=&#34;前期准备&#34;&gt;前期准备&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;有一个github帐号&lt;/li&gt;
&lt;li&gt;Linux上安装git版本控制工具，可以使用命令安装，例如 yum install git&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;github是一个好地方，不仅可以浏览很多的开源程序，而且可以把自己正在开发的项目或者有用的文档托管在上面，不管在其他任何的计算机上都可以很容易的获取到。&lt;/p&gt;

&lt;p&gt;比如我的 .vimrc 的配置文件就放在了Github上，有一个版本库是专门用来存放配置文件的。&lt;/p&gt;

&lt;p&gt;地址为：&lt;a href=&#34;https://github.com/fatedier/dot_file&#34;&gt;https://github.com/fatedier/dot_file&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;vim常用配置&#34;&gt;vim常用配置&lt;/h3&gt;

&lt;p&gt;个人的vim配置文件一般是放在用户主目录下的.vimrc文件。&lt;/p&gt;

&lt;p&gt;配置文件中 &lt;code&gt;&amp;quot;&lt;/code&gt; 之后的部分都被当作注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;if v:lang =~ &amp;quot;utf8$&amp;quot; || v:lang =~&amp;quot;UTF-8$&amp;quot;
    set fileencodings=ucs-bom,utf-8,latin1
endif
       
set nocompatible            &amp;quot; Use Vim defaults (much better!)
set bs=indent,eol,start     &amp;quot; allow backspacing overeverything in insert mode
set viminfo=&#39;20,\&amp;quot;50        &amp;quot; read/write a .viminfo file, don&#39;t store more
                            &amp;quot; than 50 lines of registers
set history=50              &amp;quot; keep 50 lines of command line history
set ruler                   &amp;quot; show the cursor position all the time
                                    
&amp;quot; -----------个人设置-----------
filetype off

set ts=4          &amp;quot; tab所占空格数
set shiftwidth=4  &amp;quot; 自动缩进所使用的空格数
set expandtab     &amp;quot; 用空格替换tab
set autoindent    &amp;quot; 自动缩进
set smartindent   &amp;quot; C语言缩进
set number        &amp;quot; 显示行号
set ignorecase    &amp;quot; 搜索忽略大小写
set incsearch     &amp;quot; 输入字符串就显示匹配点
set showtabline=2 &amp;quot; 总是显示标签页
                                      
if has(&amp;quot;mouse&amp;quot;)
    set mouse=iv  &amp;quot; 在 insert 和 visual 模式使用鼠标定位
endif
      
&amp;quot; -------------颜色配置-------------
&amp;quot; 补全弹出窗口
hi Pmenu ctermbg=light magenta
&amp;quot; 补全弹出窗口选中条目
hi PmenuSel ctermbg=yellow ctermfg=black
       
&amp;quot; -------------键盘映射-------------
&amp;quot; Ctrl+S 映射为保存
nnoremap &amp;lt;C-S&amp;gt; :w&amp;lt;CR&amp;gt;
inoremap &amp;lt;C-S&amp;gt;&amp;lt;Esc&amp;gt;:w&amp;lt;CR&amp;gt;a
        
&amp;quot; Ctrl+C 复制，Ctrl+V 粘贴
inoremap &amp;lt;C-C&amp;gt; y
inoremap &amp;lt;C-V&amp;gt; &amp;lt;Esc&amp;gt;pa
vnoremap &amp;lt;C-C&amp;gt; y
vnoremap &amp;lt;C-V&amp;gt; p
nnoremap &amp;lt;C-V&amp;gt; p

&amp;quot; F3 查找当前高亮的单词
inoremap &amp;lt;F3&amp;gt;*&amp;lt;Esc&amp;gt;:noh&amp;lt;CR&amp;gt;:match Todo /\k*\%#\k*/&amp;lt;CR&amp;gt;v
vnoremap &amp;lt;F3&amp;gt;*&amp;lt;Esc&amp;gt;:noh&amp;lt;CR&amp;gt;:match Todo /\k*\%#\k*/&amp;lt;CR&amp;gt;v

&amp;quot; Ctrl+\ 取消缩进
inoremap &amp;lt;C-\&amp;gt; &amp;lt;Esc&amp;gt;&amp;lt;&amp;lt;i
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用vundle管理vim插件&#34;&gt;使用vundle管理vim插件&lt;/h3&gt;

&lt;p&gt;很多时候我们的vim都需要安装大量的插件，需要进行各种配置，而且插件路径下面的文件也会变的非常混乱，这个时候使用 &lt;strong&gt;vundle&lt;/strong&gt; 就是一个不错的选择。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vim-scripts/vundle&#34;&gt;vundle&lt;/a&gt; 是可以算是一个用来管理各种vim插件的插件。&lt;/p&gt;

&lt;h4 id=&#34;安装ctags&#34;&gt;安装ctags&lt;/h4&gt;

&lt;p&gt;直接使用命令 yuminstall ctags 进行安装。&lt;/p&gt;

&lt;p&gt;之后在你的项目文件的根目录中执行如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ctags -R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会发现当前目录下生成了一个名为tags的文件。&lt;/p&gt;

&lt;p&gt;tags文件是由ctags程序产生的一个索引文件，如果你在读程序时看了一个函数调用, 或者一个变量, 或者一个宏等等, 你想知道它们的定义在哪儿，tags文件就起作用了。使用把光标移动到你想查的地方，按下&amp;rdquo;Ctrl + ]&amp;ldquo;，就可以跳转到定义处。&lt;/p&gt;

&lt;p&gt;最后需要在vim配置文件中将tags文件加入到vim中来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;set tags=~/tags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：这里需要填具体的tags文件所在路径。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;先安装vundle这个插件&#34;&gt;先安装vundle这个插件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后其他的插件也都会被放在~/.vim/bundle这个目录下。&lt;/p&gt;

&lt;h4 id=&#34;安装其他需要的插件&#34;&gt;安装其他需要的插件&lt;/h4&gt;

&lt;p&gt;以后当你需要安装其他的vim插件的时候，直接在.vimrc中加上如下部分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;filetype off
 
setrtp+=~/.vim/bundle/vundle/
call vundle#rc()
&amp;quot; Bundles
&amp;quot; 显示变量、函数列表等
Bundle&amp;quot;taglist.vim&amp;quot;
&amp;quot; 窗口管理器
Bundle&amp;quot;winmanager&amp;quot;
&amp;quot; 标签工具
Bundle&amp;quot;Visual-Mark&amp;quot;
&amp;quot; 代码补全工具
Bundle&amp;quot;neocomplcache&amp;quot;
  
filetype pluginindent on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bundle 后面的插件名称用引号引起来，最后在vim中输入:BundleInstall就会完成自动安装，实际上是也是从github上下载各种插件，因为大多数的插件已经备份在了github上的vim-scripts上。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:PluginSearch&lt;/code&gt; 命令可以查看有哪些插件可以直接使用插件名下载的。&lt;/p&gt;

&lt;p&gt;如果你需要的插件在这个里面没有找到，那么在.vimrc配置文件中可以直接用git远程仓库的地址，例如要安装command-t这个插件，可以在配置文件中加上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Bundle &amp;quot;git://git.wincent.com/command-t.git&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就会直接从这个地址上下载所需插件。&lt;/p&gt;

&lt;h3 id=&#34;其他插件的配置与使用&#34;&gt;其他插件的配置与使用&lt;/h3&gt;

&lt;h4 id=&#34;快速浏览源码-taglist&#34;&gt;快速浏览源码：TagList&lt;/h4&gt;

&lt;p&gt;在Windows平台我经常用来浏览项目源码的工具就是SourceInsight，会在窗口左边列出当前文件中的变量、宏、函数名等等，点击以后就会快速跳转到页面相应的地方，使用taglist就可以在vim中实现相同的效果。&lt;/p&gt;

&lt;p&gt;通过vundle安装完成后，在vim中使用 &lt;code&gt;:Tlist&lt;/code&gt; 命令就可以打开TagList窗口。&lt;/p&gt;

&lt;h4 id=&#34;窗口管理器-winmanager&#34;&gt;窗口管理器：WinManager&lt;/h4&gt;

&lt;p&gt;WinManager可以帮助我们管理在屏幕上显示的多个窗口。&lt;/p&gt;

&lt;p&gt;之后我们需要设置一下在normal模式下可以直接输入wm来打开文件管理窗口以及TagList，.vimrc文件增加如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:winManagerWindowLayout=&#39;FileExplorer|TagList&#39;
nnoremap wm:WMToggle&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：nnoremap是设置键盘映射。第一个字母n是normal模式，i是insert模式，v是visual模式。加上nore表示不会递归替换命令，比如a映射到b，b映射到c，那么按a不会得到按c的效果。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;高亮标签-visualmark&#34;&gt;高亮标签：VisualMark&lt;/h4&gt;

&lt;p&gt;这个插件的作用就是在浏览代码的时候在指定的行上添加标签，之后可以快速跳转回来，方便快捷。&lt;/p&gt;

&lt;p&gt;安装完成之后直接就可以在vim中使用。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;mm&amp;rdquo; 命令会在当前行添加标签，再次按 &amp;ldquo;mm&amp;rdquo; 会取消标签。&lt;/p&gt;

&lt;p&gt;按下“F2”可以在多个标签之间进行快速跳转。&lt;/p&gt;

&lt;h4 id=&#34;自动补全-neocomplcache&#34;&gt;自动补全：neocomplcache&lt;/h4&gt;

&lt;p&gt;这个补全插件需要tags文件的支持，所以需要安装ctags，并且在项目根目录生成tags文件，之后在.vimrc中加入这个tags文件。&lt;/p&gt;

&lt;p&gt;并且在配置文件中加上如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:neocomplcache_enable_at_startup = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行是设置是否自动启用补全，为1代表启用。这样就不需要每次都使用Ctrl+P或者Ctrl+N来弹出补全列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;let g:neocomplcache_enable_auto_select = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行是设置是否启用自动选择，为1代表启用。这个时候弹出补全列表的时候会自动选择第一个，按下Enter键就会使用列表的第一项，否则每一次都需要自己多按一次进行选择。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>vimdiff常用命令</title>
          <link>http://blog.fatedier.com/2014/10/24/vimdiff-common-commands</link>
          <pubDate>Fri, 24 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/24/vimdiff-common-commands</guid>
          <description>

&lt;p&gt;整理了一下在使用vimdiff进行文件合并的时候用到的一些常用的命令，方便以后查询。&lt;/p&gt;

&lt;p&gt;可以有多种方式使用vimdiff，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vimdiff [file1] [file2]

vim -d [file1] [file2]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;其他的一些的编辑命令与vim相同，这里主要记录一些常用的合并文件需要用到的命令：&lt;/p&gt;

&lt;h4 id=&#34;ctrl-w之后按w&#34;&gt;Ctrl+w之后按w&lt;/h4&gt;

&lt;p&gt;可以切换到另外一个文件&lt;/p&gt;

&lt;h4 id=&#34;c&#34;&gt;[c&lt;/h4&gt;

&lt;p&gt;跳转到上一个差异点&lt;/p&gt;

&lt;h4 id=&#34;c-1&#34;&gt;]c&lt;/h4&gt;

&lt;p&gt;跳转到下一个差一点&lt;/p&gt;

&lt;h4 id=&#34;zo或者i&#34;&gt;zo或者i&lt;/h4&gt;

&lt;p&gt;展开折叠区域，或者使用i进入插入模式也会进行展开&lt;/p&gt;

&lt;h4 id=&#34;zc&#34;&gt;zc&lt;/h4&gt;

&lt;p&gt;重新折叠，可以把使用zo展开折叠的区域恢复原样&lt;/p&gt;

&lt;h4 id=&#34;dp-diff-put的意思&#34;&gt;dp（diff put的意思）&lt;/h4&gt;

&lt;p&gt;把当前文件的差异点内容复制到另一个文件&lt;/p&gt;

&lt;h4 id=&#34;do-diff-obtain的意思&#34;&gt;do（diff obtain的意思）&lt;/h4&gt;

&lt;p&gt;把另一个文件的差异点内容复制到当前文件&lt;/p&gt;

&lt;h4 id=&#34;diffupdate&#34;&gt;:diffupdate&lt;/h4&gt;

&lt;p&gt;有时候修改了文件之后不会立即刷新重新比对，使用该命令可以重新进行文件比较。&lt;/p&gt;

&lt;h4 id=&#34;qa&#34;&gt;qa&lt;/h4&gt;

&lt;p&gt;退出所有打开的文件，但是不保存&lt;/p&gt;

&lt;h4 id=&#34;wqa&#34;&gt;wqa&lt;/h4&gt;

&lt;p&gt;退出并保存所有已打开的文件&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>主机使用代理上网，虚拟机Linux的shell如何连外网</title>
          <link>http://blog.fatedier.com/2014/10/14/how-virtual-machine-connect-internet-while-host-getonline-with-agent</link>
          <pubDate>Tue, 14 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/10/14/how-virtual-machine-connect-internet-while-host-getonline-with-agent</guid>
          <description>&lt;p&gt;在公司电脑上网都需要使用代理，虚拟机里面装的Linux系统需要使用yum命令来安装软件，所以需要在shell界面能连上外网才行。&lt;/p&gt;

&lt;p&gt;因为公司限制了每个人只能用一个IP，所以虚拟机中的Linux系统使用NAT方式和主机相连。主机是Win7操作系统，会发现网络里面多了VMnet8这个网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-10-14-how-virtual-machine-connect-internet-while-host-getonline-with-agent-vmware-net.jpg&#34; alt=&#34;vmware-net&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在VMware界面，点击“编辑”，“虚拟网络编辑器”&lt;/p&gt;

&lt;p&gt;可以看到子网地址分配的是192.168.131.0&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;一般来说这时我们的主机会自动分配一个IP类似192.168.131.1这样的，子网掩码为255.255.255.0，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-10-14-how-virtual-machine-connect-internet-while-host-getonline-with-agent-host-net.jpg&#34; alt=&#34;host-net&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在进入虚拟机的Linux进行设置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-10-14-how-virtual-machine-connect-internet-while-host-getonline-with-agent-network-configuration.jpg&#34; alt=&#34;network-configuration&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意IP需要设置成192.168.131.x的形势，网关是192.168.131.2。&lt;/p&gt;

&lt;p&gt;之后使用 &lt;code&gt;service network restart&lt;/code&gt; 命令重启网络服务。&lt;/p&gt;

&lt;p&gt;然后可以用 &lt;code&gt;ifconfig&lt;/code&gt; 命令检查配置是否正确。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后，修改自己目录下的配置文件，使用“cd”命令进入自己的根目录。&lt;/p&gt;

&lt;p&gt;比如我的是.bash_profile&lt;/p&gt;

&lt;p&gt;添加代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export http_proxy=&amp;quot;http://proxy_addr:port&amp;quot;
export https_proxy=&amp;quot;http://proxy_addr:port&amp;quot;
export ftp_proxy=&amp;quot;http://proxy_addr:port&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;proxy_addr&lt;/strong&gt; 就是代理的IP地址&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;port&lt;/strong&gt; 是代理的款口号&lt;/p&gt;

&lt;p&gt;如果代理需要用户名和密码的话，这样设置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export http_proxy=&amp;quot;http://username:password@proxy_addr:port&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以使用yum命令安装需要的软件了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>size() == 0和empty()的比较</title>
          <link>http://blog.fatedier.com/2014/09/26/function-size-equal-zero-compare-with-empty</link>
          <pubDate>Fri, 26 Sep 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/09/26/function-size-equal-zero-compare-with-empty</guid>
          <description>

&lt;p&gt;最近开发公司项目的时候发现大量用到了STL模板库，而且很多地方都需要判断一个容器是否为空，看到了两种写法，分别使用了容器的 size() 函数和 empty()函数。&lt;/p&gt;

&lt;p&gt;我觉得很好奇，这两种写法有什么区别呢？在网上查阅了一些资料，发现说empty()效率更高的占大多数。又查看了SGI STL的帮助文档，里面有一句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you are testing whether a container is empty, you should always write c.empty()instead of c.size() == 0. The two expressions are equivalent, but the formermay be much faster.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大致上的意思就是在检测容器是否为空的时候，推荐用empty()代替使用size() == 0，两者的含义是相等的，但是前者可能会更快一些。&lt;/p&gt;

&lt;p&gt;之后又在stackoverflow上看到有人提了一个类似的问题，并且贴出了STL的实现源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool empty()const
    {return(size() == 0); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就让我更诧异了，这样的话empty()会比size() == 0更高效吗？&lt;/p&gt;

&lt;p&gt;实践是检验真理的唯一标准，那么我们就亲自来测试一下吧。&lt;/p&gt;

&lt;p&gt;为了公平起见，也为了测试方便，我分别在两个平台上进行测试，分别是Aix5.3以及Centos6.5。&lt;/p&gt;

&lt;p&gt;由于容器的内部实现的不同，我们测试三种比较典型也用的较多的容器：vector、list以及map。&lt;/p&gt;

&lt;p&gt;测试的代码如下，因为代码基本上差别不大，这里只贴一下测试vector的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

class A
{
public:
    int a;
};

int main()
{
    cout &amp;lt;&amp;lt; &amp;quot;vector:&amp;quot; &amp;lt;&amp;lt; endl;

    long number = 20000000;
    vector&amp;lt;A&amp;gt; tmpList;
    A temp;
    temp.a = 1;

    struct timeval tv_begin, tv_end;

    //初始化tmpList中元素个数为：number
    tmpList.resize(number);

    //对size() == 0计时
    int flag = 0;
    gettimeofday(&amp;amp;tv_begin, NULL);
    for(long i=0; i&amp;lt;number*5; i++)
    {
        if(tmpList.size() == 0)
        {
        }
    }
    gettimeofday(&amp;amp;tv_end, NULL);
    cout &amp;lt;&amp;lt; &amp;quot;size() msec: &amp;quot; &amp;lt;&amp;lt; (tv_end.tv_sec - tv_begin.tv_sec)*1000 + (tv_end.tv_usec - tv_begin.tv_usec)/1000 &amp;lt;&amp;lt; endl;

    //对empty()计时
    gettimeofday(&amp;amp;tv_begin, NULL);
    for(long i=0; i&amp;lt;number*5; i++)
    {
        if(tmpList.empty())
        {
        }
    }
    gettimeofday(&amp;amp;tv_end, NULL);
    cout &amp;lt;&amp;lt; &amp;quot;empty() msec: &amp;quot; &amp;lt;&amp;lt; (tv_end.tv_sec - tv_begin.tv_sec)*1000 + (tv_end.tv_usec - tv_begin.tv_usec)/1000 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用到了gettimeofday这个函数用来计时，在需要计时的地方分别调用两次该函数之后得到的时间相减即可获得该代码段执行的时间。&lt;/p&gt;

&lt;p&gt;timeval结构体有两个变量分别是tv_sec和tv_usec分别是精确到秒和微秒级别。&lt;/p&gt;

&lt;p&gt;因为这两个函数本身耗时太短，不方便测算时间，所以采取重复调用再计时的方法。&lt;/p&gt;

&lt;h3 id=&#34;vector&#34;&gt;vector&lt;/h3&gt;

&lt;h4 id=&#34;aix&#34;&gt;Aix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;第1次输出：
vector:
size() msec:2736
empty() msec:4820

第2次输出：
vector:
size() msec:2762
empty() msec:4877
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;centos&#34;&gt;Centos&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;第1次输出：
vector:
size() msec: 298
empty() msec:1541

第2次输出：
vector:
size() msec: 283
empty() msec:1530
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list&#34;&gt;list&lt;/h3&gt;

&lt;h4 id=&#34;aix-1&#34;&gt;Aix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;第1次输出：
vector:
size() msec: 13
empty() msec: 22

第2次输出：
vector:
size() msec: 13
empty() msec: 22
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;centos-1&#34;&gt;Centos&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;第1次输出：
vector:
size() msec: 241696
empty() msec: 1

第2次输出：
vector:
size() msec: 242109
empty() msec: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map&#34;&gt;map&lt;/h3&gt;

&lt;h4 id=&#34;aix-2&#34;&gt;Aix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;第1次输出：
vector:
size() msec: 1337
empty() msec: 1733

第2次输出：
vector:
size() msec: 1339
empty() msec: 1733
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;centos-2&#34;&gt;Centos&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;第1次输出：
vector:
size() msec: 291
empty() msec: 267

第2次输出：
vector:
size() msec: 290
empty() msec: 304
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，并非在所有情况下empty()的效率都是优于size()的。具体的效率还和所使用的平台相关，准确的说是和STL源码的实现方式有关。&lt;/p&gt;

&lt;p&gt;下面我们就一起来看一下两个系统中STL源码部分是如何实现size()和empty()的。&lt;/p&gt;

&lt;h3 id=&#34;vector源码&#34;&gt;vector源码&lt;/h3&gt;

&lt;h4 id=&#34;aix-3&#34;&gt;Aix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;size_type size() const
    {return (_Size); }
 
bool empty() const
    {return (size() == 0); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出Aix上vector的empty()函数实际上是调用了size()函数进行判断，size()函数返回的是表示当前容器数量的一个变量，所以，显然，size() == 0的效率是要高于empty()的，因为少了函数调用部分的耗时。&lt;/p&gt;

&lt;h4 id=&#34;centos-3&#34;&gt;Centos&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;size_type size() const
    { return size_type(this-&amp;gt;_M_impl._M_finish -this-&amp;gt;_M_impl._M_start); }
 
bool empty() const
    { return begin() == end(); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里size()是尾指针减去头指针得到的，而empty()是比较头指针和尾指针是否相等。在empty()里多了函数调用以及临时变量赋值等操作。&lt;/p&gt;

&lt;h3 id=&#34;list源码&#34;&gt;list源码&lt;/h3&gt;

&lt;h4 id=&#34;aix-4&#34;&gt;Aix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;size_type size() const
    {return (_Size); }
 
bool empty() const
    {return (size() == 0); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aix上对于在list中的处理方式依然和vector一样，维护了一个_Size变量，empty()多了一层函数调用，效率较低。&lt;/p&gt;

&lt;h4 id=&#34;centos-4&#34;&gt;Centos&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;size_type size() const
    { return std::distance(begin(), end()); }
 
bool empty() const
    { return this-&amp;gt;_M_impl._M_node._M_next ==&amp;amp;this-&amp;gt;_M_impl._M_node; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;size()函数调用了distance函数用遍历的方法取得两个指针间的元素个数，然后返回。而empty()函数则是判断头指针的下一个节点是否是自己本身，只需要进行一次判断。所以，当list容器元素个数较多的时候，这里的empty()效率远大于size() == 0。&lt;/p&gt;

&lt;h3 id=&#34;map源码&#34;&gt;map源码&lt;/h3&gt;

&lt;h4 id=&#34;aix-5&#34;&gt;Aix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;size_type size() const
    {return (_Size); }
 
bool empty() const
    {return (size() == 0); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不出意外，可以看出Aix上依然维护了一个_Size变量，在判断的时候都是用这个变量来判断，但是empty()多了一层函数调用，所以效率上会稍微低一些。&lt;/p&gt;

&lt;h4 id=&#34;centos-5&#34;&gt;Centos&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool empty() const
    { return _M_impl._M_node_count == 0; }
 
size_type size() const
    { return _M_impl._M_node_count; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的map用到了红黑树，就不详细解释了，有兴趣的同学可以自己查阅相关资料。代码中empty()和size()用到的都是保存红黑树的节点数的变量，可以看出empty()和size() == 0两者其实是等价的。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;并不是所有的时候用empty()的效率都比size() == 0要高。&lt;/p&gt;

&lt;p&gt;例如在Aix上，由于所有的容器都维护了一个保存元素个数的值，调用size()的时候直接返回，而调用empty()的时候还是要去调用size()函数，所以会多一次函数调用的开销。在Aix上，显然使用size() == 0替代empty()将会使程序效率更高。&lt;/p&gt;

&lt;p&gt;而在Centos上，由于STL源码的实现方式不同，需要考虑到使用的容器，不同的容器调用size()和empty()的开销也不同，但是，相对来说，使用empty()的效率更加平均，例如在使用list容器的时候，如果数据量较大，size()的开销太大，而empty()则不会出现这种极端情况。&lt;/p&gt;

&lt;p&gt;如果考虑到平台迁移等等将来可能出现的状况，显然，empty()比size() == 0更加合适，可以确保你的程序不会出现太大的性能问题。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>从简单实例开始，学会写Makefile（二）</title>
          <link>http://blog.fatedier.com/2014/09/24/learn-to-write-makefile-02</link>
          <pubDate>Wed, 24 Sep 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/09/24/learn-to-write-makefile-02</guid>
          <description>

&lt;p&gt;如果文件间存在着相互之间的引用关系该怎么办？如果把.h文件和.cpp文件放在了不同的目录下该怎么办？如果我想生成静态库，然后在其他地方引用静态库该怎么办？如果我想将程序迁移到Unix平台下，使用不同的编译器，难道要依次修改所有的Makefile？&lt;/p&gt;

&lt;h3 id=&#34;d文件-解决文件间的相互引用&#34;&gt;.d文件，解决文件间的相互引用&lt;/h3&gt;

&lt;h4 id=&#34;自动生成依赖关系&#34;&gt;自动生成依赖关系&lt;/h4&gt;

&lt;p&gt;在前文的项目基础上，考虑一下这种情况：如果我们在w1.h文件里包含了头文件w2.h以及w3.h并且用到其中定义的函数。&lt;/p&gt;

&lt;p&gt;第一次编译没有遇到问题，但是如果后续的开发过程中修改了w2.h或者w3.h文件中的内容，再执行gmake命令的时候，就遇到问题了——w1.cpp文件不会被重新编译了！&lt;/p&gt;

&lt;p&gt;显然，我们需要将生成目标文件w1.o的规则的依赖项加上w2.h和w3.h。可是如果手动的去检查每一个文件的引用关系，然后修改Makefile文件，这样做的效率就太低了。&lt;/p&gt;

&lt;p&gt;万幸的是，编译器可以帮助我们自动生成依赖关系，只需要在编译命令中加上“-M”选项，就可以让编译器自动寻找源文件中包含的头文件，并生成一个依赖关系，例如，你可以在shell界面下敲下如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++-MM w1.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，其输出为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;w1.o:w1.cpp w2.h w3.h。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要特别注意的是，我们使用“-MM”而不是“-M”，因为我们使用的是GUN的C/C++编译器，使用“-M”参数会将标准库的头文件也一并包含进来，但这并不是我们想要的，而使用“-MM”则不会。&lt;/p&gt;

&lt;p&gt;现在的问题是，如何利用这个命令去写好我们的Makefile呢？&lt;/p&gt;

&lt;p&gt;GUN组织建议把每一个源文件自动生成的依赖关系放到一个.d文件中，让每一个.cpp文件都对应一个.d文件，例如之前的w1.cpp，我们可以生成一个w1.d文件，内容为自动生成的依赖关系 w1.o:w1.cpp w2.h w3.h，然后在Makefile中包含所有的.d文件，我们只需要写出.cpp文件和.d文件的依赖关系，让make自动更新或生成.d文件即可。&lt;/p&gt;

&lt;h4 id=&#34;生成-d文件&#34;&gt;生成.d文件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dep/%.d:%.cpp
    @if test ! -d &amp;quot;dep&amp;quot;; then\
        mkdir -p dep;\
    fi; \
    set -e; rm -f $@;
    g++ -MM $&amp;lt; &amp;gt; $@.$$$$; \
    sed &#39;s/$*\.o[ :]*/obj\/$*\.o dep\/$*\.d: /g&#39; &amp;lt; $@.$$$$ &amp;gt; $@; \
    rm -f $@.$$$$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Makefile中加上如上的代码，就可以生成我们所需要的.d文件了。&lt;/p&gt;

&lt;p&gt;又是一堆莫名其妙的符号，我们还是来逐句进行分析。&lt;/p&gt;

&lt;h5 id=&#34;dep-d-cpp&#34;&gt;dep/%.d: %.cpp&lt;/h5&gt;

&lt;p&gt;使所有的.d文件依赖于对应的.cpp文件，也就是说只要.cpp更新了，我们就重新生成对应的.d文件。这里和.o文件类似的，我们也创建一个dep目录用来存放所有的.d文件，既能保持项目文件的整洁和统一，也方便管理。&lt;/p&gt;

&lt;h5 id=&#34;if-test-d-dep-then&#34;&gt;@if test ! -d &amp;ldquo;dep&amp;rdquo;; then&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;@if test ! -d &amp;quot;dep&amp;quot;; then\
    mkdir -p dep;\
fi; \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查当前目录下是否存在dep目录，如果不存在，就使用mkdir命令创建dep目录。&lt;/p&gt;

&lt;h5 id=&#34;set-e-rm-f&#34;&gt;set -e; rm -f $@;&lt;/h5&gt;

&lt;p&gt;set–e 的作用是如果命令执行出错就直接退出。$@的含义之前已经说过，这里rm –f $@的意思就是删除所有的目标文件。&lt;/p&gt;

&lt;h5 id=&#34;g-mm&#34;&gt;g++ -MM $&amp;lt; &amp;gt; $@.$$$$; &lt;/h5&gt;

&lt;p&gt;$&amp;lt; 的含义是第一个依赖项的名称，&amp;gt; 是重定向符号，将输出结果重定向到指定文件中。$@.$$$$ 就是这个文件的文件名，其中“$$$$”表示一个随机的编号，例如如果有目标文件是w1.d，那么“$@.$$$$”一个可能的结果就是w1.d.12345。那么，这句话的含义就是将g++ -MM w1.cpp的输出结果重定向到w1.d.12345这个文件中。&lt;/p&gt;

&lt;h5 id=&#34;sed-s-o-obj-o-dep-d-g&#34;&gt;sed &amp;rsquo;s/$&lt;em&gt;.o[ :]&lt;/em&gt;/obj\/$&lt;em&gt;.o dep\/$&lt;/em&gt;.d : /g&amp;rsquo; &amp;lt; $@.$$$$ &amp;gt; $@;&lt;/h5&gt;

&lt;p&gt;这里使用了sed这个工具对文本进行替换处理，单引号中的规则是’s/old/new/g’，s表示替换，末尾的g代表全局的意思，对文本中所有符合要求的字符串进行替换，sed会将符合old模式的字符串替换为new，具体的使用方法可以查阅一下sed这个工具的帮助文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;$@$$$$，将这个文件的内容作为sed工具的输入。

&amp;gt;$@，将sed处理后的内容重定向输出到这个文件中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过这一步的处理后，就把自动生成的依赖关系：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;w1.o:w1.cpp w2.h w3.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;w1.o w1.d:w1.cpp w2.h w3.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，我们的.d文件也会自动更新啦。&lt;/p&gt;

&lt;h5 id=&#34;rm-f&#34;&gt;rm -f $@.$$$$&lt;/h5&gt;

&lt;p&gt;删除掉这个临时文件。&lt;/p&gt;

&lt;h4 id=&#34;使用include包含其他文件&#34;&gt;使用include包含其他文件&lt;/h4&gt;

&lt;p&gt;在Makefile中我们也可以像在C++文件中那样包含其他文件。&lt;/p&gt;

&lt;p&gt;现在在我们的Makefile中加上这样一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include w1.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这个语句就可以将之前我们生成的.d文件中的内容包含到当前的Makefile中。&lt;/p&gt;

&lt;p&gt;当然，也可以用这个命令来包含其他的Makefile文件。具体的用法后面再进行介绍。&lt;/p&gt;

&lt;p&gt;我们希望把所有的.d文件都包含在当前的Makefile中。&lt;/p&gt;

&lt;p&gt;先定义一个变量，存放所有的.d文件名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEPS = $(addsuffix .d,$(addprefix dep/,$(BASE)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用include$(DEPS) 包含所有的.d文件。&lt;/p&gt;

&lt;h3 id=&#34;i-引用其他目录下的-h文件&#34;&gt;-I，引用其他目录下的.h文件&lt;/h3&gt;

&lt;p&gt;考虑这种情况：现在有两个目录，一个inc目录用来存放.h文件，一个src目录，用来存放.cpp文件。怎么让编译器找到引用的.h文件在哪个目录下呢？&lt;/p&gt;

&lt;p&gt;我们可以使用“-I”选项。  格式为“-I目录名”，这样在编译的时候，编译器就会依次到我们指定的目录中寻找.h文件。&lt;/p&gt;

&lt;p&gt;同样，先定义一个变量，存放所有头文件的目录名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INCLUDEDIR = -I../inc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -c -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的编译命令中写成&lt;/p&gt;

&lt;p&gt;g++ -c -o $@ $(INCLUDEDIR) $&amp;lt;&lt;/p&gt;

&lt;p&gt;OK，再来尝试用gmake命令编译一下吧，已经可以成功编译了。&lt;/p&gt;

&lt;p&gt;如果需要包含多个目录下的.h文件，可以重复使用-I选项，中间需要用空格隔开。&lt;/p&gt;

&lt;h3 id=&#34;使用静态库&#34;&gt;使用静态库&lt;/h3&gt;

&lt;h4 id=&#34;修改生成静态库的makefile&#34;&gt;修改生成静态库的Makefile&lt;/h4&gt;

&lt;p&gt;有的时候我们不需要生成一个可执行的程序，而是生成一个静态库文件，之后在其他的地方引用这个静态库文件。&lt;/p&gt;

&lt;p&gt;假设我们的项目目录结构是这样的，src是项目根目录，src下面有common和app以及lib两个目录，common和app下面都有inc和src两个目录。common存放公共库的源文件，app存放程序源文件，lib存放生成的静态库。&lt;/p&gt;

&lt;p&gt;修改我们在common目录下的Makefile文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;top_srcdir = ../..
#生成静态库后所存放的位置
libdir = $(top_srcdir)/lib
#静态库文件名
LIBNAME = libfa_common.a
#路径+静态库文件名
TARGET = $(libdir)/$(LIBNAME)

$(TARGET): $(OBJS)
    -rm -f $@
    ar cr $(TARGET) $(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;top_srcdir是项目根目录的路径，使用相对路径，方便我们在后面引用其他目录。&lt;/li&gt;
&lt;li&gt;libdir是生成的静态库所存放的路径。&lt;/li&gt;
&lt;li&gt;LIBNAME是静态库名称，注意，静态库的命名必须以“lib”开头，以“.a”结尾。&lt;/li&gt;
&lt;li&gt;TARGET是目标文件名称，包含路径。&lt;/li&gt;
&lt;li&gt;在生成静态库文件的规则中，使用ar这个命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;修改引用静态库的makefile&#34;&gt;修改引用静态库的Makefile&lt;/h4&gt;

&lt;p&gt;在app/src目录下的源文件中，编译的时候需要引用libfa_common.a这个静态库，这就需要我们再修改app目录下的Makefile文件。&lt;/p&gt;

&lt;p&gt;这里使用了两个新的参数，“-l”和“-L”。&lt;/p&gt;

&lt;p&gt;“-l”参数指定要引用的库的名称。例如我们要引用libfa_common.a这个静态库，那么需要在编译命令里加上“-lfa_common”，可以看出，-l后面的库名称需要去除前面的“lib”和后面的“.a”。&lt;/p&gt;

&lt;p&gt;“-L”参数指定了要引用的库的目录，用法和之前的“-I”一样。这里需要注意的是，我们需要修改一下VPATH这个变量，指明要引用的静态库的目录。类似这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VPATH:= -L $(top_srcdir)/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;完整的makefile&#34;&gt;完整的Makefile&lt;/h3&gt;

&lt;p&gt;其实在每一个目录下的Makefile中有很多部分是重复的，我们可以考虑将重复的部分提取出来，单独放在一个公共的Makefile中，然后在其他Makefile中用include包含这个公共的Makefile即可。&lt;/p&gt;

&lt;p&gt;我写了三套Makefile，分别是Makefile（app）、Makefile（lib）、Make.rules。&lt;/p&gt;

&lt;p&gt;其中，Make.rules是公共部分，Makefile（app）是用来生成可执行程序的，Makefile（lib）是用来生成静态库的，为了以后迁移方便，考虑到Linux和Unix平台的差异，以及各个编译器之间的差异，可以将各种命令也定义成变量，之后使用宏定义进行条件编译。&lt;/p&gt;

&lt;p&gt;贴一下完整的Makefile代码。&lt;/p&gt;

&lt;h4 id=&#34;make-rules&#34;&gt;Make.rules&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#公用Make规则配置

#设置编译器类型
CXX := g++
CC := gcc

#设置编译.d文件相关内容
DEPFLAGS := -MM
DEPFILE = $@.$$$$

#设置所有静态库文件所在位置，会根据每个Makefile文件的top_srcdir设置相对位置
LIBDIR := $(top_srcdir)/lib

#设置编译程序时需要在哪些目录查找静态库文件
LDFLAGS := -L.\
           -L$(top_srcdir)/lib

#设置VPATH，在检查依赖关系时，如果查找-lxxxx时，在哪些目录查找静态库文件
VPATH := $(LIBDIR)

#设置编译程序时查找头文件的目录位置
INCLUDEDIR := -I.\
              -I../inc\

#声明要生成的目标文件，具体规则在具体的Makefile中定义
$(TARGET):

#生成.o文件所依赖的.cpp和.c文件
obj/%.o:%.cpp
@if test ! -d &amp;quot;obj&amp;quot;; then\
    mkdir-p obj;\
fi;
$(CXX)-c -o $@ $(INCLUDEDIR) $&amp;lt;

obj/%.o:%.c
    @iftest ! -d &amp;quot;obj&amp;quot;; then\
            mkdir-p obj;\
    fi;
    $(CC)-c -o $@ $(INCLUDEDIR) $&amp;lt;

#生成.d文件,存放.cpp文件的所有依赖规则
dep/%.d: %.cpp
    @iftest ! -d &amp;quot;dep&amp;quot;; then\
            mkdir-p dep;\
    fi;\
    set-e; rm -f $@;
    $(CXX)$(DEPFLAGS) $(INCLUDEDIR) $&amp;lt; &amp;gt;$(DEPFILE); \
    sed&#39;s/$*\.o[ :]*/obj\/$*\.o dep\/$*\.d : /g&#39; &amp;lt; $@.$$$$ &amp;gt; $@;\
    rm-f $@.$$$$

#生成.d文件,存放.c文件的所有依赖规则
dep/%.d: %.c
    @iftest ! -d &amp;quot;dep&amp;quot;; then\
            mkdir-p dep;\
    fi;\
    set-e; rm -f $@;
    $(CC)$(DEPFLAGS) $(INCLUDEDIR) $&amp;lt; &amp;gt; $(DEPFILE); \
    sed&#39;s/$*\.o[ :]*/obj\/$*\.o dep\/$*\.d : /g&#39; &amp;lt; $@.$$$$ &amp;gt; $@; \
    rm-f $@.$$$$

include $(DEPS)

#检测是否有文件被修改，只要有就全部编译
all: $(SRCS) $(TARGETS)

#清除编译文件
.PHONY:clean
clean:
    -rm-f $(TARGET)
    -rm-f obj/*.o
    -rm-f dep/*.d
    -rm-f core
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;makefile-lib&#34;&gt;Makefile（lib）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#需要生成静态库的Makefile

#程序根目录
top_srcdir         =../../..

#生成静态库后所存放的位置
libdir = $(top_srcdir)/lib
#静态库文件名
LIBNAME          =libfa_common.a
#路径+静态库文件名
TARGET           =$(libdir)/$(LIBNAME)

CPP_FILES = $(shell ls *.cpp)
C_FILES = $(-shell ls *.c)
SRCS = $(CPP_FILES) $(C_FILES)
BASE = $(basename $(SRCS))
OBJS = $(addsuffix .o, $(addprefixobj/,$(BASE)))
DEPS = $(addsuffix .d, $(addprefixdep/,$(BASE)))

#包含公共Make规则
include$(top_srcdir)/makeinclude/Make.rules

#设置头文件及库文件的位置
INCLUDEDIR := $(INCLUDEDIR)

$(TARGET): $(OBJS)
    -rm-f $@
    ar cr $(TARGET) $(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;makefile-app&#34;&gt;Makefile（app）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#需要生成可执行程序的Makefile

#程序根目录
top_srcdir         =../../..

#目标程序名
TARGET = test

CPP_FILES = $(shell ls *.cpp)
C_FILES = $(-shell ls *.c)
SRCS = $(CPP_FILES) $(C_FILES)
BASE = $(basename $(SRCS))
OBJS = $(addsuffix .o, $(addprefixobj/,$(BASE)))
DEPS = $(addsuffix .d, $(addprefixdep/,$(BASE)))

#包含公共Make规则
include $(top_srcdir)/makeinclude/Make.rules

#额外需要包含的头文件的目录位置
INCLUDEDIR := $(INCLUDEDIR)\
              -I$(top_srcdir)/src/common/inc\

#所有要包含的静态库的名称
LIBS := -lfa_common

#设置目标程序依赖的.o文件
$(TARGET):$(OBJS) $(LIBS)
    -rm-f $@
    $(CXX)-o $(TARGET) $(INCLUDEDIR) $(LDFLAGS) $(OBJS) $(LIBS)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>从简单实例开始，学会写Makefile（一）</title>
          <link>http://blog.fatedier.com/2014/09/08/learn-to-write-makefile-01</link>
          <pubDate>Mon, 08 Sep 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/09/08/learn-to-write-makefile-01</guid>
          <description>

&lt;p&gt;作为一个刚刚从大学毕业的新人，进公司不久就遇到了一个不大不小的门槛——看不懂Makefile！而Makefile所干的事却关系到程序的编译和链接，一个好的Makefile文件可以极大地提升编译项目文件的效率，免去手动编译的烦恼。&lt;/p&gt;

&lt;p&gt;不会写Makefile虽然还不至于影响到项目进度，从别的地方拷贝一份过来稍加修改就可以用了，但是，对于咱们“程序猿”来说这实在是一件让人感觉很不爽的事。于是，百度，谷歌（PS：吐槽一下，不XX的话Google已经完全不能用了，Bing的效果都要比百度好一些），各种看资料，看大牛的博客，或许是本人比较笨，也或许是网上的资料不太适合咱们这种新人，缺乏生动的实例讲解，所以决定自己动手研究一下，并把过程分享给大家，希望新人们看完这篇文章后就能够自己动手，为自己的项目编写合适的Makefile啦。&lt;/p&gt;

&lt;h3 id=&#34;为什么要写makefile&#34;&gt;为什么要写Makefile&lt;/h3&gt;

&lt;p&gt;首先要确定我们的目标，Makefile是用来干嘛的？&lt;/p&gt;

&lt;p&gt;曾经很长时间我都是在从事Windows环境下的开发，所以根本不知道Makefile是个什么东西。因为早已经习惯了使用VS、Eclipse等等优秀的IDE做开发，只要点一个按钮，程序就可以运行啦。但是进入公司以后，从事的是Unix环境下的开发工作，没有了IDE，要怎么才能让我写的代码编译后运行呢？&lt;/p&gt;

&lt;p&gt;在这里，Makefile的作用就体现出来了，简单的四个字—— “自动编译”。一旦整个项目的Makefile都写好了以后，只需要一个简单的make命令，就可以实现自动编译了。当然，准确的说，是make这个命令工具帮助我们实现了我们想要做的事，而Makefile就相当于是一个规则文件，make程序会按照Makefile所指定的规则，去判断哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。&lt;/p&gt;

&lt;p&gt;俗话说，懒人创造了整个世界，程序员就是在不断偷懒的过程中获得进步，使用Makefile最根本的目的就是简化我们的工作。&lt;/p&gt;

&lt;p&gt;下面我们就从头开始，一步一步的去学习如何写好一个Makefile文件吧！&lt;/p&gt;

&lt;h3 id=&#34;从单个文件开始&#34;&gt;从单个文件开始&lt;/h3&gt;

&lt;h4 id=&#34;1-单个文件的编译&#34;&gt;1、单个文件的编译&lt;/h4&gt;

&lt;p&gt;为了便于大家学习，这篇文章是以常见的Linux平台为基础的，系统为Centos6.5，使用GNU make工具进行编译，项目文件为C++格式。这里假定看到这篇文章的都是已经对C++程序的编译等基础知识和相关命令有了一定的了解的，鉴于篇幅限制，如果还有不清楚的就请自行查阅相关资料啦。&lt;/p&gt;

&lt;p&gt;假设我们在src目录下有一个test.cpp文件，我们是如何编译它的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -o test test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在shell界面执行这句命令，当前目录下会生成一个名为test的可执行程序，使用./test就可以执行该程序，看到输出结果。&lt;/p&gt;

&lt;p&gt;现在我们尝试使用编写Makefile的方式来实现这一编译过程。 首先在当前目录下新建文件并命名为“Makefile”，这样编译的时候直接使用gmake命令即可，默认使用“Makefile”文件进行编译，也可以是其他名字，那样的话需要使用“gmake -f 文件名”的格式来指定Makefile文件。&lt;/p&gt;

&lt;p&gt;Makefile文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test:test.cpp
    g++-o test test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在shell界面下执行gmake命令，敲下回车，OK。&lt;/p&gt;

&lt;p&gt;可以发现，g++ -o test test.cpp 这条命令已经被自动执行了，生成了名为test的程序。&lt;/p&gt;

&lt;h4 id=&#34;2-makefile的描述规则&#34;&gt;2、Makefile的描述规则&lt;/h4&gt;

&lt;p&gt;至此，我们已经完成了一个最简单的Makefile文件，向我们的最终目标迈出了一大步！&lt;/p&gt;

&lt;p&gt;有的人会问，传说中的自动化编译呢？难道每一个文件都要自己去写文件名和命令？&lt;/p&gt;

&lt;p&gt;不用急，我们先来分析一下这个Makefile文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;TARGET... :PREREQUISITES...
    COMMAND
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是最简单的Makefile文件的描述规则，可以说，这也是Makefile中最精华的部分，其他部分都是围绕着这个最基本的描述规则的。先来解释一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TARGET：规则生成的目标文件，通常是需要生成的程序名（例如前面出现的程序名test）或者过程文件（类似.o文件）。&lt;/li&gt;
&lt;li&gt;PREREQUISITES：规则的依赖项，比如前面的Makefile文件中我们生成test程序所依赖的就是test.cpp。&lt;/li&gt;
&lt;li&gt;COMMAND：规则所需执行的命令行，通常是编译命令。这里需要注意的是每一行命令都需要以[TAB]字符开头。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再来看我们之前写过的Makefile文件，这个规则，用通俗的自然语言翻译过来就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果目标test文件不存在，根据规则创建它。&lt;/li&gt;
&lt;li&gt;目标test文件存在，并且test文件的依赖项中存在任何一个比目标文件更新（比如修改了一个函数，文件被更新了），根据规则重新生成它。&lt;/li&gt;
&lt;li&gt;目标test文件存在，并且它比所有的依赖项都更新，那么什么都不做。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们第一次执行gmake命令时，test文件还不存在，所以就会执行g++-o test test.cpp这条命令创建test文件。&lt;/p&gt;

&lt;p&gt;而当我们再一次执行gmake时，会提示文件已经是最新的，什么都不做。&lt;/p&gt;

&lt;p&gt;这时候，如果修改了test.cpp命令，再次执行gmake命令。&lt;/p&gt;

&lt;p&gt;由于依赖项比目标文件更新，g++ -o test test.cpp这条命令就又会被再一次执行。&lt;/p&gt;

&lt;p&gt;现在，我们已经学会如何写一个简单的Makefile文件了，每次修改过源文件以后，只要执行gmake命令就可以得到我们想要生成的程序，而不需要一遍遍地重复敲g++ -o test test.cpp这个命令。&lt;/p&gt;

&lt;h3 id=&#34;多个文件的编译&#34;&gt;多个文件的编译&lt;/h3&gt;

&lt;h4 id=&#34;1-使用命令行编译多个文件&#34;&gt;1、使用命令行编译多个文件&lt;/h4&gt;

&lt;p&gt;一个项目不可能只有一个文件，学会了单个文件的编译，自然而然就要考虑如何去编译多个文件呢？&lt;/p&gt;

&lt;p&gt;同样，假设当前目录下有如下7个文件，test.cpp、w1.h、w1.cpp、w2.h、w2.cpp、w3.h、w3.cpp。其中test.cpp包含main函数，并且引用了w1.h、w2.h以及w3.h。我们需要生成的程序名为test。&lt;/p&gt;

&lt;p&gt;在shell界面下，为了正确编译我们的项目，我们需要敲下如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -c -o w1.ow1.cpp
g++ -c -o w2.o w2.cpp
g++ -c -o w3.o w3.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时当前目录下会生成w1.o、w2.o、w3.o三个.o文件。这里需要注意的是，“-c”命令是只编译，不链接，通常生成.o文件的时候使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -o testtest.cpp w1.o w2.o w3.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完这条命令后，编译成功，得到了我们想要的test文件。&lt;/p&gt;

&lt;h4 id=&#34;2-使用makefile编译多个文件&#34;&gt;2、使用Makefile编译多个文件&lt;/h4&gt;

&lt;p&gt;既然单个文件的Makefile会写了，相信多个文件举一反三也不是问题了。&lt;/p&gt;

&lt;p&gt;Makefile具体内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test:test.cppw1.o w2.o w3.o
    g++ -o test test.cpp w1.o w2.o w3.o
w1.o:w1.cpp
    g++ -c -o w1.o w1.cpp
w2.o:w2.cpp
    g++ -c -o w2.o w2.cpp
w3.o:w3.cpp
    g++ -c -o w3.o w3.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的是，我们写的第一个规则的目标，将会成为“终极目标”，也就是我们最终希望生成的程序，这里是“test”文件。根据我们的“终极目标”，make会进行自动推导，例如“终极目标”依赖于的.o文件，make就会寻找生成这些.o文件的规则，然后执行相应的命令去生成这些文件，这样一层一层递归地进行下去，直到最终生成了“终极目标”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2014/2014-09-08-learn-to-write-makefile-01-gmake-target.jpg&#34; alt=&#34;gmake-target&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，虽然生成test文件的规则写在最前面，但是由于依赖于w1.o、w2.o、w3.o，make会先执行生成w1.o、w2.o、w3.o所需的命令，然后才会执行g++ -o test test.cpp w1.o w2.o w3.o 来生成test文件。&lt;/p&gt;

&lt;h4 id=&#34;3-使用伪目标来清除过程文件&#34;&gt;3、使用伪目标来清除过程文件&lt;/h4&gt;

&lt;p&gt;我们现在已经可以自动编译多个文件的项目了，但是当我们需要全部重新编译的时候，难道还要手动地一个一个去删除那些生成的.o文件吗？&lt;/p&gt;

&lt;p&gt;既然已经使用了Makefile，我们的目标就是实现自动化编译，那么这些清除过程文件这点小事必须得能够用一个命令搞定啦。&lt;/p&gt;

&lt;p&gt;我们只需要在Makefile文件的最后加上如下几行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clean:
    -rm–f test *.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，轻松搞定，然后在shell界面下执行gmakeclean。仔细看看，是不是所有的.o文件和最后生成的程序文件已经被清除了？&lt;/p&gt;

&lt;p&gt;这里说明一下，rm是Linux下删除文件或目录的命令，前面加上“-”符号意思是忽略执行rm产生的错误。“-f”参数是指强制删除，忽略不存在的文件。&lt;/p&gt;

&lt;p&gt;这样的目标叫做“伪目标”，通过“gmake 目标名”来指定这个目标，然后执行这个目标规则下的命令。&lt;/p&gt;

&lt;h3 id=&#34;使用变量简化makefile&#34;&gt;使用变量简化Makefile&lt;/h3&gt;

&lt;p&gt;作为一个“懒惰”的程序员，现在问题又来了。如果按照上面的写法，在文件数量和名称不变的情况的下确实是没有问题，但是如果我们新增一个文件的话，岂不是又要去修改Makefile了，一个项目多的可能有成百上千的文件，这样管理起来得有多麻烦呀！&lt;/p&gt;

&lt;p&gt;还记得我们在Linux下如果要查看当前目录下所有的cpp文件的时候，使用的命令吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls *.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个命令，我们就可以将所有的cpp文件名称显示在界面上。而在Makefile中我们同样可以使用类似的规则来做简化，进一步减少后续开发过程中对Makefile文件的修改。&lt;/p&gt;

&lt;p&gt;修改后的Makefile文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;TARGET = test

CPP_FILES = $(shell ls *.cpp)
BASE = $(basename $(CPP_FILES))
OBJS = $(addsuffix .o, $(addprefix obj/,$(BASE)))
 
$(TARGET):$(OBJS)
    -rm -f $@
    g++ -o $(TARGET)$(OBJS)
 
obj/%.o:%.cpp
    @if test ! -d&amp;quot;obj&amp;quot;; then\
    mkdir -pobj;\
    fi;
    g++ -c -o $@ $&amp;lt;
 
clean:
    -rm -f test
    -rm -f obj/*.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是瞬间有种摸不着头脑的感觉？别急，这是因为我们用到了一些新的语法和命令，其实，本质上和我们之前所写的Makefile文件是一个意思，下面我们就逐条来进行分析。&lt;/p&gt;

&lt;h5 id=&#34;target-test&#34;&gt;TARGET = test&lt;/h5&gt;

&lt;p&gt;定义一个变量，保存目标文件名，这里我们需要生成的程序名就叫test。&lt;/p&gt;

&lt;h5 id=&#34;cpp-files-shell-ls-cpp&#34;&gt;CPP_FILES = $(shell ls *.cpp)&lt;/h5&gt;

&lt;p&gt;定义一个变量，内容为所有的以.cpp为后缀的文件的文件名，以空格隔开。&lt;/p&gt;

&lt;p&gt;这里&amp;amp;(shell 命令)的格式，说明这里将会用shell命令执行后输出的内容进行替换，就和在命令行下输入ls *.cpp得到的结果一样。&lt;/p&gt;

&lt;h5 id=&#34;base-basename-cpp-files&#34;&gt;BASE = $(basename $(CPP_FILES))&lt;/h5&gt;

&lt;p&gt;定义一个变量，内容为所有的以.cpp为后缀的文件的文件名去除掉后缀部分。&lt;/p&gt;

&lt;p&gt;$(CPP_FILES)是引用CPP_FIFES这个变量的内容，相信学过如何写shell命令的同学肯定不会陌生。basename 是一个函数，其作用就是去除掉文件名的后缀部分，例如“test.cpp”，经过这一步后就变成了“test”。&lt;/p&gt;

&lt;h5 id=&#34;objs-addsuffix-o-addprefix-obj-base&#34;&gt;OBJS = $(addsuffix .o, $(addprefix obj/,$(BASE)))&lt;/h5&gt;

&lt;p&gt;定义一个变量，内容为所有的以.cpp为后缀的文件去除调后缀部分后加上“.o”。&lt;/p&gt;

&lt;p&gt;和basename一样，addsuffix和addprefix同样也是调用函数。addprefix的作用是给每个文件名加上前缀，这里是加上“obj/”，而addsuffix的作用是给每个文件名加上后缀，这里是在文件名后加上“.o”。例如“test”，经过变换后变成了“obj/test.o”。&lt;/p&gt;

&lt;p&gt;为什么要在文件名前加上“obj/”？&lt;/p&gt;

&lt;p&gt;这个不是必须的，只是我自己觉得将所有的.o文件放在一个obj目录下统一管理会让目录结构显得更加清晰，包括以后的.d文件会统一放在dep目录下一样。当然，你也可以选择不这样做，而是全部放在当前目录下。&lt;/p&gt;

&lt;h5 id=&#34;target-objs&#34;&gt;$(TARGET):$(OBJS)&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$(TARGET):$(OBJS)
    -rm -f $@
    g++ -o $(TARGET) $(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个描述规则和我们之前写过的很像，只不过，使用了变量进行替换。其中需要注意的是$@这个奇怪的符号，它的含义是这个规则的目标文件的名称，在这里就相当于是$(TARGET)。&lt;/p&gt;

&lt;p&gt;把这里的变量替换成我们之前项目中的实际值，就相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test:test.ow1.o w2.o w3.o
    -rm-f test
    g++ -o test test.o w1.o w2.o w3.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果按照这种写法，当我们新增了一个w4.cpp文件的时候，就需要对Makefile进行修改，而如果我们使用了变量进行替换，那么我们就什么都不用做，直接再执行一遍gmake命令即可。&lt;/p&gt;

&lt;h5 id=&#34;obj-o-cpp&#34;&gt;obj/%.o:%.cpp&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;obj/%.o:%.cpp
    @if test ! -d&amp;quot;obj&amp;quot;; then\
        mkdir -p obj;\
    fi;
    g++ -c -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是依次生成所有cpp文件所对应的.o文件的规则。&lt;/p&gt;

&lt;p&gt;%.o和%.c表示以.o和.c结尾的文件名。因为我们准备把所有的.o文件放在obj目录下，所以这里在“%.o”前面加上前缀“obj/”。&lt;/p&gt;

&lt;p&gt;下面命令行的前三行，具体的作用是检查当前目录下是否有名为“obj”的目录，如果没有，则使用mkdir命令创建这个目录。如果不了解的同学不如先去看一下shell编程的相关知识吧。&lt;/p&gt;

&lt;p&gt;最后一句中的$@前面已经解释过了，是代表规则的目标文件名称，而$&amp;lt;与之对应的，则是代表规则的依赖项中第一个依赖文件的名称。&lt;/p&gt;

&lt;p&gt;例如obj/test.o:test.cpp&lt;/p&gt;

&lt;p&gt;那么$@的值为“test.o”，$&amp;lt;的值为“test.cpp”&lt;/p&gt;

&lt;h5 id=&#34;clean&#34;&gt;clean:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clean:
    -rm -f test
    -rm -f obj/*.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就没什么好说的啦，这里只是修改了一下.o文件的路径。&lt;/p&gt;

&lt;p&gt;到这里，相信你对如何使用Makefile来编译一个小的项目已经颇有些眉目了吧。使用这个Makefile文件，不管你往这个目录下加多少文件，轻轻松松一个gmake命令搞定，不需要再因为加了一个新的文件而去修改Makefile了。&lt;/p&gt;

&lt;p&gt;但是，你难道没有觉得仍然存在着很多问题吗？&lt;/p&gt;

&lt;p&gt;如果文件间存在着相互之间的引用关系该怎么办？&lt;/p&gt;

&lt;p&gt;如果把.h文件和.cpp文件放在了不同的目录下该怎么办？&lt;/p&gt;

&lt;p&gt;如果我想生成静态库，然后在其他地方引用静态库该怎么办？&lt;/p&gt;

&lt;p&gt;如果我想将程序迁移到Unix平台下，使用不同的编译器，难道要依次修改所有的Makefile？&lt;/p&gt;

&lt;p&gt;大家可以先尝试着自己解决以上的问题，在之后的篇幅中我们会就以上几点继续通过举例的方式来加以解决。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
