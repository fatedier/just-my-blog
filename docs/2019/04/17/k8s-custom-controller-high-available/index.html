<!DOCTYPE html>

<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="fatedier">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="自定义 controller 通常要求只能有一个实例在工作，但是为了保证高可用，就需要有一个选主的机制，保证在 leader 因为某个异常挂掉后，其他节点可以提升为 leader，然后正常工作。">
<meta property="og:url" content="http://blog.fatedier.com/"><meta property="og:type" content="article">
<meta property="og:title" content="kubernetes 自定义控制器的高可用 - fatedier blog"><meta property="og:site_name" content="fatedier blog">

<title>
    
    kubernetes 自定义控制器的高可用
    
</title>

<link rel="stylesheet" href="/onlyone/onlyone.css">
<link rel="shortcut icon" href="/assets/favicon.ico">
<script src="/onlyone/onlyone.js"></script>
<link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">
</head>
<body>


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">fatedier blog</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/categories/技术文章/">技术文章</a></li>
                        <li><a href="/categories/诗与远方/">诗与远方</a></li>
                        <li><a href="/tags/">分类</a></li>
                        <li><a href="/about/">关于我</a></li>
                        <li>
                            <form method="get" style="padding: 8px" action="https://www.google.com/search" target="_blank">
                                <input type="hidden" name="sitesearch" value="blog.fatedier.com"/>
                                <input type="text" class="form-control" name="q" placeholder="Press enter to search">
                            </form>
                        </li>
                    </ul>

                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post single">

            <header>
                <div class="post-date">
                    2019年04月17日 
                </div>
                <h1 class="post-title">kubernetes 自定义控制器的高可用</h1>
            </header>

            <div class="post-content">
                <p>自定义 controller 通常要求只能有一个实例在工作，但是为了保证高可用，就需要有一个选主的机制，保证在 leader 因为某个异常挂掉后，其他节点可以提升为 leader，然后正常工作。</p>

<p>我们可以像 kube-controller-manager 一样，借助 client-go 的 leaderelection package 来实现高可用。</p>

<h3 id="代码实现">代码实现</h3>

<p>client-go 中对选主的操作已经进行了封装，所以使用起来比较简单。</p>

<p>下面是一段简单的使用示例，编译完成后同时启动多个进程，只有一个进程会处于工作状态，当把处于工作状态的进程 kill 掉后，剩余的进程中的一个会变为 leader，开始工作。</p>

<pre><code class="language-golang">package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
    &quot;time&quot;

    &quot;github.com/google/uuid&quot;
    &quot;k8s.io/client-go/kubernetes&quot;
    &quot;k8s.io/client-go/rest&quot;
    &quot;k8s.io/client-go/tools/leaderelection&quot;
    &quot;k8s.io/client-go/tools/leaderelection/resourcelock&quot;
)

var enableLeaderElect bool

func main() {
    run := func(ctx context.Context) {
        // controller handler here
        for {
            log.Println(&quot;I'm working...&quot;)
            time.Sleep(5*time.Second)
        }
    }

    kubecli, err := newKubeClient()
    if err != nil {
        log.Fatalf(&quot;new kube client error: %v&quot;, err)
    }

    if enableLeaderElect {
        log.Println(&quot;run with leader-elect&quot;)

        id, err := os.Hostname()
        if err != nil {
            log.Fatalf(&quot;get hostname error: %v&quot;, err)
        }

        id = id + &quot;_&quot; + uuid.New().String()
        rl, err := resourcelock.New(&quot;endpoints&quot;, // support endpoints and configmaps
            &quot;default&quot;,
            &quot;test-controller&quot;,
            kubecli.CoreV1(),
            kubecli.CoordinationV1(),
            resourcelock.ResourceLockConfig{
                Identity: id,
            })
        if err != nil {
            log.Fatalf(&quot;create ResourceLock error: %v&quot;, err)
        }
        leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig{
            Lock:          rl,
            LeaseDuration: 15 * time.Second,
            RenewDeadline: 10 * time.Second,
            RetryPeriod:   2 * time.Second,
            Callbacks: leaderelection.LeaderCallbacks{
                OnStartedLeading: func(ctx context.Context) {
                    log.Println(&quot;you are the leader&quot;)
                    run(ctx)
                },
                OnStoppedLeading: func() {
                    log.Fatalf(&quot;leaderelection lost&quot;)
                },
            },
            Name: &quot;test-controller&quot;,
        })
    } else {
        log.Println(&quot;run without leader-elect&quot;)
        run(context.TODO())
    }
}

func newKubeClient() (kubernetes.Interface, error) {
    config, err := rest.InClusterConfig()
    if err != nil {
        return nil, fmt.Errorf(&quot;failed to create in-cluster kube cli configuration: %v&quot;, err)
    }

    cli, err := kubernetes.NewForConfig(config)
    if err != nil {
        return nil, fmt.Errorf(&quot;failed to create kube client: %v&quot;, err)
    }
    return cli, nil
}
</code></pre>

<p>注意我们这里如果失去 leader 后，会直接调用 <code>log.Fatalf</code> 退出进程。在 kubernetes 环境中通常采用 Deployment 等方式来部署，程序退出后，会重新启动一个 Pod 替代。</p>

<h3 id="原理分析">原理分析</h3>

<p>leaderelection 的代码实现并不复杂。</p>

<p>主要的工作原理是，通过 kubernetes 的 endpoints 或 configmaps 实现一个分布式锁，抢到锁的节点成为 leader，并定期更新，而抢不到的节点会一直等待。当 leader 因为某些异常原因挂掉后，租约到期，其他节点会尝试抢锁，成为新的 leader。</p>

<pre><code class="language-golang">rl, err := resourcelock.New(&quot;endpoints&quot;, // 实现锁的资源类型，支持 endpoints 或 configmaps
    &quot;default&quot;, // 创建资源的 namespace
    &quot;test-controller&quot;, // 锁的资源名称，这里会在 default namespace 下创建一个名为 test-controller 的 endpoint
    kubecli.CoreV1(),
    kubecli.CoordinationV1(),
    resourcelock.ResourceLockConfig{
        Identity: id, // 锁持有者的标志
    })
</code></pre>

<p>上面的代码可以看出 leaderelection 其实是利用 kubernetes 的 resource 来实现分布式锁。在对应 resource 的 annotations 中会更新 <code>control-plane.alpha.kubernetes.io/leader</code> 这个字段的值，更新成功的就是 leader。其中的内容是下面这个结构体的序列化结果:</p>

<pre><code class="language-golang">type LeaderElectionRecord struct {
    // Holder 的 ID，如果为空，表示没有 Holder
    HolderIdentity       string      `json:&quot;holderIdentity&quot;`
    // 租约期限
    LeaseDurationSeconds int         `json:&quot;leaseDurationSeconds&quot;`
    // 获取租约的时间
    AcquireTime          metav1.Time `json:&quot;acquireTime&quot;`
    // 更新租约的时间
    RenewTime            metav1.Time `json:&quot;renewTime&quot;`
    LeaderTransitions    int         `json:&quot;leaderTransitions&quot;`
}
</code></pre>

<p><code>leaderelection.RunOrDie</code> 函数会调用创建好的 LeaderElector 的 Run 函数。</p>

<pre><code class="language-golang">func (le *LeaderElector) Run(ctx context.Context) {
    defer func() {
        runtime.HandleCrash()
        le.config.Callbacks.OnStoppedLeading()
    }()
    if !le.acquire(ctx) {
        return // ctx signalled done
    }
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()
    go le.config.Callbacks.OnStartedLeading(ctx)
    le.renew(ctx)
}
</code></pre>

<p>通过 Run 函数看到在 <code>acquire</code> 成功后，会调用用户提供的 <code>le.config.Callbacks.OnStartedLeading</code> 函数。之后持续 <code>renew</code>。<code>acquire</code> 会阻塞，除非成功，或 context 被 cancel。</p>

<p><code>le.acquire</code> 和 <code>le.renew</code> 内部都是调用了 <code>le.tryAcquireOrRenew</code> 函数，只是对于返回结果的处理不一样。</p>

<p><code>le.acquire</code> 对于 <code>le.tryAcquireOrRenew</code> 返回成功则退出，失败则继续。</p>

<p><code>le.renew</code> 则相反，成功则继续，失败则退出。</p>

<pre><code class="language-golang">func (le *LeaderElector) tryAcquireOrRenew() bool {
    now := metav1.Now()
    // 这个结构体就是 endpoint 或 configmap 中 annotations `control-plane.alpha.kubernetes.io/leader` 的值
    leaderElectionRecord := rl.LeaderElectionRecord{
        HolderIdentity:       le.config.Lock.Identity(),
        LeaseDurationSeconds: int(le.config.LeaseDuration / time.Second),
        RenewTime:            now,
        AcquireTime:          now,
    }

    // 1. 获取或创建对应的 endpoint 或 configmap
    oldLeaderElectionRecord, err := le.config.Lock.Get()
    if err != nil {
        // 其他错误，返回 false，如果是不存在的错误，创建一个新的
        if !errors.IsNotFound(err) {
            klog.Errorf(&quot;error retrieving resource lock %v: %v&quot;, le.config.Lock.Describe(), err)
            return false
        }
        if err = le.config.Lock.Create(leaderElectionRecord); err != nil {
            klog.Errorf(&quot;error initially creating leader election record: %v&quot;, err)
            return false
        }
        le.observedRecord = leaderElectionRecord
        le.observedTime = le.clock.Now()
        return true
    }

    // 2. 获取到了锁的信息，检查锁的持有者和更新时间
    if !reflect.DeepEqual(le.observedRecord, *oldLeaderElectionRecord) {
        le.observedRecord = *oldLeaderElectionRecord
        le.observedTime = le.clock.Now()
    }
    // 当前持有锁的人不是自己且距上一次观察时间还没有超过租约的时间则认为当前锁被他人正常持有，直接返回 false
    if len(oldLeaderElectionRecord.HolderIdentity) &gt; 0 &amp;&amp;
        le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;
        !le.IsLeader() {
        klog.V(4).Infof(&quot;lock is held by %v and has not yet expired&quot;, oldLeaderElectionRecord.HolderIdentity)
        return false
    }

    // 3. leaderElectionRecord 在函数开始的地方设置了默认值，这里根据自己是否是 leader 来更新相关的设置
    if le.IsLeader() {
        // Renew 操作，AcquireTime 使用旧的值，LeaderTransitions 保持不变
        leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime
        leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions
    } else {
        // 有 leader 切换，LeaderTransitions 值 + 1
        leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + 1
    }

    // 更新锁资源，这里如果在 Get 和 Update 之间有变化，将会更新失败
    if err = le.config.Lock.Update(leaderElectionRecord); err != nil {
        klog.Errorf(&quot;Failed to update lock: %v&quot;, err)
        return false
    }
    le.observedRecord = leaderElectionRecord
    le.observedTime = le.clock.Now()
    return true
}
</code></pre>

<p>这个步骤中很重要的一点是利用了 kubernetes API 操作的原子性。</p>

<p>在 <code>le.config.Lock.Get()</code> 中会获取到锁的对象，其中有一个 <code>resourceVersion</code> 字段用于标识一个资源对象的内部版本，每次更新操作都会更新其值。如果一个更新操作附加上了 <code>resourceVersion</code> 字段，那么 apiserver 就会通过验证当前 <code>resourceVersion</code> 的值与指定的值是否相匹配来确保在此次更新操作周期内没有其他的更新操作，从而保证了更新操作的原子性。</p>
            </div>
            
            <div style="border: 1px dashed #e0e0e0; margin-bottom: 15px; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
                <div>
                    <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.fatedier.com/">fatedier</a>
                    <br />本文出处：<a target="_blank" href="http://blog.fatedier.com/2019/04/17/k8s-custom-controller-high-available/">http://blog.fatedier.com/2019/04/17/k8s-custom-controller-high-available/</a>
                    <br />
                    文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。 </p>
                </div>
            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="/tags/kubernetes/">
                            <i class="fa fa-tags"></i>
                            kubernetes
                        </a>
                    </li>
                    
                </ul>

                
                
                <h4 id="real-rels">相关文章</h4>
                <ul class="post-rels" id="real-rels"><li id="li-rels"><a href="/2019/04/02/k8s-custom-controller/">kubernetes 自定义控制器</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年04月02日)</span></li><li id="li-rels"><a href="/2019/03/25/k8s-crd-authorization/">kubernetes CRD 权限管理</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月25日)</span></li><li id="li-rels"><a href="/2019/03/20/k8s-crd/">kubernetes 自定义资源(CRD)</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年03月20日)</span></li><li id="li-rels"><a href="/2019/01/12/service-mesh-explore-upgrade-http2/">Service Mesh 探索之升级 HTTP/2 协议</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年01月12日)</span></li><li id="li-rels"><a href="/2019/01/03/using-telepresence-for-quick-dev-in-k8s/">使用 telepresence 在 k8s 环境中实现快速开发</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2019年01月03日)</span></li><li id="li-rels"><a href="/2018/12/10/a-connect-timeout-problem-caused-by-k8s-pod-deleting/">kubernetes 中删除 pod 导致客户端连接不存在的 IP 超时问题</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年12月10日)</span></li><li id="li-rels"><a href="/2018/12/01/service-mesh-explore-local-node-lb/">Service Mesh 探索之优先本地访问</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年12月01日)</span></li><li id="li-rels"><a href="/2018/11/21/service-mesh-traffic-hijack/">Service Mesh 探索之流量劫持</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年11月21日)</span></li><li id="li-rels"><a href="/2018/10/15/self-designed-service-mesh/">Service Mesh 自研实践</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2018年10月15日)</span></li><li id="li-rels"><a href="/2016/06/24/demystifying-kubernetes-and-deployment/">kubernetes 初探及部署实践</a>&nbsp;&nbsp;<span class="post-date" style="font-size:14px">&nbsp;(2016年06月24日)</span></li></ul>
                
            </aside>
                
            
            <footer>
                <nav>
                    <ul class="pager">

                        
                        <li class="previous disabled"><a href="#"><span aria-hidden="true">&larr;</span> Prev</a></li>
                        

                        <li><a href="/post/">All Posts</a></li>

                        
                        <li class="next"><a href="/2019/04/02/k8s-custom-controller/">Next <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
        <div class="toc panel panel-default hidden-xs hidden-sm affix-top" data-spy="affix" data-offset-top="125" data-offset-bottom="300">
            <div class="panel-heading">
                <h2 class="panel-title">Catalog</h2>
            </div>

            <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#代码实现">代码实现</a></li>
<li><a href="#原理分析">原理分析</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2019  fatedier blog </p>
	<p>Powered by <a href="https://gohugo.io" target="_blank">Hugo</a></p>
</footer>

<script>
var children = $("#TableOfContents").children().first().children().first().children().first().children().first().children().first();
$("#TableOfContents").children().first().remove();
$("#TableOfContents").append(children);

var real = $("li#li-rels:lt(8)");
$("ul.post-rels").children().remove();
$("ul.post-rels").append(real);
if ($("ul.post-rels").children().length == 0) {
    $("#real-rels").remove();
}
</script>

<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ace3ec99de96c4080ead1eb8d52db3b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92600390-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>

