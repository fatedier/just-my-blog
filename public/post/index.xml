<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fatedier&#39;s blog </title>
    <link>http://blog.fatedier.com/post/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2015</rights>
    <updated>2014-09-24 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>从简单实例开始，学会写Makefile（二）</title>
          <link>http://blog.fatedier.com/2014/09/24/learn-to-write-makefile-02</link>
          <pubDate>Wed, 24 Sep 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/09/24/learn-to-write-makefile-02</guid>
          <description>

&lt;p&gt;如果文件间存在着相互之间的引用关系该怎么办？如果把.h文件和.cpp文件放在了不同的目录下该怎么办？如果我想生成静态库，然后在其他地方引用静态库该怎么办？如果我想将程序迁移到Unix平台下，使用不同的编译器，难道要依次修改所有的Makefile？&lt;/p&gt;

&lt;h3 id=&#34;d文件-解决文件间的相互引用:3da892c90f4c124b608eea75bdf80e17&#34;&gt;.d文件，解决文件间的相互引用&lt;/h3&gt;

&lt;h4 id=&#34;自动生成依赖关系:3da892c90f4c124b608eea75bdf80e17&#34;&gt;自动生成依赖关系&lt;/h4&gt;

&lt;p&gt;在前文的项目基础上，考虑一下这种情况：如果我们在w1.h文件里包含了头文件w2.h以及w3.h并且用到其中定义的函数。&lt;/p&gt;

&lt;p&gt;第一次编译没有遇到问题，但是如果后续的开发过程中修改了w2.h或者w3.h文件中的内容，再执行gmake命令的时候，就遇到问题了——w1.cpp文件不会被重新编译了！&lt;/p&gt;

&lt;p&gt;显然，我们需要将生成目标文件w1.o的规则的依赖项加上w2.h和w3.h。可是如果手动的去检查每一个文件的引用关系，然后修改Makefile文件，这样做的效率就太低了。&lt;/p&gt;

&lt;p&gt;万幸的是，编译器可以帮助我们自动生成依赖关系，只需要在编译命令中加上“-M”选项，就可以让编译器自动寻找源文件中包含的头文件，并生成一个依赖关系，例如，你可以在shell界面下敲下如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++-MM w1.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，其输出为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;w1.o:w1.cpp w2.h w3.h。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要特别注意的是，我们使用“-MM”而不是“-M”，因为我们使用的是GUN的C/C++编译器，使用“-M”参数会将标准库的头文件也一并包含进来，但这并不是我们想要的，而使用“-MM”则不会。&lt;/p&gt;

&lt;p&gt;现在的问题是，如何利用这个命令去写好我们的Makefile呢？&lt;/p&gt;

&lt;p&gt;GUN组织建议把每一个源文件自动生成的依赖关系放到一个.d文件中，让每一个.cpp文件都对应一个.d文件，例如之前的w1.cpp，我们可以生成一个w1.d文件，内容为自动生成的依赖关系 w1.o:w1.cpp w2.h w3.h，然后在Makefile中包含所有的.d文件，我们只需要写出.cpp文件和.d文件的依赖关系，让make自动更新或生成.d文件即可。&lt;/p&gt;

&lt;h4 id=&#34;生成-d文件:3da892c90f4c124b608eea75bdf80e17&#34;&gt;生成.d文件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dep/%.d:%.cpp
    @if test ! -d &amp;quot;dep&amp;quot;; then\
        mkdir -p dep;\
    fi; \
    set -e; rm -f $@;
    g++ -MM $&amp;lt; &amp;gt; $@.$$$$; \
    sed &#39;s/$*\.o[ :]*/obj\/$*\.o dep\/$*\.d: /g&#39; &amp;lt; $@.$$$$ &amp;gt; $@; \
    rm -f $@.$$$$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Makefile中加上如上的代码，就可以生成我们所需要的.d文件了。&lt;/p&gt;

&lt;p&gt;又是一堆莫名其妙的符号，我们还是来逐句进行分析。&lt;/p&gt;

&lt;h5 id=&#34;dep-d-cpp:3da892c90f4c124b608eea75bdf80e17&#34;&gt;dep/%.d: %.cpp&lt;/h5&gt;

&lt;p&gt;使所有的.d文件依赖于对应的.cpp文件，也就是说只要.cpp更新了，我们就重新生成对应的.d文件。这里和.o文件类似的，我们也创建一个dep目录用来存放所有的.d文件，既能保持项目文件的整洁和统一，也方便管理。&lt;/p&gt;

&lt;h5 id=&#34;if-test-d-dep-then:3da892c90f4c124b608eea75bdf80e17&#34;&gt;@if test ! -d &amp;ldquo;dep&amp;rdquo;; then&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;@if test ! -d &amp;quot;dep&amp;quot;; then\
    mkdir -p dep;\
fi; \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查当前目录下是否存在dep目录，如果不存在，就使用mkdir命令创建dep目录。&lt;/p&gt;

&lt;h5 id=&#34;set-e-rm-f:3da892c90f4c124b608eea75bdf80e17&#34;&gt;set -e; rm -f $@;&lt;/h5&gt;

&lt;p&gt;set–e 的作用是如果命令执行出错就直接退出。$@的含义之前已经说过，这里rm –f $@的意思就是删除所有的目标文件。&lt;/p&gt;

&lt;h5 id=&#34;g-mm:3da892c90f4c124b608eea75bdf80e17&#34;&gt;g++ -MM $&amp;lt; &amp;gt; $@.$$$$; &lt;/h5&gt;

&lt;p&gt;$&amp;lt; 的含义是第一个依赖项的名称，&amp;gt; 是重定向符号，将输出结果重定向到指定文件中。$@.$$$$ 就是这个文件的文件名，其中“$$$$”表示一个随机的编号，例如如果有目标文件是w1.d，那么“$@.$$$$”一个可能的结果就是w1.d.12345。那么，这句话的含义就是将g++ -MM w1.cpp的输出结果重定向到w1.d.12345这个文件中。&lt;/p&gt;

&lt;h5 id=&#34;sed-s-o-obj-o-dep-d-g:3da892c90f4c124b608eea75bdf80e17&#34;&gt;sed &amp;rsquo;s/$&lt;em&gt;.o[ :]&lt;/em&gt;/obj\/$&lt;em&gt;.o dep\/$&lt;/em&gt;.d : /g&amp;rsquo; &amp;lt; $@.$$$$ &amp;gt; $@;&lt;/h5&gt;

&lt;p&gt;这里使用了sed这个工具对文本进行替换处理，单引号中的规则是’s/old/new/g’，s表示替换，末尾的g代表全局的意思，对文本中所有符合要求的字符串进行替换，sed会将符合old模式的字符串替换为new，具体的使用方法可以查阅一下sed这个工具的帮助文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;$@$$$$，将这个文件的内容作为sed工具的输入。

&amp;gt;$@，将sed处理后的内容重定向输出到这个文件中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过这一步的处理后，就把自动生成的依赖关系：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;w1.o:w1.cpp w2.h w3.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;w1.o w1.d:w1.cpp w2.h w3.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，我们的.d文件也会自动更新啦。&lt;/p&gt;

&lt;h5 id=&#34;rm-f:3da892c90f4c124b608eea75bdf80e17&#34;&gt;rm -f $@.$$$$&lt;/h5&gt;

&lt;p&gt;删除掉这个临时文件。&lt;/p&gt;

&lt;h4 id=&#34;使用include包含其他文件:3da892c90f4c124b608eea75bdf80e17&#34;&gt;使用include包含其他文件&lt;/h4&gt;

&lt;p&gt;在Makefile中我们也可以像在C++文件中那样包含其他文件。&lt;/p&gt;

&lt;p&gt;现在在我们的Makefile中加上这样一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include w1.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这个语句就可以将之前我们生成的.d文件中的内容包含到当前的Makefile中。&lt;/p&gt;

&lt;p&gt;当然，也可以用这个命令来包含其他的Makefile文件。具体的用法后面再进行介绍。&lt;/p&gt;

&lt;p&gt;我们希望把所有的.d文件都包含在当前的Makefile中。&lt;/p&gt;

&lt;p&gt;先定义一个变量，存放所有的.d文件名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEPS = $(addsuffix .d,$(addprefix dep/,$(BASE)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用include$(DEPS) 包含所有的.d文件。&lt;/p&gt;

&lt;h3 id=&#34;i-引用其他目录下的-h文件:3da892c90f4c124b608eea75bdf80e17&#34;&gt;-I，引用其他目录下的.h文件&lt;/h3&gt;

&lt;p&gt;考虑这种情况：现在有两个目录，一个inc目录用来存放.h文件，一个src目录，用来存放.cpp文件。怎么让编译器找到引用的.h文件在哪个目录下呢？&lt;/p&gt;

&lt;p&gt;我们可以使用“-I”选项。  格式为“-I目录名”，这样在编译的时候，编译器就会依次到我们指定的目录中寻找.h文件。&lt;/p&gt;

&lt;p&gt;同样，先定义一个变量，存放所有头文件的目录名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INCLUDEDIR = -I../inc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -c -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的编译命令中写成&lt;/p&gt;

&lt;p&gt;g++ -c -o $@ $(INCLUDEDIR) $&amp;lt;&lt;/p&gt;

&lt;p&gt;OK，再来尝试用gmake命令编译一下吧，已经可以成功编译了。&lt;/p&gt;

&lt;p&gt;如果需要包含多个目录下的.h文件，可以重复使用-I选项，中间需要用空格隔开。&lt;/p&gt;

&lt;h3 id=&#34;使用静态库:3da892c90f4c124b608eea75bdf80e17&#34;&gt;使用静态库&lt;/h3&gt;

&lt;h4 id=&#34;修改生成静态库的makefile:3da892c90f4c124b608eea75bdf80e17&#34;&gt;修改生成静态库的Makefile&lt;/h4&gt;

&lt;p&gt;有的时候我们不需要生成一个可执行的程序，而是生成一个静态库文件，之后在其他的地方引用这个静态库文件。&lt;/p&gt;

&lt;p&gt;假设我们的项目目录结构是这样的，src是项目根目录，src下面有common和app以及lib两个目录，common和app下面都有inc和src两个目录。common存放公共库的源文件，app存放程序源文件，lib存放生成的静态库。&lt;/p&gt;

&lt;p&gt;修改我们在common目录下的Makefile文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;top_srcdir = ../..
#生成静态库后所存放的位置
libdir = $(top_srcdir)/lib
#静态库文件名
LIBNAME = libfa_common.a
#路径+静态库文件名
TARGET = $(libdir)/$(LIBNAME)

$(TARGET): $(OBJS)
    -rm -f $@
    ar cr $(TARGET) $(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;top_srcdir是项目根目录的路径，使用相对路径，方便我们在后面引用其他目录。&lt;/li&gt;
&lt;li&gt;libdir是生成的静态库所存放的路径。&lt;/li&gt;
&lt;li&gt;LIBNAME是静态库名称，注意，静态库的命名必须以“lib”开头，以“.a”结尾。&lt;/li&gt;
&lt;li&gt;TARGET是目标文件名称，包含路径。&lt;/li&gt;
&lt;li&gt;在生成静态库文件的规则中，使用ar这个命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;修改引用静态库的makefile:3da892c90f4c124b608eea75bdf80e17&#34;&gt;修改引用静态库的Makefile&lt;/h4&gt;

&lt;p&gt;在app/src目录下的源文件中，编译的时候需要引用libfa_common.a这个静态库，这就需要我们再修改app目录下的Makefile文件。&lt;/p&gt;

&lt;p&gt;这里使用了两个新的参数，“-l”和“-L”。&lt;/p&gt;

&lt;p&gt;“-l”参数指定要引用的库的名称。例如我们要引用libfa_common.a这个静态库，那么需要在编译命令里加上“-lfa_common”，可以看出，-l后面的库名称需要去除前面的“lib”和后面的“.a”。&lt;/p&gt;

&lt;p&gt;“-L”参数指定了要引用的库的目录，用法和之前的“-I”一样。这里需要注意的是，我们需要修改一下VPATH这个变量，指明要引用的静态库的目录。类似这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VPATH:= -L $(top_srcdir)/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;完整的makefile:3da892c90f4c124b608eea75bdf80e17&#34;&gt;完整的Makefile&lt;/h3&gt;

&lt;p&gt;其实在每一个目录下的Makefile中有很多部分是重复的，我们可以考虑将重复的部分提取出来，单独放在一个公共的Makefile中，然后在其他Makefile中用include包含这个公共的Makefile即可。&lt;/p&gt;

&lt;p&gt;我写了三套Makefile，分别是Makefile（app）、Makefile（lib）、Make.rules。&lt;/p&gt;

&lt;p&gt;其中，Make.rules是公共部分，Makefile（app）是用来生成可执行程序的，Makefile（lib）是用来生成静态库的，为了以后迁移方便，考虑到Linux和Unix平台的差异，以及各个编译器之间的差异，可以将各种命令也定义成变量，之后使用宏定义进行条件编译。&lt;/p&gt;

&lt;p&gt;贴一下完整的Makefile代码。&lt;/p&gt;

&lt;h4 id=&#34;make-rules:3da892c90f4c124b608eea75bdf80e17&#34;&gt;Make.rules&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#公用Make规则配置

#设置编译器类型
CXX := g++
CC := gcc

#设置编译.d文件相关内容
DEPFLAGS := -MM
DEPFILE = $@.$$$$

#设置所有静态库文件所在位置，会根据每个Makefile文件的top_srcdir设置相对位置
LIBDIR := $(top_srcdir)/lib

#设置编译程序时需要在哪些目录查找静态库文件
LDFLAGS := -L.\
           -L$(top_srcdir)/lib

#设置VPATH，在检查依赖关系时，如果查找-lxxxx时，在哪些目录查找静态库文件
VPATH := $(LIBDIR)

#设置编译程序时查找头文件的目录位置
INCLUDEDIR := -I.\
              -I../inc\

#声明要生成的目标文件，具体规则在具体的Makefile中定义
$(TARGET):

#生成.o文件所依赖的.cpp和.c文件
obj/%.o:%.cpp
@if test ! -d &amp;quot;obj&amp;quot;; then\
    mkdir-p obj;\
fi;
$(CXX)-c -o $@ $(INCLUDEDIR) $&amp;lt;

obj/%.o:%.c
    @iftest ! -d &amp;quot;obj&amp;quot;; then\
            mkdir-p obj;\
    fi;
    $(CC)-c -o $@ $(INCLUDEDIR) $&amp;lt;

#生成.d文件,存放.cpp文件的所有依赖规则
dep/%.d: %.cpp
    @iftest ! -d &amp;quot;dep&amp;quot;; then\
            mkdir-p dep;\
    fi;\
    set-e; rm -f $@;
    $(CXX)$(DEPFLAGS) $(INCLUDEDIR) $&amp;lt; &amp;gt;$(DEPFILE); \
    sed&#39;s/$*\.o[ :]*/obj\/$*\.o dep\/$*\.d : /g&#39; &amp;lt; $@.$$$$ &amp;gt; $@;\
    rm-f $@.$$$$

#生成.d文件,存放.c文件的所有依赖规则
dep/%.d: %.c
    @iftest ! -d &amp;quot;dep&amp;quot;; then\
            mkdir-p dep;\
    fi;\
    set-e; rm -f $@;
    $(CC)$(DEPFLAGS) $(INCLUDEDIR) $&amp;lt; &amp;gt; $(DEPFILE); \
    sed&#39;s/$*\.o[ :]*/obj\/$*\.o dep\/$*\.d : /g&#39; &amp;lt; $@.$$$$ &amp;gt; $@; \
    rm-f $@.$$$$

include $(DEPS)

#检测是否有文件被修改，只要有就全部编译
all: $(SRCS) $(TARGETS)

#清除编译文件
.PHONY:clean
clean:
    -rm-f $(TARGET)
    -rm-f obj/*.o
    -rm-f dep/*.d
    -rm-f core
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;makefile-lib:3da892c90f4c124b608eea75bdf80e17&#34;&gt;Makefile（lib）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#需要生成静态库的Makefile

#程序根目录
top_srcdir         =../../..

#生成静态库后所存放的位置
libdir = $(top_srcdir)/lib
#静态库文件名
LIBNAME          =libfa_common.a
#路径+静态库文件名
TARGET           =$(libdir)/$(LIBNAME)

CPP_FILES = $(shell ls *.cpp)
C_FILES = $(-shell ls *.c)
SRCS = $(CPP_FILES) $(C_FILES)
BASE = $(basename $(SRCS))
OBJS = $(addsuffix .o, $(addprefixobj/,$(BASE)))
DEPS = $(addsuffix .d, $(addprefixdep/,$(BASE)))

#包含公共Make规则
include$(top_srcdir)/makeinclude/Make.rules

#设置头文件及库文件的位置
INCLUDEDIR := $(INCLUDEDIR)

$(TARGET): $(OBJS)
    -rm-f $@
    ar cr $(TARGET) $(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;makefile-app:3da892c90f4c124b608eea75bdf80e17&#34;&gt;Makefile（app）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#需要生成可执行程序的Makefile

#程序根目录
top_srcdir         =../../..

#目标程序名
TARGET = test

CPP_FILES = $(shell ls *.cpp)
C_FILES = $(-shell ls *.c)
SRCS = $(CPP_FILES) $(C_FILES)
BASE = $(basename $(SRCS))
OBJS = $(addsuffix .o, $(addprefixobj/,$(BASE)))
DEPS = $(addsuffix .d, $(addprefixdep/,$(BASE)))

#包含公共Make规则
include $(top_srcdir)/makeinclude/Make.rules

#额外需要包含的头文件的目录位置
INCLUDEDIR := $(INCLUDEDIR)\
              -I$(top_srcdir)/src/common/inc\

#所有要包含的静态库的名称
LIBS := -lfa_common

#设置目标程序依赖的.o文件
$(TARGET):$(OBJS) $(LIBS)
    -rm-f $@
    $(CXX)-o $(TARGET) $(INCLUDEDIR) $(LDFLAGS) $(OBJS) $(LIBS)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>从简单实例开始，学会写Makefile（一）</title>
          <link>http://blog.fatedier.com/2014/09/08/learn-to-write-makefile-01</link>
          <pubDate>Mon, 08 Sep 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2014/09/08/learn-to-write-makefile-01</guid>
          <description>

&lt;p&gt;作为一个刚刚从大学毕业的新人，进公司不久就遇到了一个不大不小的门槛——看不懂Makefile！而Makefile所干的事却关系到程序的编译和链接，一个好的Makefile文件可以极大地提升编译项目文件的效率，免去手动编译的烦恼。&lt;/p&gt;

&lt;p&gt;不会写Makefile虽然还不至于影响到项目进度，从别的地方拷贝一份过来稍加修改就可以用了，但是，对于咱们“程序猿”来说这实在是一件让人感觉很不爽的事。于是，百度，谷歌（PS：吐槽一下，不XX的话Google已经完全不能用了，Bing的效果都要比百度好一些），各种看资料，看大牛的博客，或许是本人比较笨，也或许是网上的资料不太适合咱们这种新人，缺乏生动的实例讲解，所以决定自己动手研究一下，并把过程分享给大家，希望新人们看完这篇文章后就能够自己动手，为自己的项目编写合适的Makefile啦。&lt;/p&gt;

&lt;h3 id=&#34;为什么要写makefile:faa200a09f18bf5060563b9fc5d15373&#34;&gt;为什么要写Makefile&lt;/h3&gt;

&lt;p&gt;首先要确定我们的目标，Makefile是用来干嘛的？&lt;/p&gt;

&lt;p&gt;曾经很长时间我都是在从事Windows环境下的开发，所以根本不知道Makefile是个什么东西。因为早已经习惯了使用VS、Eclipse等等优秀的IDE做开发，只要点一个按钮，程序就可以运行啦。但是进入公司以后，从事的是Unix环境下的开发工作，没有了IDE，要怎么才能让我写的代码编译后运行呢？&lt;/p&gt;

&lt;p&gt;在这里，Makefile的作用就体现出来了，简单的四个字—— “自动编译”。一旦整个项目的Makefile都写好了以后，只需要一个简单的make命令，就可以实现自动编译了。当然，准确的说，是make这个命令工具帮助我们实现了我们想要做的事，而Makefile就相当于是一个规则文件，make程序会按照Makefile所指定的规则，去判断哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。&lt;/p&gt;

&lt;p&gt;俗话说，懒人创造了整个世界，程序员就是在不断偷懒的过程中获得进步，使用Makefile最根本的目的就是简化我们的工作。&lt;/p&gt;

&lt;p&gt;下面我们就从头开始，一步一步的去学习如何写好一个Makefile文件吧！&lt;/p&gt;

&lt;h3 id=&#34;从单个文件开始:faa200a09f18bf5060563b9fc5d15373&#34;&gt;从单个文件开始&lt;/h3&gt;

&lt;h4 id=&#34;1-单个文件的编译:faa200a09f18bf5060563b9fc5d15373&#34;&gt;1、单个文件的编译&lt;/h4&gt;

&lt;p&gt;为了便于大家学习，这篇文章是以常见的Linux平台为基础的，系统为Centos6.5，使用GNU make工具进行编译，项目文件为C++格式。这里假定看到这篇文章的都是已经对C++程序的编译等基础知识和相关命令有了一定的了解的，鉴于篇幅限制，如果还有不清楚的就请自行查阅相关资料啦。&lt;/p&gt;

&lt;p&gt;假设我们在src目录下有一个test.cpp文件，我们是如何编译它的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -o test test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在shell界面执行这句命令，当前目录下会生成一个名为test的可执行程序，使用./test就可以执行该程序，看到输出结果。&lt;/p&gt;

&lt;p&gt;现在我们尝试使用编写Makefile的方式来实现这一编译过程。 首先在当前目录下新建文件并命名为“Makefile”，这样编译的时候直接使用gmake命令即可，默认使用“Makefile”文件进行编译，也可以是其他名字，那样的话需要使用“gmake -f 文件名”的格式来指定Makefile文件。&lt;/p&gt;

&lt;p&gt;Makefile文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test:test.cpp
    g++-o test test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在shell界面下执行gmake命令，敲下回车，OK。&lt;/p&gt;

&lt;p&gt;可以发现，g++ -o test test.cpp 这条命令已经被自动执行了，生成了名为test的程序。&lt;/p&gt;

&lt;h4 id=&#34;2-makefile的描述规则:faa200a09f18bf5060563b9fc5d15373&#34;&gt;2、Makefile的描述规则&lt;/h4&gt;

&lt;p&gt;至此，我们已经完成了一个最简单的Makefile文件，向我们的最终目标迈出了一大步！&lt;/p&gt;

&lt;p&gt;有的人会问，传说中的自动化编译呢？难道每一个文件都要自己去写文件名和命令？&lt;/p&gt;

&lt;p&gt;不用急，我们先来分析一下这个Makefile文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;TARGET... :PREREQUISITES...
    COMMAND
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是最简单的Makefile文件的描述规则，可以说，这也是Makefile中最精华的部分，其他部分都是围绕着这个最基本的描述规则的。先来解释一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TARGET：规则生成的目标文件，通常是需要生成的程序名（例如前面出现的程序名test）或者过程文件（类似.o文件）。&lt;/li&gt;
&lt;li&gt;PREREQUISITES：规则的依赖项，比如前面的Makefile文件中我们生成test程序所依赖的就是test.cpp。&lt;/li&gt;
&lt;li&gt;COMMAND：规则所需执行的命令行，通常是编译命令。这里需要注意的是每一行命令都需要以[TAB]字符开头。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再来看我们之前写过的Makefile文件，这个规则，用通俗的自然语言翻译过来就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果目标test文件不存在，根据规则创建它。&lt;/li&gt;
&lt;li&gt;目标test文件存在，并且test文件的依赖项中存在任何一个比目标文件更新（比如修改了一个函数，文件被更新了），根据规则重新生成它。&lt;/li&gt;
&lt;li&gt;目标test文件存在，并且它比所有的依赖项都更新，那么什么都不做。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们第一次执行gmake命令时，test文件还不存在，所以就会执行g++-o test test.cpp这条命令创建test文件。&lt;/p&gt;

&lt;p&gt;而当我们再一次执行gmake时，会提示文件已经是最新的，什么都不做。&lt;/p&gt;

&lt;p&gt;这时候，如果修改了test.cpp命令，再次执行gmake命令。&lt;/p&gt;

&lt;p&gt;由于依赖项比目标文件更新，g++ -o test test.cpp这条命令就又会被再一次执行。&lt;/p&gt;

&lt;p&gt;现在，我们已经学会如何写一个简单的Makefile文件了，每次修改过源文件以后，只要执行gmake命令就可以得到我们想要生成的程序，而不需要一遍遍地重复敲g++ -o test test.cpp这个命令。&lt;/p&gt;

&lt;h3 id=&#34;多个文件的编译:faa200a09f18bf5060563b9fc5d15373&#34;&gt;多个文件的编译&lt;/h3&gt;

&lt;h4 id=&#34;1-使用命令行编译多个文件:faa200a09f18bf5060563b9fc5d15373&#34;&gt;1、使用命令行编译多个文件&lt;/h4&gt;

&lt;p&gt;一个项目不可能只有一个文件，学会了单个文件的编译，自然而然就要考虑如何去编译多个文件呢？&lt;/p&gt;

&lt;p&gt;同样，假设当前目录下有如下7个文件，test.cpp、w1.h、w1.cpp、w2.h、w2.cpp、w3.h、w3.cpp。其中test.cpp包含main函数，并且引用了w1.h、w2.h以及w3.h。我们需要生成的程序名为test。&lt;/p&gt;

&lt;p&gt;在shell界面下，为了正确编译我们的项目，我们需要敲下如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -c -o w1.ow1.cpp
g++ -c -o w2.o w2.cpp
g++ -c -o w3.o w3.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时当前目录下会生成w1.o、w2.o、w3.o三个.o文件。这里需要注意的是，“-c”命令是只编译，不链接，通常生成.o文件的时候使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -o testtest.cpp w1.o w2.o w3.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完这条命令后，编译成功，得到了我们想要的test文件。&lt;/p&gt;

&lt;h4 id=&#34;2-使用makefile编译多个文件:faa200a09f18bf5060563b9fc5d15373&#34;&gt;2、使用Makefile编译多个文件&lt;/h4&gt;

&lt;p&gt;既然单个文件的Makefile会写了，相信多个文件举一反三也不是问题了。&lt;/p&gt;

&lt;p&gt;Makefile具体内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test:test.cppw1.o w2.o w3.o
    g++ -o test test.cpp w1.o w2.o w3.o
w1.o:w1.cpp
    g++ -c -o w1.o w1.cpp
w2.o:w2.cpp
    g++ -c -o w2.o w2.cpp
w3.o:w3.cpp
    g++ -c -o w3.o w3.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的是，我们写的第一个规则的目标，将会成为“终极目标”，也就是我们最终希望生成的程序，这里是“test”文件。根据我们的“终极目标”，make会进行自动推导，例如“终极目标”依赖于的.o文件，make就会寻找生成这些.o文件的规则，然后执行相应的命令去生成这些文件，这样一层一层递归地进行下去，直到最终生成了“终极目标”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../../pic/2014/2014-09-08-learn-to-write-makefile-01-gmake-target.jpg&#34; alt=&#34;gmake-target&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;如上图所示，虽然生成test文件的规则写在最前面，但是由于依赖于w1.o、w2.o、w3.o，make会先执行生成w1.o、w2.o、w3.o所需的命令，然后才会执行g++ -o test test.cpp w1.o w2.o w3.o 来生成test文件。&lt;/p&gt;

&lt;h4 id=&#34;3-使用伪目标来清除过程文件:faa200a09f18bf5060563b9fc5d15373&#34;&gt;3、使用伪目标来清除过程文件&lt;/h4&gt;

&lt;p&gt;我们现在已经可以自动编译多个文件的项目了，但是当我们需要全部重新编译的时候，难道还要手动地一个一个去删除那些生成的.o文件吗？&lt;/p&gt;

&lt;p&gt;既然已经使用了Makefile，我们的目标就是实现自动化编译，那么这些清除过程文件这点小事必须得能够用一个命令搞定啦。&lt;/p&gt;

&lt;p&gt;我们只需要在Makefile文件的最后加上如下几行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clean:
    -rm–f test *.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，轻松搞定，然后在shell界面下执行gmakeclean。仔细看看，是不是所有的.o文件和最后生成的程序文件已经被清除了？&lt;/p&gt;

&lt;p&gt;这里说明一下，rm是Linux下删除文件或目录的命令，前面加上“-”符号意思是忽略执行rm产生的错误。“-f”参数是指强制删除，忽略不存在的文件。&lt;/p&gt;

&lt;p&gt;这样的目标叫做“伪目标”，通过“gmake 目标名”来指定这个目标，然后执行这个目标规则下的命令。&lt;/p&gt;

&lt;h3 id=&#34;使用变量简化makefile:faa200a09f18bf5060563b9fc5d15373&#34;&gt;使用变量简化Makefile&lt;/h3&gt;

&lt;p&gt;作为一个“懒惰”的程序员，现在问题又来了。如果按照上面的写法，在文件数量和名称不变的情况的下确实是没有问题，但是如果我们新增一个文件的话，岂不是又要去修改Makefile了，一个项目多的可能有成百上千的文件，这样管理起来得有多麻烦呀！&lt;/p&gt;

&lt;p&gt;还记得我们在Linux下如果要查看当前目录下所有的cpp文件的时候，使用的命令吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls *.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个命令，我们就可以将所有的cpp文件名称显示在界面上。而在Makefile中我们同样可以使用类似的规则来做简化，进一步减少后续开发过程中对Makefile文件的修改。&lt;/p&gt;

&lt;p&gt;修改后的Makefile文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;TARGET = test

CPP_FILES = $(shell ls *.cpp)
BASE = $(basename $(CPP_FILES))
OBJS = $(addsuffix .o, $(addprefix obj/,$(BASE)))
 
$(TARGET):$(OBJS)
    -rm -f $@
    g++ -o $(TARGET)$(OBJS)
 
obj/%.o:%.cpp
    @if test ! -d&amp;quot;obj&amp;quot;; then\
    mkdir -pobj;\
    fi;
    g++ -c -o $@ $&amp;lt;
 
clean:
    -rm -f test
    -rm -f obj/*.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是瞬间有种摸不着头脑的感觉？别急，这是因为我们用到了一些新的语法和命令，其实，本质上和我们之前所写的Makefile文件是一个意思，下面我们就逐条来进行分析。&lt;/p&gt;

&lt;h5 id=&#34;target-test:faa200a09f18bf5060563b9fc5d15373&#34;&gt;TARGET = test&lt;/h5&gt;

&lt;p&gt;定义一个变量，保存目标文件名，这里我们需要生成的程序名就叫test。&lt;/p&gt;

&lt;h5 id=&#34;cpp-files-shell-ls-cpp:faa200a09f18bf5060563b9fc5d15373&#34;&gt;CPP_FILES = $(shell ls *.cpp)&lt;/h5&gt;

&lt;p&gt;定义一个变量，内容为所有的以.cpp为后缀的文件的文件名，以空格隔开。&lt;/p&gt;

&lt;p&gt;这里&amp;amp;(shell 命令)的格式，说明这里将会用shell命令执行后输出的内容进行替换，就和在命令行下输入ls *.cpp得到的结果一样。&lt;/p&gt;

&lt;h5 id=&#34;base-basename-cpp-files:faa200a09f18bf5060563b9fc5d15373&#34;&gt;BASE = $(basename $(CPP_FILES))&lt;/h5&gt;

&lt;p&gt;定义一个变量，内容为所有的以.cpp为后缀的文件的文件名去除掉后缀部分。&lt;/p&gt;

&lt;p&gt;$(CPP_FILES)是引用CPP_FIFES这个变量的内容，相信学过如何写shell命令的同学肯定不会陌生。basename 是一个函数，其作用就是去除掉文件名的后缀部分，例如“test.cpp”，经过这一步后就变成了“test”。&lt;/p&gt;

&lt;h5 id=&#34;objs-addsuffix-o-addprefix-obj-base:faa200a09f18bf5060563b9fc5d15373&#34;&gt;OBJS = $(addsuffix .o, $(addprefix obj/,$(BASE)))&lt;/h5&gt;

&lt;p&gt;定义一个变量，内容为所有的以.cpp为后缀的文件去除调后缀部分后加上“.o”。&lt;/p&gt;

&lt;p&gt;和basename一样，addsuffix和addprefix同样也是调用函数。addprefix的作用是给每个文件名加上前缀，这里是加上“obj/”，而addsuffix的作用是给每个文件名加上后缀，这里是在文件名后加上“.o”。例如“test”，经过变换后变成了“obj/test.o”。&lt;/p&gt;

&lt;p&gt;为什么要在文件名前加上“obj/”？&lt;/p&gt;

&lt;p&gt;这个不是必须的，只是我自己觉得将所有的.o文件放在一个obj目录下统一管理会让目录结构显得更加清晰，包括以后的.d文件会统一放在dep目录下一样。当然，你也可以选择不这样做，而是全部放在当前目录下。&lt;/p&gt;

&lt;h5 id=&#34;target-objs:faa200a09f18bf5060563b9fc5d15373&#34;&gt;$(TARGET):$(OBJS)&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$(TARGET):$(OBJS)
    -rm -f $@
    g++ -o $(TARGET) $(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个描述规则和我们之前写过的很像，只不过，使用了变量进行替换。其中需要注意的是$@这个奇怪的符号，它的含义是这个规则的目标文件的名称，在这里就相当于是$(TARGET)。&lt;/p&gt;

&lt;p&gt;把这里的变量替换成我们之前项目中的实际值，就相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;test:test.ow1.o w2.o w3.o
    -rm-f test
    g++ -o test test.o w1.o w2.o w3.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果按照这种写法，当我们新增了一个w4.cpp文件的时候，就需要对Makefile进行修改，而如果我们使用了变量进行替换，那么我们就什么都不用做，直接再执行一遍gmake命令即可。&lt;/p&gt;

&lt;h5 id=&#34;obj-o-cpp:faa200a09f18bf5060563b9fc5d15373&#34;&gt;obj/%.o:%.cpp&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;obj/%.o:%.cpp
    @if test ! -d&amp;quot;obj&amp;quot;; then\
        mkdir -p obj;\
    fi;
    g++ -c -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是依次生成所有cpp文件所对应的.o文件的规则。&lt;/p&gt;

&lt;p&gt;%.o和%.c表示以.o和.c结尾的文件名。因为我们准备把所有的.o文件放在obj目录下，所以这里在“%.o”前面加上前缀“obj/”。&lt;/p&gt;

&lt;p&gt;下面命令行的前三行，具体的作用是检查当前目录下是否有名为“obj”的目录，如果没有，则使用mkdir命令创建这个目录。如果不了解的同学不如先去看一下shell编程的相关知识吧。&lt;/p&gt;

&lt;p&gt;最后一句中的$@前面已经解释过了，是代表规则的目标文件名称，而$&amp;lt;与之对应的，则是代表规则的依赖项中第一个依赖文件的名称。&lt;/p&gt;

&lt;p&gt;例如obj/test.o:test.cpp&lt;/p&gt;

&lt;p&gt;那么$@的值为“test.o”，$&amp;lt;的值为“test.cpp”&lt;/p&gt;

&lt;h5 id=&#34;clean:faa200a09f18bf5060563b9fc5d15373&#34;&gt;clean:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clean:
    -rm -f test
    -rm -f obj/*.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就没什么好说的啦，这里只是修改了一下.o文件的路径。&lt;/p&gt;

&lt;p&gt;到这里，相信你对如何使用Makefile来编译一个小的项目已经颇有些眉目了吧。使用这个Makefile文件，不管你往这个目录下加多少文件，轻轻松松一个gmake命令搞定，不需要再因为加了一个新的文件而去修改Makefile了。&lt;/p&gt;

&lt;p&gt;但是，你难道没有觉得仍然存在着很多问题吗？&lt;/p&gt;

&lt;p&gt;如果文件间存在着相互之间的引用关系该怎么办？&lt;/p&gt;

&lt;p&gt;如果把.h文件和.cpp文件放在了不同的目录下该怎么办？&lt;/p&gt;

&lt;p&gt;如果我想生成静态库，然后在其他地方引用静态库该怎么办？&lt;/p&gt;

&lt;p&gt;如果我想将程序迁移到Unix平台下，使用不同的编译器，难道要依次修改所有的Makefile？&lt;/p&gt;

&lt;p&gt;大家可以先尝试着自己解决以上的问题，在之后的篇幅中我们会就以上几点继续通过举例的方式来加以解决。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
