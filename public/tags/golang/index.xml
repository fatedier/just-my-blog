<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fatedier blog </title>
    <link>http://blog.fatedier.com/tags/golang/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2016</rights>
    <updated>2016-08-08 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>go 程序中获取虚拟块设备的读写速度</title>
          <link>http://blog.fatedier.com/2016/08/08/get-wr-speed-of-virtual-block-device-in-golang</link>
          <pubDate>Mon, 08 Aug 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/08/08/get-wr-speed-of-virtual-block-device-in-golang</guid>
          <description>

&lt;p&gt;最近在写程序时需要在 centos5 系统上获取 device mapper 中的虚拟块设备的读写信息。在这个过程中发现由于
go 跨平台的特性，有一些 api 是无法拿到特定平台上的一些特殊信息的，或者是需要一些小技巧来实现。&lt;/p&gt;

&lt;h3 id=&#34;获取磁盘读写速度&#34;&gt;获取磁盘读写速度&lt;/h3&gt;

&lt;p&gt;正常情况下 linux 上通过 &lt;code&gt;/proc/diskstats&lt;/code&gt; 这个文件来获取磁盘设备的读写信息，这个文件的内容可以通过 &lt;code&gt;cat /proc/diskstats&lt;/code&gt; 获取，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   1    0 ram0 0 0 0 0 0 0 0 0 0 0 0
   1    1 ram1 0 0 0 0 0 0 0 0 0 0 0
   1    2 ram2 0 0 0 0 0 0 0 0 0 0 0
   1    3 ram3 0 0 0 0 0 0 0 0 0 0 0
   1    4 ram4 0 0 0 0 0 0 0 0 0 0 0
   1    5 ram5 0 0 0 0 0 0 0 0 0 0 0
   1    6 ram6 0 0 0 0 0 0 0 0 0 0 0
   1    7 ram7 0 0 0 0 0 0 0 0 0 0 0
   1    8 ram8 0 0 0 0 0 0 0 0 0 0 0
   1    9 ram9 0 0 0 0 0 0 0 0 0 0 0
   1   10 ram10 0 0 0 0 0 0 0 0 0 0 0
   1   11 ram11 0 0 0 0 0 0 0 0 0 0 0
   1   12 ram12 0 0 0 0 0 0 0 0 0 0 0
   1   13 ram13 0 0 0 0 0 0 0 0 0 0 0
   1   14 ram14 0 0 0 0 0 0 0 0 0 0 0
   1   15 ram15 0 0 0 0 0 0 0 0 0 0 0
   8    0 sda 29130 11247 905939 500914 155932 727767 7071070 2191673 0 552400 2692588
   8    1 sda1 84 1040 2264 450 31 12 86 382 0 809 832
   8    2 sda2 29026 10190 903379 500111 155901 727755 7070984 2191291 0 551590 2691403
 253    0 dm-0 38942 0 902058 758838 883873 0 7070984 30357342 0 551667 31116195
 253    1 dm-1 142 0 1136 502 0 0 0 0 0 84 502
  22    0 hdc 0 0 0 0 0 0 0 0 0 0 0
   2    0 fd0 0 0 0 0 0 0 0 0 0 0 0
   9    0 md0 0 0 0 0 0 0 0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一列和第二列是设备号，第三列是设备名称，第六列是读取的 sectors 数，第十列是写入的 sectors 数。&lt;/p&gt;

&lt;p&gt;和计算 cpu 使用率类似，我们需要读取两次该文件，将两次读取到的值相减以后除以间隔时间来计算读写速度。&lt;/p&gt;

&lt;h3 id=&#34;虚拟块设备的区别&#34;&gt;虚拟块设备的区别&lt;/h3&gt;

&lt;p&gt;通过 &lt;code&gt;df -h&lt;/code&gt; 可以看到其中 &lt;code&gt;/dev/mapper/VolGroup00-LogVol00&lt;/code&gt; 就是一个虚拟块设备：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup00-LogVol00
                       18G  1.9G   15G  12% /
/dev/sda1              99M   13M   81M  14% /boot
tmpfs                 499M     0  499M   0% /dev/shm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是获取读写信息时拿到的对应设备名并不是这个，实际上应该是 &lt;code&gt;dm-0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以我们需要通过设备号来获取他们的对应关系。&lt;/p&gt;

&lt;h4 id=&#34;获取设备号&#34;&gt;获取设备号&lt;/h4&gt;

&lt;p&gt;在 centos5 上比较特殊，没法使用 &lt;code&gt;lsblk&lt;/code&gt; 获取设备号，所以需要用其他的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls -lh /dev/mapper/

total 0
crw------- 1 root root  10, 60 Jul 11 22:18 control
brw-rw---- 1 root disk 253,  0 Jul 11 22:19 VolGroup00-LogVol00
brw-rw---- 1 root disk 253,  1 Jul 11 22:18 VolGroup00-LogVol01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出 &lt;code&gt;VolGroup00-LogVol00&lt;/code&gt; 的设备号为 &lt;code&gt;253,0&lt;/code&gt;，既然 &lt;code&gt;ls -lh&lt;/code&gt; 可以显示设备号信息，说明这个信息是可以通过 &lt;code&gt;stat&lt;/code&gt; 获取到的。&lt;/p&gt;

&lt;h4 id=&#34;go-中获取文件信息&#34;&gt;go 中获取文件信息&lt;/h4&gt;

&lt;p&gt;go 中文件的信息接口如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type FileInfo interface {
    Name() string           // 文件的名字（不含扩展名）
    Size() int64            // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同
    Mode() FileMode         // 文件的模式位
    ModTime() time.Time     // 文件的修改时间
    IsDir() bool            // 等价于
    Mode().IsDir()Sys() interface{} // 底层数据来源（可以返回nil）
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 go 语言需要考虑跨平台的特性，正常情况下只能拿到这些通用的信息。而如果要在 linux 下获取设备号，关键就在于那个 &lt;code&gt;Sys()&lt;/code&gt; 函数所返回的 &lt;code&gt;Interface{}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 linux 平台上，其对应的是一个 &lt;code&gt;Stat_t&lt;/code&gt; 结构体：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Stat_t struct {
    Dev       uint64
    X__pad1   uint16
    Pad_cgo_0 [2]byte
    X__st_ino uint32
    Mode      uint32
    Nlink     uint32
    Uid       uint32
    Gid       uint32
    Rdev      uint64
    X__pad2   uint16
    Pad_cgo_1 [2]byte
    Size      int64
    Blksize   int32
    Blocks    int64
    Atim      Timespec
    Mtim      Timespec
    Ctim      Timespec
    Ino       uint64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需要注意这个结构体在不同平台上的定义是不同的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其中的 &lt;code&gt;Rdev&lt;/code&gt; 就是设备号的值，例如查看上文中的设备文件设备号返回结果是 &lt;code&gt;64768&lt;/code&gt;，转换成 &lt;code&gt;ls -lh&lt;/code&gt; 中显示的格式就是 &lt;code&gt;253,0&lt;/code&gt;，转换成 16 进制是 &lt;code&gt;FD00&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面是示例代码片段，需要注意的是这段代码可能并不能在除 linux 之外的其他平台运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;dev, err := os.Stat(&amp;quot;/dev/mapper/VolGroup00-LogVol00&amp;quot;)
if err != nil {
    os.Exit(1)
}
sys, ok := dev.Sys().(*syscall.Stat_t)
if !ok {
    os.Exit(1)
}
major := sys.Rdev / 256
minor := sys.Rdev % 256
devNumStr := fmt.Sprintf(&amp;quot;%d:%d&amp;quot;, major, minor)
fmt.Printf(&amp;quot;get dev mapper [%s] [%s]&amp;quot;, dev.Name, devNumStr)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>InfluxDB详解之TSM存储引擎解析（一）</title>
          <link>http://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one</link>
          <pubDate>Fri, 05 Aug 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one</guid>
          <description>

&lt;p&gt;InfluxDB 项目更新比较快，google 了一下网上的一些文档基本上都是简单介绍了一下，而且很多都已经过时了，比如其中使用的 TSM 存储引擎，甚至官方文档上的内容都不是最新的。在源码里的 README 中有最新的设计实现的一些概要说明。&lt;/p&gt;

&lt;p&gt;我认为像这样的针对特殊场景进行优化的数据库会是今后数据库领域发展的主流，这里针对 InfluxDB 1.0.0 版本的源码深入研究一下 TSM 引擎的实现原理。TSM 存储引擎解决了 InfluxDB 之前使用的 LevelDB 和 BoltDB 时遇到的一些问题。&lt;/p&gt;

&lt;p&gt;因为 TSM 是根据 LSM Tree 针对时间序列数据优化而来，所以总体架构设计上相差并不是很大，LSM Tree 的概念可以参考 &lt;a href=&#34;http://blog.fatedier.com/2016/06/15/learn-lsm-tree/&#34;&gt;『LSM Tree 学习笔记』&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;

&lt;p&gt;首先需要简单了解 InfluxDB 的总体的架构以及一些关键概念，有一个总的思路，知道这个数据库是为了存储什么样的数据，解决哪些问题而诞生的，便于后面理解 TSM 存储引擎的详细的结构。可以简单看一下我之前的文章，&lt;a href=&#34;http://blog.fatedier.com/2016/07/05/research-of-time-series-database-influxdb/&#34;&gt;『时间序列数据库调研之InfluxDB』&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;数据格式&#34;&gt;数据格式&lt;/h4&gt;

&lt;p&gt;在 InfluxDB 中，我们可以粗略的将要存入的一条数据看作&lt;strong&gt;一个虚拟的 key 和其对应的 value(field value)&lt;/strong&gt;，格式如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cpu_usage,host=server01,region=us-west value=0.64 1434055562000000000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚拟的 key 包括以下几个部分： database, retention policy, measurement, tag sets, field name, timestamp。&lt;/strong&gt; database 和 retention policy 在上面的数据中并没有体现，通常在插入数据时在 http 请求的相应字段中指定。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;database&lt;/strong&gt;: 数据库名，在 InfluxDB 中可以创建多个数据库，不同数据库中的数据文件是隔离存放的，存放在磁盘上的不同目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;retention policy&lt;/strong&gt;: 存储策略，用于设置数据保留的时间，每个数据库刚开始会自动创建一个默认的存储策略 autogen，数据保留时间为永久，之后用户可以自己设置，例如保留最近2小时的数据。插入和查询数据时如果不指定存储策略，则使用默认存储策略，且默认存储策略可以修改。InfluxDB 会定期清除过期的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;measurement&lt;/strong&gt;: 测量指标名，例如 cpu_usage 表示 cpu 的使用率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tag sets&lt;/strong&gt;: tags 在 InfluxDB 中会按照字典序排序，不管是 tagk 还是 tagv，只要不一致就分别属于两个 key，例如 &lt;code&gt;host=server01,region=us-west&lt;/code&gt; 和 &lt;code&gt;host=server02,region=us-west&lt;/code&gt; 就是两个不同的 tag set。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;field name&lt;/strong&gt;: 例如上面数据中的 &lt;code&gt;value&lt;/code&gt; 就是 fieldName，InfluxDB 中支持一条数据中插入多个 fieldName，这其实是一个语法上的优化，在实际的底层存储中，是当作多条数据来存储。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;timestamp&lt;/strong&gt;: 每一条数据都需要指定一个时间戳，在 TSM 存储引擎中会特殊对待，以为了优化后续的查询操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;point&#34;&gt;Point&lt;/h4&gt;

&lt;p&gt;InfluxDB 中单条插入语句的数据结构，&lt;code&gt;series + timestamp&lt;/code&gt; 可以用于区别一个 point，也就是说一个 point 可以有多个 field name 和 field value。&lt;/p&gt;

&lt;h4 id=&#34;series&#34;&gt;Series&lt;/h4&gt;

&lt;p&gt;series 相当于是 InfluxDB 中一些数据的集合，在同一个 database 中，retention policy、measurement、tag sets 完全相同的数据同属于一个 series，同一个 series 的数据在物理上会按照时间顺序排列存储在一起。&lt;/p&gt;

&lt;p&gt;series 的 key 为 &lt;code&gt;measurement + 所有 tags 的序列化字符串&lt;/code&gt;，这个 key 在之后会经常用到。&lt;/p&gt;

&lt;p&gt;代码中的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Series struct {
    mu          sync.RWMutex
    Key         string              // series key
    Tags        map[string]string   // tags
    id          uint64              // id
    measurement *Measurement        // measurement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;shard&#34;&gt;Shard&lt;/h4&gt;

&lt;p&gt;shard 在 InfluxDB 中是一个比较重要的概念，它和 retention policy 相关联。每一个存储策略下会存在许多 shard，每一个 shard 存储一个指定时间段内的数据，并且不重复，例如 7点-8点 的数据落入 shard0 中，8点-9点的数据则落入 shard1 中。每一个 shard 都对应一个底层的 tsm 存储引擎，有独立的 cache、wal、tsm file。&lt;/p&gt;

&lt;p&gt;创建数据库时会自动创建一个默认存储策略，永久保存数据，对应的在此存储策略下的 shard 所保存的数据的时间段为 7 天，计算的函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func shardGroupDuration(d time.Duration) time.Duration {
    if d &amp;gt;= 180*24*time.Hour || d == 0 { // 6 months or 0
        return 7 * 24 * time.Hour
    } else if d &amp;gt;= 2*24*time.Hour { // 2 days
        return 1 * 24 * time.Hour
    }
    return 1 * time.Hour
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果创建一个新的 retention policy 设置数据的保留时间为 1 天，则单个 shard 所存储数据的时间间隔为 1 小时，超过1个小时的数据会被存放到下一个 shard 中。&lt;/p&gt;

&lt;h3 id=&#34;组件&#34;&gt;组件&lt;/h3&gt;

&lt;p&gt;TSM 存储引擎主要由几个部分组成： &lt;strong&gt;cache、wal、tsm file、compactor&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-architecture.png&#34; alt=&#34;tsm-architecture&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;shard-1&#34;&gt;Shard&lt;/h4&gt;

&lt;p&gt;shard 并不能算是其中的一个组件，因为这是在 tsm 存储引擎之上的一个概念。在 InfluxDB 中按照数据的时间戳所在的范围，会去创建不同的 shard，每一个 shard 都有自己的 cache、wal、tsm file 以及 compactor，这样做的目的就是为了可以通过时间来快速定位到要查询数据的相关资源，加速查询的过程，并且也让之后的批量删除数据的操作变得非常简单且高效。&lt;/p&gt;

&lt;p&gt;在 LSM Tree 中删除数据是通过给指定 key 插入一个删除标记的方式，数据并不立即删除，需要等之后对文件进行压缩合并时才会真正地将数据删除，所以删除大量数据在 LSM Tree 中是一个非常低效的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而在 InfluxDB 中，通过 retention policy 设置数据的保留时间，当检测到一个 shard 中的数据过期后，只需要将这个 shard 的资源释放，相关文件删除即可，这样的做法使得删除过期数据变得非常高效。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;cache&#34;&gt;Cache&lt;/h4&gt;

&lt;p&gt;cache 相当于是 LSM Tree 中的 memtable，在内存中是一个简单的 map 结构，这里的 key 为 &lt;code&gt;seriesKey + 分隔符 + filedName&lt;/code&gt;，目前代码中的分隔符为 &lt;code&gt;#!~#&lt;/code&gt;，entry 相当于是一个按照时间排序的存放实际值的数组，具体结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Cache struct {
    commit  sync.Mutex
    mu      sync.RWMutex
    store   map[string]*entry
    size    uint64              // 当前使用内存的大小
    maxSize uint64              // 缓存最大值

    // snapshots are the cache objects that are currently being written to tsm files
    // they&#39;re kept in memory while flushing so they can be queried along with the cache.
    // they are read only and should never be modified
    // memtable 快照，用于写入 tsm 文件，只读
    snapshot     *Cache
    snapshotSize uint64
    snapshotting bool

    // This number is the number of pending or failed WriteSnaphot attempts since the last successful one.
    snapshotAttempts int

    stats        *CacheStatistics
    lastSnapshot time.Time
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入数据时，实际上是同时往 cache 与 wal 中写入数据，可以认为 cache 是 wal 文件中的数据在内存中的缓存。当 InfluxDB 启动时，会遍历所有的 wal 文件，重新构造 cache，这样即使系统出现故障，也不会导致数据的丢失。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cache 中的数据并不是无限增长的，有一个 maxSize 参数用于控制当 cache 中的数据占用多少内存后就会将数据写入 tsm 文件。&lt;/strong&gt;如果不配置的话，默认上限为 25MB，每当 cache 中的数据达到阀值后，会将当前的 cache 进行一次快照，之后清空当前 cache 中的内容，再创建一个新的 wal 文件用于写入，剩下的 wal 文件最后会被删除，快照中的数据会经过排序写入一个新的 tsm 文件中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目前的 cache 的设计有一个问题&lt;/strong&gt;，当一个快照正在被写入一个新的 tsm 文件时，当前的 cache 由于大量数据写入，又达到了阀值，此时前一次快照还没有完全写入磁盘，InfluxDB 的做法是让后续的写入操作失败，用户需要自己处理，等待恢复后继续写入数据。&lt;/p&gt;

&lt;h4 id=&#34;wal&#34;&gt;WAL&lt;/h4&gt;

&lt;p&gt;wal 文件的内容与内存中的 cache 相同，其作用就是为了持久化数据，当系统崩溃后可以通过 wal 文件恢复还没有写入到 tsm 文件中的数据。&lt;/p&gt;

&lt;p&gt;由于数据是被顺序插入到 wal 文件中，所以写入效率非常高。但是如果写入的数据没有按照时间顺序排列，而是以杂乱无章的方式写入，数据将会根据时间路由到不同的 shard 中，每一个 shard 都有自己的 wal 文件，这样就不再是完全的顺序写入，对性能会有一定影响。看到官方社区有说后续会进行优化，只使用一个 wal 文件，而不是为每一个 shard 创建 wal 文件。&lt;/p&gt;

&lt;p&gt;wal 单个文件达到一定大小后会进行分片，创建一个新的 wal 分片文件用于写入数据。&lt;/p&gt;

&lt;h4 id=&#34;tsm-file&#34;&gt;TSM file&lt;/h4&gt;

&lt;p&gt;单个 tsm file 大小最大为 2GB，用于存放数据。&lt;/p&gt;

&lt;p&gt;TSM file 使用了自己设计的格式，对查询性能以及压缩方面进行了很多优化，在后面的章节会具体说明其文件结构。&lt;/p&gt;

&lt;h4 id=&#34;compactor&#34;&gt;Compactor&lt;/h4&gt;

&lt;p&gt;compactor 组件在后台持续运行，每隔 1 秒会检查一次是否有需要压缩合并的数据。&lt;/p&gt;

&lt;p&gt;主要进行两种操作，一种是 cache 中的数据大小达到阀值后，进行快照，之后转存到一个新的 tsm 文件中。&lt;/p&gt;

&lt;p&gt;另外一种就是合并当前的 tsm 文件，将多个小的 tsm 文件合并成一个，使每一个文件尽量达到单个文件的最大大小，减少文件的数量，并且一些数据的删除操作也是在这个时候完成。&lt;/p&gt;

&lt;h3 id=&#34;目录与文件结构&#34;&gt;目录与文件结构&lt;/h3&gt;

&lt;p&gt;InfluxDB 的数据存储主要有三个目录。&lt;/p&gt;

&lt;p&gt;默认情况下是 &lt;strong&gt;meta&lt;/strong&gt;, &lt;strong&gt;wal&lt;/strong&gt; 以及 &lt;strong&gt;data&lt;/strong&gt; 三个目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;meta&lt;/strong&gt; 用于存储数据库的一些元数据，&lt;strong&gt;meta&lt;/strong&gt; 目录下有一个 &lt;code&gt;meta.db&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;wal&lt;/strong&gt; 目录存放预写日志文件，以 &lt;code&gt;.wal&lt;/code&gt; 结尾。&lt;strong&gt;data&lt;/strong&gt; 目录存放实际存储的数据文件，以 &lt;code&gt;.tsm&lt;/code&gt; 结尾。这两个目录下的结构是相似的，其基本结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# wal 目录结构
-- wal
   -- mydb
      -- autogen
         -- 1
            -- _00001.wal
         -- 2
            -- _00035.wal
      -- 2hours
         -- 1
            -- _00001.wal

# data 目录结构
-- data
   -- mydb
      -- autogen
         -- 1
            -- 000000001-000000003.tsm
         -- 2
            -- 000000001-000000001.tsm
      -- 2hours
         -- 1
            -- 000000002-000000002.tsm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;strong&gt;mydb&lt;/strong&gt; 是数据库名称，&lt;strong&gt;autogen&lt;/strong&gt; 和 &lt;strong&gt;2hours&lt;/strong&gt; 是存储策略名称，再下一层目录中的以数字命名的目录是 shard 的 ID 值，比如 &lt;strong&gt;autogen&lt;/strong&gt; 存储策略下有两个 shard，ID 分别为 1 和 2，shard 存储了某一个时间段范围内的数据。再下一级的目录则为具体的文件，分别是 &lt;code&gt;.wal&lt;/code&gt; 和 &lt;code&gt;.tsm&lt;/code&gt; 结尾的文件。&lt;/p&gt;

&lt;h4 id=&#34;wal-文件&#34;&gt;WAL 文件&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-wal-entry.png&#34; alt=&#34;wal-entry&#34; /&gt;&lt;/p&gt;

&lt;p&gt;wal 文件中的一条数据，对应的是一个 key(measument + tags + fieldName) 下的所有 value 数据，按照时间排序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Type (1 byte)&lt;/strong&gt;: 表示这个条目中 value 的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Key Len (2 bytes)&lt;/strong&gt;: 指定下面一个字段 key 的长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Key (N bytes)&lt;/strong&gt;: 这里的 key 为 measument + tags + fieldName。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Count (4 bytes)&lt;/strong&gt;: 后面紧跟着的是同一个 key 下数据的个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time (8 bytes)&lt;/strong&gt;: 单个 value 的时间戳。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value (N bytes)&lt;/strong&gt;: value 的具体内容，其中 float64, int64, boolean 都是固定的字节数存储比较简单，通过 Type 字段知道这里 value 的字节数。string 类型比较特殊，对于 string 来说，N bytes 的 Value 部分，前面 4 字节用于存储 string 的长度，剩下的部分才是 string 的实际内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tsm-文件&#34;&gt;TSM 文件&lt;/h4&gt;

&lt;p&gt;单个 tsm 文件的主要格式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file.png&#34; alt=&#34;tsm-file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;主要分为四个部分： &lt;strong&gt;Header, Blocks, Index, Footer&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;其中 &lt;strong&gt;Index&lt;/strong&gt; 部分的内容会被缓存在内存中，下面详细说明一下每一个部分的数据结构。&lt;/p&gt;

&lt;h5 id=&#34;header&#34;&gt;Header&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file-header.png&#34; alt=&#34;tsm-file-header&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MagicNumber  (4 bytes)&lt;/strong&gt;: 用于区分是哪一个存储引擎，目前使用的 tsm1 引擎，MagicNumber 为 &lt;code&gt;0x16D116D1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Version (1 byte)&lt;/strong&gt;: 目前是 tsm1 引擎，此值固定为 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;blocks&#34;&gt;Blocks&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file-blocks.png&#34; alt=&#34;tsm-file-blocks&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Blocks 内部是一些连续的 Block，block 是 InfluxDB 中的最小读取对象，每次读取操作都会读取一个 block。每一个 Block 分为 CRC32 值和 Data 两部分，CRC32 值用于校验 Data 的内容是否有问题。Data 的长度记录在之后的 Index 部分中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data 中的内容根据数据类型的不同，在 InfluxDB 中会采用不同的压缩方式&lt;/strong&gt;，float 值采用了 Gorilla float compression，而 timestamp 因为是一个递增的序列，所以实际上压缩时只需要记录时间的偏移量信息。string 类型的 value 采用了 snappy 算法进行压缩。&lt;/p&gt;

&lt;p&gt;Data 的数据解压后的格式为 8 字节的时间戳以及紧跟着的 value，value 根据类型的不同，会占用不同大小的空间，其中 string 为不定长，会在数据开始处存放长度，这一点和 WAL 文件中的格式相同。&lt;/p&gt;

&lt;h5 id=&#34;index&#34;&gt;Index&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file-index.png&#34; alt=&#34;tsm-file-index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Index 存放的是前面 Blocks 里内容的索引。索引条目的顺序是先按照 key 的字典序排序，再按照 time 排序。InfluxDB 在做查询操作时，可以根据 Index 的信息快速定位到 tsm file 中要查询的 block 的位置。&lt;/p&gt;

&lt;p&gt;这张图只展示了其中一部分，用结构体来表示的话类似下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type BlockIndex struct {
    MinTime     int64
    MaxTime     int64
    Offset      int64
    Size        uint32
}

type KeyIndex struct {
    KeyLen      uint16
    Key         string
    Type        byte
    Count       uint32
    Blocks      []*BlockIndex
}

type Index []*KeyIndex
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Key Len (2 bytes)&lt;/strong&gt;: 下面一个字段 key 的长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Key (N bytes)&lt;/strong&gt;: 这里的 key 指的是 seriesKey + 分隔符 + fieldName。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type (1 bytes)&lt;/strong&gt;: fieldName 所对应的 fieldValue 的类型，也就是 Block 中 Data 内的数据的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Count (2 bytes)&lt;/strong&gt;: 后面紧跟着的 Blocks 索引的个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后面四个部分是 block 的索引信息，根据 Count 中的个数会重复出现，每个 block 索引固定为 28 字节，按照时间排序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Min Time (8 bytes)&lt;/strong&gt;: block 中 value 的最小时间戳。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Max Time (8 bytes)&lt;/strong&gt;: block 中 value 的最大时间戳。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Offset (8 bytes)&lt;/strong&gt;: block 在整个 tsm file 中的偏移量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Size (4 bytes)&lt;/strong&gt;: block 的大小。根据 Offset + Size 字段就可以快速读取出一个 block 中的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;间接索引&#34;&gt;间接索引&lt;/h5&gt;

&lt;p&gt;间接索引只存在于内存中，是为了可以快速定位到一个 key 在详细索引信息中的位置而创建的，可以被用于二分查找来实现快速检索。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file-index-simple.png&#34; alt=&#34;tsm-file-index-simple&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file-sub-index.png&#34; alt=&#34;tsm-file-sub-index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;offsets 是一个数组，其中存储的值为每一个 key 在 Index 表中的位置，由于 key 的长度固定为 2字节，所以根据这个位置就可以找到该位置上对应的 key 的内容。&lt;/p&gt;

&lt;p&gt;当指定一个要查询的 key 时，就可以通过二分查找，定位到其在 Index 表中的位置，再根据要查询的数据的时间进行定位，由于 KeyIndex  中的 BlockIndex 结构是定长的，所以也可以进行一次二分查找，找到要查询的数据所在的 BlockIndex 的内容，之后根据偏移量以及 block 长度就可以从 tsm 文件中快速读取出一个 block 的内容。&lt;/p&gt;

&lt;h5 id=&#34;footer&#34;&gt;Footer&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-08-05-detailed-in-influxdb-tsm-storage-engine-one-tsm-file-footer.png&#34; alt=&#34;tsm-file-footer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;tsm file 的最后8字节的内容存放了 Index 部分的起始位置在 tsm file 中的偏移量，方便将索引信息加载到内存中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于内容较多，具体的写入与查询操作的流程，以及部分代码的详解会在下一篇文章中介绍。&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>golang 中使用 statik 将静态资源编译进二进制文件中</title>
          <link>http://blog.fatedier.com/2016/08/01/compile-assets-into-binary-file-with-statik-in-golang</link>
          <pubDate>Mon, 01 Aug 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/08/01/compile-assets-into-binary-file-with-statik-in-golang</guid>
          <description>

&lt;p&gt;现在的很多程序都会提供一个 Dashboard 类似的页面用于查看程序状态并进行一些管理的功能，通常都不会很复杂，但是其中用到的图片和网页的一些静态资源，如果需要用户额外存放在一个目录，也不是很方便，如果能打包进程序发布的二进制文件中，用户下载以后可以直接使用，就方便很多。&lt;/p&gt;

&lt;p&gt;最近在阅读 InfluxDB 的源码，发现里面提供了一个 admin 管理的页面，可以通过浏览器来执行一些命令以及查看程序运行的信息。但是我运行的时候只运行了一个 influxd 的二进制文件，并没有看到 css, html 等文件。&lt;/p&gt;

&lt;p&gt;原来 InfluxDB 中使用了 statik 这个工具将静态资源都编译进了二进制文件中，这样用户只需要运行这个程序即可，而不需要管静态资源文件存放的位置。&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;先下载并安装 statik 这个工具&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go get -d github.com/rakyll/statik&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go install github.com/rakyll/statik&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意将 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 加入到 PATH 环境变量中。&lt;/p&gt;

&lt;h3 id=&#34;创建测试项目&#34;&gt;创建测试项目&lt;/h3&gt;

&lt;p&gt;创建一个测试用的 golang 项目，这里假设目录为 &lt;code&gt;$GOPATH/src/test/testStatikFS&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;创建一个 assets 目录用于放静态资源文件。包括 &lt;code&gt;./assets/a&lt;/code&gt; 和 &lt;code&gt;./assets/tmp/b&lt;/code&gt; 两个文件，文件内容分别为 &lt;code&gt;aaa&lt;/code&gt; 和 &lt;code&gt;bbb&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;创建 main.go 文件，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//go:generate statik -src=./assets
//go:generate go fmt statik/statik.go

package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;os&amp;quot;

    _ &amp;quot;test/testStatikFS/statik&amp;quot;
    &amp;quot;github.com/rakyll/statik/fs&amp;quot;
)

// Before buildling, run go generate.
func main() {
    statikFS, err := fs.New()
    if err != nil {
        fmt.Printf(&amp;quot;err: %v\n&amp;quot;, err)
        os.Exit(1)
    }   

    file, err := statikFS.Open(&amp;quot;/tmp/b&amp;quot;)
    if err != nil {
        fmt.Printf(&amp;quot;err: %v\n&amp;quot;, err)
        os.Exit(1)
    }   
    content, err := ioutil.ReadAll(file)
    if err != nil { 
        fmt.Printf(&amp;quot;err: %v\n&amp;quot;, err)
        os.Exit(1)
    }   
    fmt.Printf(&amp;quot;content: %s\n&amp;quot;, content)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意文件最开始的两行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//go:generate statik -src=./assets
//go:generate go fmt statik/statik.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个注释是告诉 &lt;code&gt;go generate&lt;/code&gt; 需要执行的命令，之后就可以通过 &lt;code&gt;go generate&lt;/code&gt; 生成我们需要的 go 文件。&lt;/p&gt;

&lt;p&gt;这段代码的功能就是从 &lt;strong&gt;statikFS&lt;/strong&gt; 提供的文件系统接口中获取 &lt;code&gt;/tmp/b&lt;/code&gt; 这个文件的内容并输出，可以看到操作起来和操作普通文件的方法基本一致。&lt;/p&gt;

&lt;h3 id=&#34;将静态资源打包成-go-文件&#34;&gt;将静态资源打包成 go 文件&lt;/h3&gt;

&lt;p&gt;执行 &lt;code&gt;go generate&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在项目目录下执行这个命令会生成一个 &lt;strong&gt;statik&lt;/strong&gt; 目录，里面存放的是自动生成的 go 文件，将所有 &lt;code&gt;./assets&lt;/code&gt; 下的文件变成了一个压缩后的字符串放在了这个文件中，并且在程序启动时会解析这个字符串，构造一个 &lt;strong&gt;http.FileSystem&lt;/strong&gt; 对象，之后就可以使用对文件系统类似的操作来获取文件内容。&lt;/p&gt;

&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go build -o test ./main.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 main.go 中我们 import 了两个包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ &amp;quot;test/testStatikFS/statik&amp;quot;
&amp;quot;github.com/rakyll/statik/fs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个就是 &lt;code&gt;go generate&lt;/code&gt; 自动生成的目录，其中只有一个 &lt;code&gt;init()&lt;/code&gt; 函数，初始化相关的资源，我们不需要调用这个包里面的函数，只执行 &lt;code&gt;init()&lt;/code&gt; 函数，所以在包名前加上 &lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;

&lt;p&gt;运行编译后的文件： &lt;code&gt;./test&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;输出了文件 &lt;code&gt;./assets/tmp/b&lt;/code&gt; 中的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;content: bbb
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文件系统接口&#34;&gt;文件系统接口&lt;/h3&gt;

&lt;p&gt;由于 statik 实现了标准库中的 http.FileSystem 接口，所以也可以直接使用 http 包提供静态资源的访问服务，关键部分代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;github.com/rakyll/statik/fs&amp;quot;

    _ &amp;quot;./statik&amp;quot; // TODO: Replace with the absolute import path
)

// ...

statikFS, _ := fs.New()
http.ListenAndServe(&amp;quot;:8080&amp;quot;, http.FileServer(statikFS))
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用gvm在不同go版本之间切换</title>
          <link>http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm</link>
          <pubDate>Mon, 25 Jul 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm</guid>
          <description>

&lt;p&gt;Centos7上通过 yum 从 epel 仓库里直接安装的 go 版本还是 1.4.2，从源码编译安装最新的 go 版本比较麻烦，而且开发中有时需要调试在不同编译环境下可能存在的问题，不能忽略使用最新版本是存在某些 bug 的可能性。&lt;/p&gt;

&lt;p&gt;Go 的更新速度比较快，2015年8月发布 1.5 版本，2016年2月发布 1.6 版本，2016年8月即将发布 1.7 版本，在性能以及GC方便都在不断优化，及时更新到新版本的 go 很有优势。&lt;/p&gt;

&lt;h3 id=&#34;go-版本切换的问题&#34;&gt;Go 版本切换的问题&lt;/h3&gt;

&lt;p&gt;二进制文件的管理比较简单，通过链接使用不同版本的程序即可，实际上主要是一些环境变量和标准库的设置问题，环境变量主要是 &lt;code&gt;GOPATH&lt;/code&gt; 以及 &lt;code&gt;GOROOT&lt;/code&gt;，标准库的话需要在切换 go 版本时也能跟着切换。&lt;strong&gt;gvm&lt;/strong&gt; 实际上就是帮助完成这些配置工作。&lt;/p&gt;

&lt;h3 id=&#34;安装-gvm&#34;&gt;安装 gvm&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;gvm&lt;/strong&gt; 的项目地址：&lt;a href=&#34;https://github.com/moovweb/gvm&#34;&gt;https://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash &amp;lt;&amp;lt; (curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你使用的是 &lt;code&gt;zsh&lt;/code&gt; 的话将前面的 &lt;code&gt;bash&lt;/code&gt; 改为 &lt;code&gt;zsh&lt;/code&gt; 即可，这条命令主要是下载 &lt;strong&gt;gvm&lt;/strong&gt; 相关的文件，创建所需目录，并且在 &lt;code&gt;.bashrc&lt;/code&gt; 或者 &lt;code&gt;.zshrc&lt;/code&gt; 中加入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[[ -s &amp;quot;/home/wcl/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;/home/wcl/.gvm/scripts/gvm&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使每次登录 shell 时都可以生效。&lt;/p&gt;

&lt;h3 id=&#34;安装指定-go-版本&#34;&gt;安装指定 go 版本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gvm install go1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意这里实际上是先执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://go.googlesource.com/go $GVM_ROOT/archive/go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个网站在墙外。&lt;/p&gt;

&lt;p&gt;我们可以通过配置使 git 可以通过 http 代理访问，修改 &lt;code&gt;.gitconfig&lt;/code&gt; 文件，加上 http 代理服务器的地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[http]
        proxy = http://[proxydomain]:[port]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载成功后，有可能提示编译失败，因为 go1.6.3 需要依赖于 go1.4 来编译，需要设置 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 变量。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;go env&lt;/code&gt; 查看 &lt;code&gt;GOROOT&lt;/code&gt; 的路径，通常 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 就设置成 &lt;code&gt;GOROOT&lt;/code&gt;，centos7 下需要注意 /usr/lib/golang/bin 下并没有 &lt;code&gt;go&lt;/code&gt; 的二进制文件，通过 cp 命令复制一个过去。&lt;/p&gt;

&lt;p&gt;之后再次执行 &lt;code&gt;gvm install go1.6.3&lt;/code&gt; 即可安装完成。&lt;/p&gt;

&lt;h3 id=&#34;修改配置信息方便使用&#34;&gt;修改配置信息方便使用&lt;/h3&gt;

&lt;p&gt;最初测试时发现每次切换 go 版本后都会被修改 &lt;code&gt;GOPATH&lt;/code&gt; 变量，而实际上我并不需要这个功能，只是希望用新版本来编译已有的项目，所以我们需要把 &lt;code&gt;~/.gvm/environments&lt;/code&gt; 文件夹下所有 &lt;code&gt;GOPATH&lt;/code&gt; 的设置全部删除。&lt;/p&gt;

&lt;p&gt;另外还需要将 &lt;code&gt;~/.zshrc&lt;/code&gt; 或者 &lt;code&gt;~/.bashrc&lt;/code&gt; 中的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[[ -s &amp;quot;~/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;~/.gvm/scripts/gvm&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移到设置 &lt;code&gt;GOPATH&lt;/code&gt; 变量之前，避免登录 shell 之后被修改 &lt;code&gt;GOPATH&lt;/code&gt; 变量。&lt;/p&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;h4 id=&#34;切换到安装好的指定-go-版本&#34;&gt;切换到安装好的指定 go 版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use go1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;go version&lt;/code&gt; 可以看到已经是新版本的二进制文件，通过 &lt;code&gt;go env&lt;/code&gt; 可以查看 &lt;code&gt;GOROOT&lt;/code&gt; 信息，例如我的就是 &lt;code&gt;~/.gvm/gos/go1.6.3&lt;/code&gt;，这样编译项目时就会在这个目录下找标准库中的文件。&lt;/p&gt;

&lt;h4 id=&#34;切换到原来的系统版本&#34;&gt;切换到原来的系统版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use system&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;查看当前已经安装的所有版本&#34;&gt;查看当前已经安装的所有版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gvm gos (installed)

=&amp;gt; go1.6.3
   system
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;设置某个版本为默认&#34;&gt;设置某个版本为默认&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use go1.6.3 --default&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样设置后，再登录 shell 就默认使用 &lt;code&gt;go1.6.3&lt;/code&gt; 的版本，而不是系统原来的版本了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>go程序中dns解析无法使用所有域名服务器</title>
          <link>http://blog.fatedier.com/2016/04/27/go-program-does-not-use-all-nameservers-for-dns-lookups</link>
          <pubDate>Wed, 27 Apr 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/04/27/go-program-does-not-use-all-nameservers-for-dns-lookups</guid>
          <description>

&lt;p&gt;最近线上服务经常会出现异常，从错误日志来看是因为域名解析失败导致的，我们在 /etc/resolv.conf 中配置了多个域名服务器，第一个是内网的，用于解析内网域名，如果是外网域名，则会通过其他的域名服务器进行解析，按道理来说应该不会有问题，但是最近却频繁发生这样的故障，为了彻底解决问题，特意研究了一下 golang 中进行 dns 查询的源码并最终解决了此问题。&lt;/p&gt;

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;h4 id=&#34;nameserver-配置&#34;&gt;nameserver 配置&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中配置了多个 nameserver&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nameserver 10.10.100.3
nameserver 114.114.114.114
nameserver 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;10.10.100.3&lt;/code&gt; 用于解析内网域名，外网域名通过 &lt;code&gt;114.114.114.114&lt;/code&gt; 或者 &lt;code&gt;8.8.8.8&lt;/code&gt; 来解析。&lt;/p&gt;

&lt;h4 id=&#34;测试代码&#34;&gt;测试代码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
    &amp;quot;net&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func main() {
    hostname := &amp;quot;www.baidu.com&amp;quot;
    addrs, err := net.LookupHost(hostname)
    if err != nil {
        fmt.Printf(&amp;quot;lookup host error: %v\n&amp;quot;, err)
    } else {
        fmt.Printf(&amp;quot;addrs: %v&amp;quot;, addrs)
    }   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;结果&#34;&gt;结果&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lookup host error: lookup www.baidu.com on 10.10.100.3:53: no such host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 go1.5 版本进行编译，发现程序并没有按照预想的过程来解析，通过 &lt;code&gt;10.10.100.3&lt;/code&gt; 无法解析后就直接返回了错误信息。&lt;/p&gt;

&lt;p&gt;而使用 go1.4 版本编译运行后，确得到了正确的结果。&lt;/p&gt;

&lt;h3 id=&#34;调试标准库的方法&#34;&gt;调试标准库的方法&lt;/h3&gt;

&lt;p&gt;调试 golang 的标准库非常简单，先找到标准库源码的存放位置，然后将要修改的文件备份一份，之后直接在其中添加输出语句，大部分可以 &lt;code&gt;import &amp;quot;fmt&amp;quot;&lt;/code&gt; 后使用 &lt;code&gt;fmt.Printf&lt;/code&gt; 函数进行输出，有的包中需要使用其他方式，避免循环引用，这里不详述，因为我们要改的 &lt;code&gt;net&lt;/code&gt; 包并不涉及这个问题，注意调试完之后将标准库的文件恢复。&lt;/p&gt;

&lt;h4 id=&#34;查找标准库所在的目录&#34;&gt;查找标准库所在的目录&lt;/h4&gt;

&lt;p&gt;执行 &lt;code&gt;go env&lt;/code&gt; 查看 go 的环境变量如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOARCH=&amp;quot;amd64&amp;quot;
GOBIN=&amp;quot;&amp;quot;GOCHAR=&amp;quot;6&amp;quot;GOEXE=&amp;quot;&amp;quot;GOHOSTARCH=&amp;quot;amd64&amp;quot;GOHOSTOS=&amp;quot;linux&amp;quot;GOOS=&amp;quot;linux&amp;quot;
GOPATH=&amp;quot;/home/wcl/go_projects&amp;quot;
GORACE=&amp;quot;&amp;quot;
GOROOT=&amp;quot;/usr/lib/golang&amp;quot;
GOTOOLDIR=&amp;quot;/usr/lib/golang/pkg/tool/linux_amd64&amp;quot;
CC=&amp;quot;gcc&amp;quot;
GOGCCFLAGS=&amp;quot;-fPIC -m64 -pthread -fmessage-length=0&amp;quot;
CXX=&amp;quot;g++&amp;quot;
CGO_ENABLED=&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GOROOT&lt;/strong&gt; 的值即是标准库所在的目录，&lt;code&gt;net&lt;/code&gt; 包的具体路径为 &lt;code&gt;/usr/lib/golang/src/net&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-1-4-与-1-5-版本中-dns-查询逻辑的不同&#34;&gt;go 1.4 与 1.5 版本中 dns 查询逻辑的不同&lt;/h3&gt;

&lt;p&gt;因为最近很多程序都是使用 &lt;strong&gt;go1.5&lt;/strong&gt; 版本进行编译的，所以理所当然查看了两个版本这部分源码的区别，还真的有所改变。&lt;/p&gt;

&lt;p&gt;标准库对外暴露的 dns 查询函数是 &lt;code&gt;func LookupHost(host string) (addrs []string, err error)&lt;/code&gt; &lt;strong&gt;(net/lookup.go)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个函数会调用实际处理函数 &lt;code&gt;lookupHost&lt;/code&gt; &lt;strong&gt;(net/lookup_unix.go)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;cgo-与纯-go-实现的-dns-查询&#34;&gt;cgo 与纯 go 实现的 dns 查询&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;go1.4 版本源码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func lookupHost(host string) (addrs []string, err error) {
    addrs, err, ok := cgoLookupHost(host)
    if !ok {
        addrs, err = goLookupHost(host)
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;go1.5 版本源码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func lookupHost(host string) (addrs []string, err error) {
    order := systemConf().hostLookupOrder(host)
    if order == hostLookupCgo {
        if addrs, err, ok := cgoLookupHost(host); ok {
            return addrs, err
        }
        // cgo not available (or netgo); fall back to Go&#39;s DNS resolver
        order = hostLookupFilesDNS
    }
    return goLookupHostOrder(host, order)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可以明显的看到 1.4 的源码中默认使用 cgo 的方式进行 dns 查询&lt;/strong&gt;（这个函数最终会创建一个线程调用c的 getaddrinfo 函数来获取 dns 查询结果），如果查询失败则会再使用纯 go 实现的查询方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而在 1.5 的源码中，这一点有所改变，cgo 的方式不再是默认值，而是根据 &lt;code&gt;systemConf().hostLookupOrder(host)&lt;/code&gt; 的返回值来判断具体使用哪种方式&lt;/strong&gt;。这个函数定义在 &lt;strong&gt;net/conf.go&lt;/strong&gt; 中，稍微看了一下， 除非通过编译标志强制使用 cgo 方式或者在某些特定的系统上会使用 cgo 方式，其他时候都使用纯 go 实现的查询方式。&lt;/p&gt;

&lt;p&gt;cgo 的方式没有问题，看起来程序会并发地向 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中所有配置的域名服务器发送 dns 解析请求，然后将最先成功响应的结果返回。&lt;/p&gt;

&lt;h4 id=&#34;纯-go-实现的-dns-查询分析&#34;&gt;纯 go 实现的 dns 查询分析&lt;/h4&gt;

&lt;p&gt;问题就出在纯 go 实现的查询上，主要看一下 go1.5 的实现。&lt;/p&gt;

&lt;p&gt;函数调用逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;LookupHost (net/lookup.go)
    lookupHost  (net/lookup_unix.go)
        goLookupHostOrder  (net/dnsclient_unix.go)
            goLookupIPOrder  (net/dnsclient_unix.go)
                tryOneName   (net/dnsclient_unix.go)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分实现代码在 &lt;code&gt;net/dnsclient_unix.go&lt;/code&gt; 这个文件中。&lt;/p&gt;

&lt;p&gt;重点看一下 &lt;code&gt;tryOneName&lt;/code&gt; 这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func tryOneName(cfg *dnsConfig, name string, qtype uint16) (string, []dnsRR, error) {
    if len(cfg.servers) == 0 {
        return &amp;quot;&amp;quot;, nil, &amp;amp;DNSError{Err: &amp;quot;no DNS servers&amp;quot;, Name: name}
    }
    if len(name) &amp;gt;= 256 {
        return &amp;quot;&amp;quot;, nil, &amp;amp;DNSError{Err: &amp;quot;DNS name too long&amp;quot;, Name: name}
    }
    timeout := time.Duration(cfg.timeout) * time.Second
    var lastErr error
    for i := 0; i &amp;lt; cfg.attempts; i++ {
        for _, server := range cfg.servers {
            server = JoinHostPort(server, &amp;quot;53&amp;quot;)
            msg, err := exchange(server, name, qtype, timeout)
            if err != nil {
                lastErr = &amp;amp;DNSError{
                    Err:    err.Error(),
                    Name:   name,
                    Server: server,
                }
                if nerr, ok := err.(Error); ok &amp;amp;&amp;amp; nerr.Timeout() {
                    lastErr.(*DNSError).IsTimeout = true
                }
                continue
            }
            cname, rrs, err := answer(name, server, msg, qtype)
            if err == nil || msg.rcode == dnsRcodeSuccess || msg.rcode == dnsRcodeNameError &amp;amp;&amp;amp; msg.recursion_available {
                return cname, rrs, err
            }
            lastErr = err
        }
    }
    return &amp;quot;&amp;quot;, nil, lastErr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一层 for 循环是尝试的次数，第二层 for 循环是遍历 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中配置的所有域名服务器，&lt;code&gt;exchange&lt;/code&gt; 函数是发送 dns 查询请求并将响应结果解析到 &lt;code&gt;msg&lt;/code&gt; 变量中返回，初看到这里，觉得实现是没问题的，顺序向每一个域名服务器发送 dns 查询请求，如果成功就返回，如果失败就尝试下一个。&lt;/p&gt;

&lt;p&gt;问题出现在判断是否成功的那一行代码 &lt;code&gt;if err == nil || msg.rcode == dnsRcodeSuccess || msg.rcode == dnsRcodeNameError &amp;amp;&amp;amp; msg.recursion_available&lt;/code&gt;，这里的意思是如果 dns 查询成功，或者出错了但是对方支持递归查询的话，就直接返回，不继续请求下一个域名服务器。如果对方支持递归查询但是仍然没有查到的话，说明上级服务器也没有这个域名的记录，没有必要继续往下查。（这个逻辑在 go1.6 版本中被修改了，出错了以后不再判断是否支持递归查询，仍然尝试向下一个域名服务器发送请求）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;msg.rcode&lt;/code&gt; 这个值很重要，是问题的关键。&lt;/p&gt;

&lt;h3 id=&#34;dns-查询协议格式&#34;&gt;dns 查询协议格式&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-04-27-go-program-does-not-use-all-nameservers-for-dns-lookups-dns-query-package.png&#34; alt=&#34;dns-query-package&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要关注首部的12字节。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID:占16位，2个字节。此报文的编号，由客户端指定。DNS回复时带上此标识，以指示处理的对应请应请求。&lt;/li&gt;
&lt;li&gt;QR:占1位，1/8字节。0代表查询，1代表DNS回复&lt;/li&gt;
&lt;li&gt;Opcode:占4位，1/2字节。指示查询种类：0:标准查询；1:反向查询；2:服务器状态查询；3-15:未使用。&lt;/li&gt;
&lt;li&gt;AA:占1位，1/8字节。是否权威回复。&lt;/li&gt;
&lt;li&gt;TC:占1位，1/8字节。因为一个UDP报文为512字节，所以该位指示是否截掉超过的部分。&lt;/li&gt;
&lt;li&gt;RD:占1位，1/8字节。此位在查询中指定，回复时相同。设置为1指示服务器进行递归查询。&lt;/li&gt;
&lt;li&gt;RA:占1位，1/8字节。由DNS回复返回指定，说明DNS服务器是否支持递归查询。&lt;/li&gt;
&lt;li&gt;Z:占3位，3/8字节。保留字段，必须设置为0。&lt;/li&gt;
&lt;li&gt;RCODE:占4位，1/2字节。由回复时指定的返回码：0:无差错；1:格式错；2:DNS出错；3:域名不存在；4:DNS不支持这类查询；5:DNS拒绝查询；6-15:保留字段。　&lt;/li&gt;
&lt;li&gt;QDCOUNT:占16位，2字节。一个无符号数指示查询记录的个数。&lt;/li&gt;
&lt;li&gt;ANCOUNT:占16位，2字节。一个无符号数指明回复记录的个数。&lt;/li&gt;
&lt;li&gt;NSCOUNT:占16位，2字节。一个无符号数指明权威记录的个数。&lt;/li&gt;
&lt;li&gt;ARCOUNT:占16位，2字节。一个无符号数指明格外记录的个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中 &lt;strong&gt;RCODE&lt;/strong&gt; 是回复时用于判断查询结果是否成功的，对应前面的 &lt;code&gt;msg.rcode&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;bind-的-dns-回复问题&#34;&gt;bind 的 dns 回复问题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;10.10.100.3&lt;/code&gt; 上是使用 &lt;strong&gt;bind&lt;/strong&gt; 搭建的本地域名服务器。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;dig @10.10.100.3 www.baidu.com&lt;/code&gt; 命令查看解析结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @10.10.100.3 www.baidu.com ;
(1 server found) 
;; global options: +cmd 
;; Got answer: 
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 55909 
;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 13, ADDITIONAL: 0 
;; WARNING: recursion requested but not available 

;; QUESTION SECTION: 
;www.baidu.com.         IN  A 

;; AUTHORITY SECTION: 
.           518400  IN  NS  H.ROOT-SERVERS.NET.  
.           518400  IN  NS  K.ROOT-SERVERS.NET.  
.           518400  IN  NS  C.ROOT-SERVERS.NET.  
.           518400  IN  NS  A.ROOT-SERVERS.NET.  
.           518400  IN  NS  B.ROOT-SERVERS.NET.  
.           518400  IN  NS  F.ROOT-SERVERS.NET.  
.           518400  IN  NS  L.ROOT-SERVERS.NET.  
.           518400  IN  NS  D.ROOT-SERVERS.NET.  
.           518400  IN  NS  I.ROOT-SERVERS.NET.  
.           518400  IN  NS  E.ROOT-SERVERS.NET.  
.           518400  IN  NS  G.ROOT-SERVERS.NET.  
.           518400  IN  NS  M.ROOT-SERVERS.NET.  
.           518400  IN  NS  J.ROOT-SERVERS.NET.  

;; Query time: 1 msec 
;; SERVER: 10.10.100.3#53(10.10.100.3) 
;; WHEN: Wed Apr 27 17:35:15 2016 
;; MSG SIZE  rcvd: 242 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bind&lt;/strong&gt; 并没有返回 &lt;code&gt;www.baidu.com&lt;/code&gt; 的 A 记录，而是返回了13个根域名服务器的地址，并且 &lt;strong&gt;status&lt;/strong&gt; 的状态是 &lt;strong&gt;NOERROR&lt;/strong&gt;（这个值就是前述的 &lt;strong&gt;RCODE&lt;/strong&gt;，这里返回0表示没有错误)，问题就在这里，没有查到 A 记录还返回 &lt;code&gt;RCODE=0&lt;/code&gt;，回顾一下上面 go 代码中的判断条件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if err == nil || msg.rcode == dnsRcodeSuccess || msg.rcode == dnsRcodeNameError &amp;amp;&amp;amp; msg.recursion_available&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果返回的 &lt;strong&gt;RCODE&lt;/strong&gt; 值为 0，则直接退出，不继续尝试后面的域名服务器，从而导致了域名解析失败。&lt;/p&gt;

&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;

&lt;h4 id=&#34;仍然使用-go1-4-版本进行编译&#34;&gt;仍然使用 go1.4 版本进行编译&lt;/h4&gt;

&lt;p&gt;不推荐这么做，毕竟升级后在 gc 以及很多其他方面都有优化。&lt;/p&gt;

&lt;h4 id=&#34;使用-go1-5-及以上版本编译但是通过环境变量强制使用-cgo-的-dns-查询方式&#34;&gt;使用 go1.5 及以上版本编译但是通过环境变量强制使用 cgo 的 dns 查询方式&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;export GODEBUG=netdns=cgo go build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 cgo 的方式会在每一次调用时创建一个线程，在并发量较大时可能会对系统资源造成一定影响。而且需要每一个使用 go 编写的程序编译时都加上此标志，较为繁琐。&lt;/p&gt;

&lt;h4 id=&#34;修改-bind-的配置文件&#34;&gt;修改 bind 的配置文件&lt;/h4&gt;

&lt;p&gt;在 &lt;strong&gt;bind&lt;/strong&gt; 中彻底关闭对递归查询的支持也可以解决此问题，但是由于对 &lt;strong&gt;bind&lt;/strong&gt; 不是很熟悉，具体是什么原因导致没有查到 &lt;strong&gt;A 记录&lt;/strong&gt;但仍然返回 &lt;strong&gt;NOERROR&lt;/strong&gt; 不是很清楚，猜测可能和递归转发的查询方式有关，有可能 &lt;strong&gt;bind&lt;/strong&gt; 认为返回了根域名服务器的地址，&lt;strong&gt;client&lt;/strong&gt; 可以去这些地址上查，所以该次请求并不算做出错。&lt;/p&gt;

&lt;p&gt;修改配置文件加上以下内容以后，再次查询时会返回 &lt;strong&gt;RCODE=5&lt;/strong&gt;，拒绝递归查询，这样可以达到我们的目的，查询非内网域名时通过其他域名服务器查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;recursion no;
allow-query-cache { none; };
allow-recursion { none; };
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>如何使golang项目可以在任意目录下编译</title>
          <link>http://blog.fatedier.com/2016/02/25/how-to-compile-go-project-in-any-directory</link>
          <pubDate>Thu, 25 Feb 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/02/25/how-to-compile-go-project-in-any-directory</guid>
          <description>

&lt;p&gt;通常我们将golang项目直接放在 $GOPATH/src 目录下，所有 import 的包的路径也是相对于 GOPATH 的。我在开发 frp（一个可以用于穿透内网的反向代理工具）的时候就遇到一个比较小但是挺棘手的问题，需要使这个项目可以在任意目录里被编译，方便其他成员不需要做额外的操作就可以一同开发，这里分享一下解决的方法。&lt;/p&gt;

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fatedier/frp&#34;&gt;frp&lt;/a&gt; 是我业余时间写的一个用于穿透内网的反向代理工具，可以将防火墙内或内网环境的机器对外暴露指定的服务，例如22端口提供ssh服务或者80端口提供一个临时的web测试环境。&lt;/p&gt;

&lt;p&gt;一开始项目是直接放在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 目录下的，第三方包的引用是 &lt;code&gt;import github.com/xxx/xxx&lt;/code&gt;，内部包的引用 &lt;code&gt;import frp/xxx&lt;/code&gt;，这样编译时内部包的查找路径实际上就是 &lt;code&gt;$GOPATH/src/frp/xxx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;后来由于使用了 &lt;a href=&#34;https://travis-ci.org/&#34;&gt;travis-ci&lt;/a&gt; 做持续集成，travis-ci 中是直接使用 &lt;code&gt;go get github.com/fatedier/frp&lt;/code&gt; 下载代码，然后编译运行。这样问题就来了，通过 go get 下载的源码在本地的路径是 &lt;code&gt;$GOPATH/src/github.com/fatedier/frp&lt;/code&gt;，内部包就找不到了，导致编译失败。&lt;/p&gt;

&lt;h3 id=&#34;使用类似第三方包的引用方式&#34;&gt;使用类似第三方包的引用方式&lt;/h3&gt;

&lt;p&gt;解决这个问题最直接的方法就是将内部包的引用方式修改成 &lt;code&gt;import github.com/fatedier/frp/xxx&lt;/code&gt;，在 travis-ci 中编译的时候就可以通过了，同时需要注意把自己本地的项目路径也更换成&lt;code&gt;$GOPATH/src/github.com/fatedier/frp&lt;/code&gt;，很多开源项目都是用的这种方式引用内部包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：不推荐使用 ./ ../ 等相对路径来引用内部包，这样管理和定位问题其实都不是很方便。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;之后由于需要其他人共同开发，fork了我的项目之后，他们也使用 go get 下载他们fork后的项目源码，这样 &lt;code&gt;fatedier&lt;/code&gt; 就替换成了他们自己的用户名，但是代码中 import 的包名并没有改变，会导致他们无法编译通过。当然，他们可以将项目再放到正确的目录，但是多了一部操作总归不方便。&lt;/p&gt;

&lt;h3 id=&#34;比较tricky的做法-修改gopath&#34;&gt;比较tricky的做法，修改GOPATH&lt;/h3&gt;

&lt;p&gt;其实问题的关键就在于 &lt;code&gt;GOPATH&lt;/code&gt; 这个环境变量，这个变量决定了查找包的绝对路径。我们在项目根目录下建立 &lt;code&gt;src/frp&lt;/code&gt; 这样的目录结构，之后将原来的源代码放到这个目录下，然后内部包的应用方式还是改成 &lt;code&gt;import frp/xxx&lt;/code&gt; 这种简洁的格式。&lt;/p&gt;

&lt;p&gt;编译的时候，把项目根目录加到 &lt;code&gt;GOPATH&lt;/code&gt; 中去，例如 &lt;code&gt;GOPATH=`pwd`:${GOPATH}&lt;/code&gt;，这样就会在自己的目录里查找内部包。&lt;/p&gt;

&lt;p&gt;可以看到，通过这样的方式不管把你把项目放到哪一个目录下，都可以编译成功，当然，为了便于管理，推荐还是放在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 目录下，同时使用 &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;godep&lt;/a&gt; 来管理第三方包。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Go中如何优雅地关闭net.Listener</title>
          <link>http://blog.fatedier.com/2016/02/19/how-to-shutdown-go-net-dot-listeners-gracefully</link>
          <pubDate>Fri, 19 Feb 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/02/19/how-to-shutdown-go-net-dot-listeners-gracefully</guid>
          <description>&lt;p&gt;在开发一个 Go 语言写的服务器项目的时候，遇到一个很有意思的问题，这个程序会根据客户端的请求动态的监听本地的一个端口，并且与客户端交互结束后需要释放这个端口。Go 的标准库提供了常用的接口，开发网络服务非常方便，网上随便就可以找到很多样例代码。&lt;/p&gt;

&lt;p&gt;但是我在释放这个监听端口的时候遇到了一些问题，我发现很难优雅地去关闭这个 &lt;strong&gt;net.Listener&lt;/strong&gt;。在网上查阅了一下资料，基本上都是程序结束时资源被系统自动回收，没发现有需要主动释放的。这个需求确实不多，不过想一下在写测试用例的时候或许可能会用到，我们先创建一个 &lt;strong&gt;net.Listener&lt;/strong&gt; 监听一个端口，&lt;strong&gt;client&lt;/strong&gt; 发送请求进行测试，通过后关闭这个 &lt;strong&gt;net.Listener&lt;/strong&gt;，再创建另外一个 &lt;strong&gt;net.Listener&lt;/strong&gt; 用于测试其他用例。&lt;/p&gt;

&lt;p&gt;初步思考了一下有两个办法来关闭 &lt;strong&gt;net.Listener&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置一个结束标志，为 &lt;strong&gt;net.Listener&lt;/strong&gt; 的 &lt;code&gt;accept&lt;/code&gt; 设置超时，&lt;strong&gt;net.Listener&lt;/strong&gt; 提供了一个 &lt;code&gt;SetDeadline(t time.Time)&lt;/code&gt; 接口，需要关闭时将标志置为 &lt;strong&gt;true&lt;/strong&gt;，每次超时后检查一下结束标志，如果为 &lt;strong&gt;true&lt;/strong&gt; 则退出。&lt;/li&gt;
&lt;li&gt;在另外一个协程中 &lt;strong&gt;close net.Listener&lt;/strong&gt;，检查 &lt;code&gt;accept&lt;/code&gt; 返回的 &lt;strong&gt;error&lt;/strong&gt; 信息，如果是被 &lt;strong&gt;close&lt;/strong&gt; 的话就退出，其他情况就继续。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个方法很显然不够优雅，在大并发量连接请求时对效率有很大影响，而且退出机制是延迟的，不能及时退出。&lt;/p&gt;

&lt;p&gt;第二个方法的问题就在于如果 &lt;strong&gt;close net.Listener&lt;/strong&gt;，&lt;code&gt;accept&lt;/code&gt; 函数返回的 &lt;strong&gt;error&lt;/strong&gt; 信息只能拿到错误的字符串信息，如果是被 &lt;strong&gt;close&lt;/strong&gt; 的话返回的信息是：&lt;code&gt;use of closed network connection&lt;/code&gt;，这个时候退出监听，如果是其他错误，则继续监听。想法是好的，然而并不能用错误信息的字符串来判断是哪一种类型的错误，有可能以后的版本中错误信息字符串变更也说不定，最好不要在代码中写死。这个 &lt;strong&gt;error&lt;/strong&gt; 其实是有类型的，在标准库中是 &lt;code&gt;errClosing&lt;/code&gt;，开头小写，说明只能在包内部使用，我们没有办法使用这个类型来判断具体是哪一种错误。个人觉得这方面可能还没有 &lt;strong&gt;c语言&lt;/strong&gt; 中通过 &lt;strong&gt;errno&lt;/strong&gt; 的值来判断是哪一种类型的错误来的方便。&lt;/p&gt;

&lt;p&gt;既然不能通过 &lt;strong&gt;error&lt;/strong&gt; 的字符串信息判断是哪一种错误，那么我们只能用类似第一个方法中使用的标志来判断了，先将结束标志置为 &lt;strong&gt;true&lt;/strong&gt;，之后 &lt;strong&gt;close net.Listener&lt;/strong&gt;，&lt;code&gt;accept&lt;/code&gt; 函数返回 &lt;code&gt;error != nil&lt;/code&gt; 时，检查结束标志，如果为 &lt;strong&gt;true&lt;/strong&gt; 就退出，这样相比较第一个方法退出时就没有延迟了，参考代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net&amp;quot;
    &amp;quot;time&amp;quot;
)

var (
    ln        net.Listener
    closeFlag bool = false
)

func startServer() (err error) {
    ln, err = net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:12345&amp;quot;)
    if err != nil {
        return err
    }
    defer ln.Close()

    for {
        conn, err := ln.Accept()
        if err != nil {
            fmt.Printf(&amp;quot;accept error: %v\n&amp;quot;, err)
            if closeFlag {
                break
            } else {
                continue
            }
        } else {
            conn.Close()
        }
    }
    return nil
}

func main() {
    go startServer()
    time.Sleep(1 * time.Second)
    closeFlag = true
    ln.Close()
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用godep管理golang项目的第三方包</title>
          <link>http://blog.fatedier.com/2016/01/15/use-godep-to-manage-third-party-packages-of-golang-projects</link>
          <pubDate>Fri, 15 Jan 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/01/15/use-godep-to-manage-third-party-packages-of-golang-projects</guid>
          <description>

&lt;p&gt;go语言项目的第三方包资源现在十分丰富，使用起来也非常方便，直接在代码中 import 之后再使用 go get 命令下载到本地即可。但是在合作开发一个golang项目时，经常会遇到每个人在各自的机器上使用 go get 下载的第三方包版本不一致的情况（因为 go get 会下载指定包的最新版本），很有可能会遇到版本不兼容的情况。&lt;/p&gt;

&lt;p&gt;目前 go 自身的包管理体系比较薄弱，go 1.5 以后开始使用 vendor 机制来管理，但是依然缺乏对第三方包的版本的管理。&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;确保已经有go语言的环境并且设置好了 GOPATH 环境变量。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;go get -u github.com/tools/godep&lt;/code&gt; 下载 godep 包并自动安装。&lt;/li&gt;
&lt;li&gt;godep 可执行程序会放在 $GOPATH/bin 目录下。所以想直接用 godep 执行命令的话需要将该路径加入到全局的环境变量 PATH 中，可以将&lt;code&gt;export PATH=&amp;quot;$PATH:$GOPATH/bin&amp;quot;&lt;/code&gt;加入到系统启动脚本中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;进入go项目的根目录，需要该项目已经可以使用 go build 正常编译。&lt;/p&gt;

&lt;h4 id=&#34;godep-save&#34;&gt;godep save&lt;/h4&gt;

&lt;p&gt;执行 &lt;code&gt;godep save&lt;/code&gt; 或者 &lt;code&gt;godep save ./...&lt;/code&gt;，后者会递归地查找所有引用的第三方包。&lt;/p&gt;

&lt;p&gt;如果加上 -r 参数，则会替换原来代码中的第三包的路径为 godep 在该项目下copy过后的路径，例如 &lt;code&gt;C/Godeps/_workspace/src/D&lt;/code&gt;， 这样一来，以后直接执行 &lt;code&gt;go build&lt;/code&gt; 等就可以了，不需要使用 &lt;code&gt;godep go build&lt;/code&gt;。&lt;strong&gt;（这个特性在最新版本中已经被移除了）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个命令做了以下几件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查找项目中所用到的所有的第三方包&lt;/li&gt;
&lt;li&gt;在项目目录下创建 &lt;code&gt;Godeps&lt;/code&gt; 目录，&lt;code&gt;Godeps/Godeps.json&lt;/code&gt; 是依赖文件，包括了go的版本，用到的第三包的引入路径，版本号等信息，json文件需要一并加入到版本控制里。&lt;/li&gt;
&lt;li&gt;所有依赖的第三包的代码会被拷贝到 &lt;code&gt;Godeps/_workspace/src&lt;/code&gt; 下，并且移除了 &lt;code&gt;.git&lt;/code&gt; 这样的版本控制信息。&lt;code&gt;Godeps/_workspace&lt;/code&gt; 里的内容如果加到版本控制里，别人下载代码后可以直接编译，不需要另外再下依赖包，但是项目大小会变大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;godep-restore&#34;&gt;godep restore&lt;/h4&gt;

&lt;p&gt;这个命令是根据 &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; 文件把项目的依赖包下载到 &lt;code&gt;$GOPATH&lt;/code&gt; 目录下，需要注意这个命令是会修改 &lt;code&gt;$GOPATH&lt;/code&gt; 下依赖包的状态的，所以最好还是将 &lt;code&gt;Godeps/_workspace&lt;/code&gt; 里的内容直接加到自己项目的版本控制里。&lt;/p&gt;

&lt;h4 id=&#34;其他命令&#34;&gt;其他命令&lt;/h4&gt;

&lt;p&gt;其他的 go 命令基本上都可以通过 godep 执行，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;godep go build
godep go install
godep go fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;godep 封装的 go 命令其实就是将 Godeps/_workspace 加入到 GOPATH 中，这样编译的时候就会去 Godeps/_workspace 中寻找第三方包。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>go语言中使用smtp发送邮件及smtp协议的相关问题</title>
          <link>http://blog.fatedier.com/2015/08/20/use-smtp-to-sendmail-in-go-and-some-problems-with-smtp</link>
          <pubDate>Thu, 20 Aug 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2015/08/20/use-smtp-to-sendmail-in-go-and-some-problems-with-smtp</guid>
          <description>

&lt;p&gt;go 的标准库中有一个 smtp 包提供了一个可以非常方便的使用 smtp 协议发送邮件的函数，通常情况下使用起来简单方便，不过我在使用中却意外遇到了一个会导致邮件发送出错的情况。&lt;/p&gt;

&lt;h3 id=&#34;smtp-协议发送邮件&#34;&gt;smtp 协议发送邮件&lt;/h3&gt;

&lt;h4 id=&#34;sendmail-函数&#34;&gt;sendmail 函数&lt;/h4&gt;

&lt;p&gt;go 标准库的 net/smtp 包提供了一个 SendMail 函数用于发送邮件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SendMail(addr string, a Auth, from string, to []string, msg []byte) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SendMail&lt;/strong&gt;： 连接到 &lt;strong&gt;addr&lt;/strong&gt; 指定的服务器；如果支持会开启 &lt;strong&gt;TLS&lt;/strong&gt;；如果支持会使用 &lt;strong&gt;a(Auth)&lt;/strong&gt; 认证身份；然后以 &lt;strong&gt;from&lt;/strong&gt; 为邮件源地址发送邮件 &lt;strong&gt;msg&lt;/strong&gt; 到目标地址 &lt;strong&gt;to&lt;/strong&gt;。（可以是多个目标地址：群发）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;： 邮件服务器的地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a&lt;/strong&gt;： 身份认证接口，可以由 &lt;code&gt;func PlainAuth(identity, username, password, host string) Auth&lt;/code&gt; 函数创建。&lt;/p&gt;

&lt;h4 id=&#34;简单发送邮件示例&#34;&gt;简单发送邮件示例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/smtp&amp;quot;
    &amp;quot;strings&amp;quot;
)

func main() {
    auth := smtp.PlainAuth(&amp;quot;&amp;quot;, &amp;quot;username@qq.com&amp;quot;, &amp;quot;passwd&amp;quot;, &amp;quot;smtp.qq.com&amp;quot;)
    to := []string{&amp;quot;to-user@qq.com&amp;quot;}
    nickname := &amp;quot;test&amp;quot;
    user := &amp;quot;username@qq.com&amp;quot;
    subject := &amp;quot;test mail&amp;quot;
    content_type := &amp;quot;Content-Type: text/plain; charset=UTF-8&amp;quot;
    body := &amp;quot;This is the email body.&amp;quot;
    msg := []byte(&amp;quot;To: &amp;quot; + strings.Join(to, &amp;quot;,&amp;quot;) + &amp;quot;\r\nFrom: &amp;quot; + nickname +
        &amp;quot;&amp;lt;&amp;quot; + user + &amp;quot;&amp;gt;\r\nSubject: &amp;quot; + subject + &amp;quot;\r\n&amp;quot; + content_type + &amp;quot;\r\n\r\n&amp;quot; + body)
    err := smtp.SendMail(&amp;quot;smtp.qq.com:25&amp;quot;, auth, user, to, msg)
    if err != nil {
        fmt.Printf(&amp;quot;send mail error: %v&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;autu&lt;/strong&gt;： 这里采用简单的明文用户名和密码的认证方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nickname&lt;/strong&gt;： 发送方的昵称。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;subject&lt;/strong&gt;： 邮件主题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;content_type&lt;/strong&gt;： 可以有两种方式，一种 text/plain，纯字符串，不做转义。一种 text/html，会展示成 html 页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt;： 邮件正文内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;msg&lt;/strong&gt;： msg 的内容需要遵循 smtp 协议的格式，参考上例。&lt;/p&gt;

&lt;h3 id=&#34;特定邮件服务器出错&#34;&gt;特定邮件服务器出错&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;certificate signed by unknown authority
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在通过公司内部自己搭建的邮件服务器发送邮件时报了上述错误，看上去是因为认证不通过的问题，检查了一下用户名和密码没有问题。&lt;/p&gt;

&lt;p&gt;我通过抓包以及手动 telnet 执行了一遍 smtp 的过程，发送问题出现在是否加密和身份验证上。&lt;/p&gt;

&lt;h4 id=&#34;smtp-协议&#34;&gt;SMTP 协议&lt;/h4&gt;

&lt;p&gt;smtp 协议开始时客户端主动向邮件服务器发送 &lt;code&gt;EHLO&lt;/code&gt;，服务器会返回支持的所有命令，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;250-PIPELINING
250-SIZE 10240000
250-VRFY
250-ETRN
250-STARTTLS
250-AUTH PLAIN LOGIN
250-AUTH=PLAIN LOGIN
250-ENHANCEDSTATUSCODES
250-8BITMIME
250 DSN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有 &lt;strong&gt;STARTTLS&lt;/strong&gt;，说明支持加密传输，golang 的标准库中会进行判断然后决定是否选择使用 &lt;strong&gt;STARTTLS&lt;/strong&gt; 加密传输。&lt;/p&gt;

&lt;p&gt;如果没有 &lt;strong&gt;AUTH=PLAIN LOGIN&lt;/strong&gt;，说明不支持 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式。&lt;/p&gt;

&lt;p&gt;一共有3种验证方式，可以参考这篇 blog： &lt;a href=&#34;http://blog.csdn.net/mhfh611/article/details/9470599&#34;&gt;http://blog.csdn.net/mhfh611/article/details/9470599&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;starttls-引起的错误&#34;&gt;STARTTLS 引起的错误&lt;/h4&gt;

&lt;p&gt;公司内部的邮件服务器返回了 &lt;strong&gt;STARTTLS&lt;/strong&gt;，但是实际上却不支持加密传输的认证方式，所以就导致了身份认证失败。&lt;/p&gt;

&lt;p&gt;大部分国内的邮件服务器都支持 &lt;strong&gt;LOGIN&lt;/strong&gt; 和 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式，所以我们可以在代码中直接采用 &lt;strong&gt;PLAIN&lt;/strong&gt; 的方式，不过安全性就降低了。&lt;/p&gt;

&lt;p&gt;想要强制使用 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式也不是这么容易的，因为涉及到修改 &lt;strong&gt;net/smtp&lt;/strong&gt; 的 &lt;code&gt;SendMail&lt;/code&gt; 函数，当然标准库我们修改不了，所以只能重新实现一个 &lt;code&gt;SendMail&lt;/code&gt; 函数。&lt;/p&gt;

&lt;p&gt;标准库中 &lt;code&gt;SendMail&lt;/code&gt; 函数代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SendMail(addr string, a Auth, from string, to []string, msg []byte) error {
    c, err := Dial(addr)
    if err != nil {
        return err
    }
    defer c.Close()
    if err = c.hello(); err != nil {
        return err
    }
    if ok, _ := c.Extension(&amp;quot;STARTTLS&amp;quot;); ok {
        config := &amp;amp;tls.Config{ServerName: c.serverName}
        if testHookStartTLS != nil {
            testHookStartTLS(config)
        }
        if err = c.StartTLS(config); err != nil {
            return err
        }
    }
    if a != nil &amp;amp;&amp;amp; c.ext != nil {
        if _, ok := c.ext[&amp;quot;AUTH&amp;quot;]; ok {
            if err = c.Auth(a); err != nil {
                return err
            }
        }
    }
    if err = c.Mail(from); err != nil {
        return err
    }
    for _, addr := range to {
        if err = c.Rcpt(addr); err != nil {
            return err
        }
    }
    w, err := c.Data()
    if err != nil {
        return err
    }
    _, err = w.Write(msg)
    if err != nil {
        return err
    }
    err = w.Close()
    if err != nil {
        return err
    }
    return c.Quit()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点就在于下面这一段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if ok, _ := c.Extension(&amp;quot;STARTTLS&amp;quot;); ok {
    config := &amp;amp;tls.Config{ServerName: c.serverName}
    if testHookStartTLS != nil {
        testHookStartTLS(config)
    }
    if err = c.StartTLS(config); err != nil {
        return err
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逻辑上就是检查服务器端对于 &lt;strong&gt;EHLO&lt;/strong&gt; 命令返回的所支持的命令中是否有 &lt;strong&gt;STARTTLS&lt;/strong&gt;，如果有，则采用加密传输的方式。我们自己实现的函数中直接把这部分去掉。&lt;/p&gt;

&lt;p&gt;我们仿照 &lt;code&gt;SendMail&lt;/code&gt; 函数实现一个 &lt;code&gt;NewSendMail&lt;/code&gt; 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewSendMail(addr string, a smtp.Auth, from string, to []string, msg []byte) error {
    c, err := smtp.Dial(addr)
    if err != nil {
        return err 
    }   
    defer c.Close()
    if err = c.Hello(&amp;quot;localhost&amp;quot;); err != nil {
        return err 
    }   
    err = c.Auth(a)
    if err != nil {
        return err 
    }   

    if err = c.Mail(from); err != nil {
        fmt.Printf(&amp;quot;mail\n&amp;quot;)
        return err 
    }   
    for _, addr := range to {
        if err = c.Rcpt(addr); err != nil {
            return err 
        }   
    }
    w, err := c.Data()
    if err != nil {
        return err
    }
    _, err = w.Write(msg)
    if err != nil {
        return err
    }
    err = w.Close()
    if err != nil {
        return err
    }
    return c.Quit()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个函数发送邮件，则身份认证时不会采用加密的方式，而是直接使用 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
