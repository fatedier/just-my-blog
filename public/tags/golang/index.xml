<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fatedier blog </title>
    <link>http://blog.fatedier.com/tags/golang/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2016</rights>
    <updated>2016-07-25 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>使用gvm在不同go版本之间切换</title>
          <link>http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm</link>
          <pubDate>Mon, 25 Jul 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/07/25/use-different-go-version-by-gvm</guid>
          <description>

&lt;p&gt;Centos7上通过 yum 从 epel 仓库里直接安装的 go 版本还是 1.4.2，从源码编译安装最新的 go 版本比较麻烦，而且开发中有时需要调试在不同编译环境下可能存在的问题，不能忽略使用最新版本是存在某些 bug 的可能性。&lt;/p&gt;

&lt;p&gt;Go 的更新速度比较快，2015年8月发布 1.5 版本，2016年2月发布 1.6 版本，2016年8月即将发布 1.7 版本，在性能以及GC方便都在不断优化，及时更新到新版本的 go 很有优势。&lt;/p&gt;

&lt;h3 id=&#34;go-版本切换的问题&#34;&gt;Go 版本切换的问题&lt;/h3&gt;

&lt;p&gt;二进制文件的管理比较简单，通过链接使用不同版本的程序即可，实际上主要是一些环境变量和标准库的设置问题，环境变量主要是 &lt;code&gt;GOPATH&lt;/code&gt; 以及 &lt;code&gt;GOROOT&lt;/code&gt;，标准库的话需要在切换 go 版本时也能跟着切换。&lt;strong&gt;gvm&lt;/strong&gt; 实际上就是帮助完成这些配置工作。&lt;/p&gt;

&lt;h3 id=&#34;安装-gvm&#34;&gt;安装 gvm&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;gvm&lt;/strong&gt; 的项目地址：&lt;a href=&#34;https://github.com/moovweb/gvm&#34;&gt;https://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash &amp;lt;&amp;lt; (curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你使用的是 &lt;code&gt;zsh&lt;/code&gt; 的话将前面的 &lt;code&gt;bash&lt;/code&gt; 改为 &lt;code&gt;zsh&lt;/code&gt; 即可，这条命令主要是下载 &lt;strong&gt;gvm&lt;/strong&gt; 相关的文件，创建所需目录，并且在 &lt;code&gt;.bashrc&lt;/code&gt; 或者 &lt;code&gt;.zshrc&lt;/code&gt; 中加入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[[ -s &amp;quot;/home/wcl/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;/home/wcl/.gvm/scripts/gvm&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使每次登录 shell 时都可以生效。&lt;/p&gt;

&lt;h3 id=&#34;安装指定-go-版本&#34;&gt;安装指定 go 版本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gvm install go1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意这里实际上是先执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://go.googlesource.com/go $GVM_ROOT/archive/go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个网站在墙外。&lt;/p&gt;

&lt;p&gt;我们可以通过配置使 git 可以通过 http 代理访问，修改 &lt;code&gt;.gitconfig&lt;/code&gt; 文件，加上 http 代理服务器的地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[http]
        proxy = http://[proxydomain]:[port]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载成功后，有可能提示编译失败，因为 go1.6.3 需要依赖于 go1.4 来编译，需要设置 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 变量。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;go env&lt;/code&gt; 查看 &lt;code&gt;GOROOT&lt;/code&gt; 的路径，通常 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 就设置成 &lt;code&gt;GOROOT&lt;/code&gt;，centos7 下需要注意 /usr/lib/golang/bin 下并没有 &lt;code&gt;go&lt;/code&gt; 的二进制文件，通过 cp 命令复制一个过去。&lt;/p&gt;

&lt;p&gt;之后再次执行 &lt;code&gt;gvm install go1.6.3&lt;/code&gt; 即可安装完成。&lt;/p&gt;

&lt;h3 id=&#34;修改配置信息方便使用&#34;&gt;修改配置信息方便使用&lt;/h3&gt;

&lt;p&gt;最初测试时发现每次切换 go 版本后都会被修改 &lt;code&gt;GOPATH&lt;/code&gt; 变量，而实际上我并不需要这个功能，只是希望用新版本来编译已有的项目，所以我们需要把 &lt;code&gt;~/.gvm/environments&lt;/code&gt; 文件夹下所有 &lt;code&gt;GOPATH&lt;/code&gt; 的设置全部删除。&lt;/p&gt;

&lt;p&gt;另外还需要将 &lt;code&gt;~/.zshrc&lt;/code&gt; 或者 &lt;code&gt;~/.bashrc&lt;/code&gt; 中的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[[ -s &amp;quot;~/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;~/.gvm/scripts/gvm&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移到设置 &lt;code&gt;GOPATH&lt;/code&gt; 变量之前，避免登录 shell 之后被修改 &lt;code&gt;GOPATH&lt;/code&gt; 变量。&lt;/p&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;h4 id=&#34;切换到安装好的指定-go-版本&#34;&gt;切换到安装好的指定 go 版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use go1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;go version&lt;/code&gt; 可以看到已经是新版本的二进制文件，通过 &lt;code&gt;go env&lt;/code&gt; 可以查看 &lt;code&gt;GOROOT&lt;/code&gt; 信息，例如我的就是 &lt;code&gt;~/.gvm/gos/go1.6.3&lt;/code&gt;，这样编译项目时就会在这个目录下找标准库中的文件。&lt;/p&gt;

&lt;h4 id=&#34;切换到原来的系统版本&#34;&gt;切换到原来的系统版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use system&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;查看当前已经安装的所有版本&#34;&gt;查看当前已经安装的所有版本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gvm gos (installed)

=&amp;gt; go1.6.3
   system
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;设置某个版本为默认&#34;&gt;设置某个版本为默认&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;gvm use go1.6.3 --default&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样设置后，再登录 shell 就默认使用 &lt;code&gt;go1.6.3&lt;/code&gt; 的版本，而不是系统原来的版本了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>go程序中dns解析无法使用所有域名服务器</title>
          <link>http://blog.fatedier.com/2016/04/27/go-program-does-not-use-all-nameservers-for-dns-lookups</link>
          <pubDate>Wed, 27 Apr 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/04/27/go-program-does-not-use-all-nameservers-for-dns-lookups</guid>
          <description>

&lt;p&gt;最近线上服务经常会出现异常，从错误日志来看是因为域名解析失败导致的，我们在 /etc/resolv.conf 中配置了多个域名服务器，第一个是内网的，用于解析内网域名，如果是外网域名，则会通过其他的域名服务器进行解析，按道理来说应该不会有问题，但是最近却频繁发生这样的故障，为了彻底解决问题，特意研究了一下 golang 中进行 dns 查询的源码并最终解决了此问题。&lt;/p&gt;

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;h4 id=&#34;nameserver-配置&#34;&gt;nameserver 配置&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中配置了多个 nameserver&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nameserver 10.10.100.3
nameserver 114.114.114.114
nameserver 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;10.10.100.3&lt;/code&gt; 用于解析内网域名，外网域名通过 &lt;code&gt;114.114.114.114&lt;/code&gt; 或者 &lt;code&gt;8.8.8.8&lt;/code&gt; 来解析。&lt;/p&gt;

&lt;h4 id=&#34;测试代码&#34;&gt;测试代码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
    &amp;quot;net&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func main() {
    hostname := &amp;quot;www.baidu.com&amp;quot;
    addrs, err := net.LookupHost(hostname)
    if err != nil {
        fmt.Printf(&amp;quot;lookup host error: %v\n&amp;quot;, err)
    } else {
        fmt.Printf(&amp;quot;addrs: %v&amp;quot;, addrs)
    }   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;结果&#34;&gt;结果&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lookup host error: lookup www.baidu.com on 10.10.100.3:53: no such host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 go1.5 版本进行编译，发现程序并没有按照预想的过程来解析，通过 &lt;code&gt;10.10.100.3&lt;/code&gt; 无法解析后就直接返回了错误信息。&lt;/p&gt;

&lt;p&gt;而使用 go1.4 版本编译运行后，确得到了正确的结果。&lt;/p&gt;

&lt;h3 id=&#34;调试标准库的方法&#34;&gt;调试标准库的方法&lt;/h3&gt;

&lt;p&gt;调试 golang 的标准库非常简单，先找到标准库源码的存放位置，然后将要修改的文件备份一份，之后直接在其中添加输出语句，大部分可以 &lt;code&gt;import &amp;quot;fmt&amp;quot;&lt;/code&gt; 后使用 &lt;code&gt;fmt.Printf&lt;/code&gt; 函数进行输出，有的包中需要使用其他方式，避免循环引用，这里不详述，因为我们要改的 &lt;code&gt;net&lt;/code&gt; 包并不涉及这个问题，注意调试完之后将标准库的文件恢复。&lt;/p&gt;

&lt;h4 id=&#34;查找标准库所在的目录&#34;&gt;查找标准库所在的目录&lt;/h4&gt;

&lt;p&gt;执行 &lt;code&gt;go env&lt;/code&gt; 查看 go 的环境变量如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOARCH=&amp;quot;amd64&amp;quot;
GOBIN=&amp;quot;&amp;quot;GOCHAR=&amp;quot;6&amp;quot;GOEXE=&amp;quot;&amp;quot;GOHOSTARCH=&amp;quot;amd64&amp;quot;GOHOSTOS=&amp;quot;linux&amp;quot;GOOS=&amp;quot;linux&amp;quot;
GOPATH=&amp;quot;/home/wcl/go_projects&amp;quot;
GORACE=&amp;quot;&amp;quot;
GOROOT=&amp;quot;/usr/lib/golang&amp;quot;
GOTOOLDIR=&amp;quot;/usr/lib/golang/pkg/tool/linux_amd64&amp;quot;
CC=&amp;quot;gcc&amp;quot;
GOGCCFLAGS=&amp;quot;-fPIC -m64 -pthread -fmessage-length=0&amp;quot;
CXX=&amp;quot;g++&amp;quot;
CGO_ENABLED=&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GOROOT&lt;/strong&gt; 的值即是标准库所在的目录，&lt;code&gt;net&lt;/code&gt; 包的具体路径为 &lt;code&gt;/usr/lib/golang/src/net&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-1-4-与-1-5-版本中-dns-查询逻辑的不同&#34;&gt;go 1.4 与 1.5 版本中 dns 查询逻辑的不同&lt;/h3&gt;

&lt;p&gt;因为最近很多程序都是使用 &lt;strong&gt;go1.5&lt;/strong&gt; 版本进行编译的，所以理所当然查看了两个版本这部分源码的区别，还真的有所改变。&lt;/p&gt;

&lt;p&gt;标准库对外暴露的 dns 查询函数是 &lt;code&gt;func LookupHost(host string) (addrs []string, err error)&lt;/code&gt; &lt;strong&gt;(net/lookup.go)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个函数会调用实际处理函数 &lt;code&gt;lookupHost&lt;/code&gt; &lt;strong&gt;(net/lookup_unix.go)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;cgo-与纯-go-实现的-dns-查询&#34;&gt;cgo 与纯 go 实现的 dns 查询&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;go1.4 版本源码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func lookupHost(host string) (addrs []string, err error) {
    addrs, err, ok := cgoLookupHost(host)
    if !ok {
        addrs, err = goLookupHost(host)
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;go1.5 版本源码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func lookupHost(host string) (addrs []string, err error) {
    order := systemConf().hostLookupOrder(host)
    if order == hostLookupCgo {
        if addrs, err, ok := cgoLookupHost(host); ok {
            return addrs, err
        }
        // cgo not available (or netgo); fall back to Go&#39;s DNS resolver
        order = hostLookupFilesDNS
    }
    return goLookupHostOrder(host, order)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可以明显的看到 1.4 的源码中默认使用 cgo 的方式进行 dns 查询&lt;/strong&gt;（这个函数最终会创建一个线程调用c的 getaddrinfo 函数来获取 dns 查询结果），如果查询失败则会再使用纯 go 实现的查询方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而在 1.5 的源码中，这一点有所改变，cgo 的方式不再是默认值，而是根据 &lt;code&gt;systemConf().hostLookupOrder(host)&lt;/code&gt; 的返回值来判断具体使用哪种方式&lt;/strong&gt;。这个函数定义在 &lt;strong&gt;net/conf.go&lt;/strong&gt; 中，稍微看了一下， 除非通过编译标志强制使用 cgo 方式或者在某些特定的系统上会使用 cgo 方式，其他时候都使用纯 go 实现的查询方式。&lt;/p&gt;

&lt;p&gt;cgo 的方式没有问题，看起来程序会并发地向 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中所有配置的域名服务器发送 dns 解析请求，然后将最先成功响应的结果返回。&lt;/p&gt;

&lt;h4 id=&#34;纯-go-实现的-dns-查询分析&#34;&gt;纯 go 实现的 dns 查询分析&lt;/h4&gt;

&lt;p&gt;问题就出在纯 go 实现的查询上，主要看一下 go1.5 的实现。&lt;/p&gt;

&lt;p&gt;函数调用逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;LookupHost (net/lookup.go)
    lookupHost  (net/lookup_unix.go)
        goLookupHostOrder  (net/dnsclient_unix.go)
            goLookupIPOrder  (net/dnsclient_unix.go)
                tryOneName   (net/dnsclient_unix.go)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分实现代码在 &lt;code&gt;net/dnsclient_unix.go&lt;/code&gt; 这个文件中。&lt;/p&gt;

&lt;p&gt;重点看一下 &lt;code&gt;tryOneName&lt;/code&gt; 这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func tryOneName(cfg *dnsConfig, name string, qtype uint16) (string, []dnsRR, error) {
    if len(cfg.servers) == 0 {
        return &amp;quot;&amp;quot;, nil, &amp;amp;DNSError{Err: &amp;quot;no DNS servers&amp;quot;, Name: name}
    }
    if len(name) &amp;gt;= 256 {
        return &amp;quot;&amp;quot;, nil, &amp;amp;DNSError{Err: &amp;quot;DNS name too long&amp;quot;, Name: name}
    }
    timeout := time.Duration(cfg.timeout) * time.Second
    var lastErr error
    for i := 0; i &amp;lt; cfg.attempts; i++ {
        for _, server := range cfg.servers {
            server = JoinHostPort(server, &amp;quot;53&amp;quot;)
            msg, err := exchange(server, name, qtype, timeout)
            if err != nil {
                lastErr = &amp;amp;DNSError{
                    Err:    err.Error(),
                    Name:   name,
                    Server: server,
                }
                if nerr, ok := err.(Error); ok &amp;amp;&amp;amp; nerr.Timeout() {
                    lastErr.(*DNSError).IsTimeout = true
                }
                continue
            }
            cname, rrs, err := answer(name, server, msg, qtype)
            if err == nil || msg.rcode == dnsRcodeSuccess || msg.rcode == dnsRcodeNameError &amp;amp;&amp;amp; msg.recursion_available {
                return cname, rrs, err
            }
            lastErr = err
        }
    }
    return &amp;quot;&amp;quot;, nil, lastErr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一层 for 循环是尝试的次数，第二层 for 循环是遍历 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中配置的所有域名服务器，&lt;code&gt;exchange&lt;/code&gt; 函数是发送 dns 查询请求并将响应结果解析到 &lt;code&gt;msg&lt;/code&gt; 变量中返回，初看到这里，觉得实现是没问题的，顺序向每一个域名服务器发送 dns 查询请求，如果成功就返回，如果失败就尝试下一个。&lt;/p&gt;

&lt;p&gt;问题出现在判断是否成功的那一行代码 &lt;code&gt;if err == nil || msg.rcode == dnsRcodeSuccess || msg.rcode == dnsRcodeNameError &amp;amp;&amp;amp; msg.recursion_available&lt;/code&gt;，这里的意思是如果 dns 查询成功，或者出错了但是对方支持递归查询的话，就直接返回，不继续请求下一个域名服务器。如果对方支持递归查询但是仍然没有查到的话，说明上级服务器也没有这个域名的记录，没有必要继续往下查。（这个逻辑在 go1.6 版本中被修改了，出错了以后不再判断是否支持递归查询，仍然尝试向下一个域名服务器发送请求）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;msg.rcode&lt;/code&gt; 这个值很重要，是问题的关键。&lt;/p&gt;

&lt;h3 id=&#34;dns-查询协议格式&#34;&gt;dns 查询协议格式&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xs9f1.com1.z0.glb.clouddn.com/pic/2016/2016-04-27-go-program-does-not-use-all-nameservers-for-dns-lookups-dns-query-package.png&#34; alt=&#34;dns-query-package&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要关注首部的12字节。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID:占16位，2个字节。此报文的编号，由客户端指定。DNS回复时带上此标识，以指示处理的对应请应请求。&lt;/li&gt;
&lt;li&gt;QR:占1位，1/8字节。0代表查询，1代表DNS回复&lt;/li&gt;
&lt;li&gt;Opcode:占4位，1/2字节。指示查询种类：0:标准查询；1:反向查询；2:服务器状态查询；3-15:未使用。&lt;/li&gt;
&lt;li&gt;AA:占1位，1/8字节。是否权威回复。&lt;/li&gt;
&lt;li&gt;TC:占1位，1/8字节。因为一个UDP报文为512字节，所以该位指示是否截掉超过的部分。&lt;/li&gt;
&lt;li&gt;RD:占1位，1/8字节。此位在查询中指定，回复时相同。设置为1指示服务器进行递归查询。&lt;/li&gt;
&lt;li&gt;RA:占1位，1/8字节。由DNS回复返回指定，说明DNS服务器是否支持递归查询。&lt;/li&gt;
&lt;li&gt;Z:占3位，3/8字节。保留字段，必须设置为0。&lt;/li&gt;
&lt;li&gt;RCODE:占4位，1/2字节。由回复时指定的返回码：0:无差错；1:格式错；2:DNS出错；3:域名不存在；4:DNS不支持这类查询；5:DNS拒绝查询；6-15:保留字段。　&lt;/li&gt;
&lt;li&gt;QDCOUNT:占16位，2字节。一个无符号数指示查询记录的个数。&lt;/li&gt;
&lt;li&gt;ANCOUNT:占16位，2字节。一个无符号数指明回复记录的个数。&lt;/li&gt;
&lt;li&gt;NSCOUNT:占16位，2字节。一个无符号数指明权威记录的个数。&lt;/li&gt;
&lt;li&gt;ARCOUNT:占16位，2字节。一个无符号数指明格外记录的个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中 &lt;strong&gt;RCODE&lt;/strong&gt; 是回复时用于判断查询结果是否成功的，对应前面的 &lt;code&gt;msg.rcode&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;bind-的-dns-回复问题&#34;&gt;bind 的 dns 回复问题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;10.10.100.3&lt;/code&gt; 上是使用 &lt;strong&gt;bind&lt;/strong&gt; 搭建的本地域名服务器。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;dig @10.10.100.3 www.baidu.com&lt;/code&gt; 命令查看解析结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @10.10.100.3 www.baidu.com ;
(1 server found) 
;; global options: +cmd 
;; Got answer: 
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 55909 
;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 13, ADDITIONAL: 0 
;; WARNING: recursion requested but not available 

;; QUESTION SECTION: 
;www.baidu.com.         IN  A 

;; AUTHORITY SECTION: 
.           518400  IN  NS  H.ROOT-SERVERS.NET.  
.           518400  IN  NS  K.ROOT-SERVERS.NET.  
.           518400  IN  NS  C.ROOT-SERVERS.NET.  
.           518400  IN  NS  A.ROOT-SERVERS.NET.  
.           518400  IN  NS  B.ROOT-SERVERS.NET.  
.           518400  IN  NS  F.ROOT-SERVERS.NET.  
.           518400  IN  NS  L.ROOT-SERVERS.NET.  
.           518400  IN  NS  D.ROOT-SERVERS.NET.  
.           518400  IN  NS  I.ROOT-SERVERS.NET.  
.           518400  IN  NS  E.ROOT-SERVERS.NET.  
.           518400  IN  NS  G.ROOT-SERVERS.NET.  
.           518400  IN  NS  M.ROOT-SERVERS.NET.  
.           518400  IN  NS  J.ROOT-SERVERS.NET.  

;; Query time: 1 msec 
;; SERVER: 10.10.100.3#53(10.10.100.3) 
;; WHEN: Wed Apr 27 17:35:15 2016 
;; MSG SIZE  rcvd: 242 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bind&lt;/strong&gt; 并没有返回 &lt;code&gt;www.baidu.com&lt;/code&gt; 的 A 记录，而是返回了13个根域名服务器的地址，并且 &lt;strong&gt;status&lt;/strong&gt; 的状态是 &lt;strong&gt;NOERROR&lt;/strong&gt;（这个值就是前述的 &lt;strong&gt;RCODE&lt;/strong&gt;，这里返回0表示没有错误)，问题就在这里，没有查到 A 记录还返回 &lt;code&gt;RCODE=0&lt;/code&gt;，回顾一下上面 go 代码中的判断条件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if err == nil || msg.rcode == dnsRcodeSuccess || msg.rcode == dnsRcodeNameError &amp;amp;&amp;amp; msg.recursion_available&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果返回的 &lt;strong&gt;RCODE&lt;/strong&gt; 值为 0，则直接退出，不继续尝试后面的域名服务器，从而导致了域名解析失败。&lt;/p&gt;

&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;

&lt;h4 id=&#34;仍然使用-go1-4-版本进行编译&#34;&gt;仍然使用 go1.4 版本进行编译&lt;/h4&gt;

&lt;p&gt;不推荐这么做，毕竟升级后在 gc 以及很多其他方面都有优化。&lt;/p&gt;

&lt;h4 id=&#34;使用-go1-5-及以上版本编译但是通过环境变量强制使用-cgo-的-dns-查询方式&#34;&gt;使用 go1.5 及以上版本编译但是通过环境变量强制使用 cgo 的 dns 查询方式&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;export GODEBUG=netdns=cgo go build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 cgo 的方式会在每一次调用时创建一个线程，在并发量较大时可能会对系统资源造成一定影响。而且需要每一个使用 go 编写的程序编译时都加上此标志，较为繁琐。&lt;/p&gt;

&lt;h4 id=&#34;修改-bind-的配置文件&#34;&gt;修改 bind 的配置文件&lt;/h4&gt;

&lt;p&gt;在 &lt;strong&gt;bind&lt;/strong&gt; 中彻底关闭对递归查询的支持也可以解决此问题，但是由于对 &lt;strong&gt;bind&lt;/strong&gt; 不是很熟悉，具体是什么原因导致没有查到 &lt;strong&gt;A 记录&lt;/strong&gt;但仍然返回 &lt;strong&gt;NOERROR&lt;/strong&gt; 不是很清楚，猜测可能和递归转发的查询方式有关，有可能 &lt;strong&gt;bind&lt;/strong&gt; 认为返回了根域名服务器的地址，&lt;strong&gt;client&lt;/strong&gt; 可以去这些地址上查，所以该次请求并不算做出错。&lt;/p&gt;

&lt;p&gt;修改配置文件加上以下内容以后，再次查询时会返回 &lt;strong&gt;RCODE=5&lt;/strong&gt;，拒绝递归查询，这样可以达到我们的目的，查询非内网域名时通过其他域名服务器查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;recursion no;
allow-query-cache { none; };
allow-recursion { none; };
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>如何使golang项目可以在任意目录下编译</title>
          <link>http://blog.fatedier.com/2016/02/25/how-to-compile-go-project-in-any-directory</link>
          <pubDate>Thu, 25 Feb 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/02/25/how-to-compile-go-project-in-any-directory</guid>
          <description>

&lt;p&gt;通常我们将golang项目直接放在 $GOPATH/src 目录下，所有 import 的包的路径也是相对于 GOPATH 的。我在开发 frp（一个可以用于穿透内网的反向代理工具）的时候就遇到一个比较小但是挺棘手的问题，需要使这个项目可以在任意目录里被编译，方便其他成员不需要做额外的操作就可以一同开发，这里分享一下解决的方法。&lt;/p&gt;

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fatedier/frp&#34;&gt;frp&lt;/a&gt; 是我业余时间写的一个用于穿透内网的反向代理工具，可以将防火墙内或内网环境的机器对外暴露指定的服务，例如22端口提供ssh服务或者80端口提供一个临时的web测试环境。&lt;/p&gt;

&lt;p&gt;一开始项目是直接放在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 目录下的，第三方包的引用是 &lt;code&gt;import github.com/xxx/xxx&lt;/code&gt;，内部包的引用 &lt;code&gt;import frp/xxx&lt;/code&gt;，这样编译时内部包的查找路径实际上就是 &lt;code&gt;$GOPATH/src/frp/xxx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;后来由于使用了 &lt;a href=&#34;https://travis-ci.org/&#34;&gt;travis-ci&lt;/a&gt; 做持续集成，travis-ci 中是直接使用 &lt;code&gt;go get github.com/fatedier/frp&lt;/code&gt; 下载代码，然后编译运行。这样问题就来了，通过 go get 下载的源码在本地的路径是 &lt;code&gt;$GOPATH/src/github.com/fatedier/frp&lt;/code&gt;，内部包就找不到了，导致编译失败。&lt;/p&gt;

&lt;h3 id=&#34;使用类似第三方包的引用方式&#34;&gt;使用类似第三方包的引用方式&lt;/h3&gt;

&lt;p&gt;解决这个问题最直接的方法就是将内部包的引用方式修改成 &lt;code&gt;import github.com/fatedier/frp/xxx&lt;/code&gt;，在 travis-ci 中编译的时候就可以通过了，同时需要注意把自己本地的项目路径也更换成&lt;code&gt;$GOPATH/src/github.com/fatedier/frp&lt;/code&gt;，很多开源项目都是用的这种方式引用内部包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：不推荐使用 ./ ../ 等相对路径来引用内部包，这样管理和定位问题其实都不是很方便。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;之后由于需要其他人共同开发，fork了我的项目之后，他们也使用 go get 下载他们fork后的项目源码，这样 &lt;code&gt;fatedier&lt;/code&gt; 就替换成了他们自己的用户名，但是代码中 import 的包名并没有改变，会导致他们无法编译通过。当然，他们可以将项目再放到正确的目录，但是多了一部操作总归不方便。&lt;/p&gt;

&lt;h3 id=&#34;比较tricky的做法-修改gopath&#34;&gt;比较tricky的做法，修改GOPATH&lt;/h3&gt;

&lt;p&gt;其实问题的关键就在于 &lt;code&gt;GOPATH&lt;/code&gt; 这个环境变量，这个变量决定了查找包的绝对路径。我们在项目根目录下建立 &lt;code&gt;src/frp&lt;/code&gt; 这样的目录结构，之后将原来的源代码放到这个目录下，然后内部包的应用方式还是改成 &lt;code&gt;import frp/xxx&lt;/code&gt; 这种简洁的格式。&lt;/p&gt;

&lt;p&gt;编译的时候，把项目根目录加到 &lt;code&gt;GOPATH&lt;/code&gt; 中去，例如 &lt;code&gt;GOPATH=`pwd`:${GOPATH}&lt;/code&gt;，这样就会在自己的目录里查找内部包。&lt;/p&gt;

&lt;p&gt;可以看到，通过这样的方式不管把你把项目放到哪一个目录下，都可以编译成功，当然，为了便于管理，推荐还是放在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 目录下，同时使用 &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;godep&lt;/a&gt; 来管理第三方包。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Go中如何优雅地关闭net.Listener</title>
          <link>http://blog.fatedier.com/2016/02/19/how-to-shutdown-go-net-dot-listeners-gracefully</link>
          <pubDate>Fri, 19 Feb 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/02/19/how-to-shutdown-go-net-dot-listeners-gracefully</guid>
          <description>&lt;p&gt;在开发一个 Go 语言写的服务器项目的时候，遇到一个很有意思的问题，这个程序会根据客户端的请求动态的监听本地的一个端口，并且与客户端交互结束后需要释放这个端口。Go 的标准库提供了常用的接口，开发网络服务非常方便，网上随便就可以找到很多样例代码。&lt;/p&gt;

&lt;p&gt;但是我在释放这个监听端口的时候遇到了一些问题，我发现很难优雅地去关闭这个 &lt;strong&gt;net.Listener&lt;/strong&gt;。在网上查阅了一下资料，基本上都是程序结束时资源被系统自动回收，没发现有需要主动释放的。这个需求确实不多，不过想一下在写测试用例的时候或许可能会用到，我们先创建一个 &lt;strong&gt;net.Listener&lt;/strong&gt; 监听一个端口，&lt;strong&gt;client&lt;/strong&gt; 发送请求进行测试，通过后关闭这个 &lt;strong&gt;net.Listener&lt;/strong&gt;，再创建另外一个 &lt;strong&gt;net.Listener&lt;/strong&gt; 用于测试其他用例。&lt;/p&gt;

&lt;p&gt;初步思考了一下有两个办法来关闭 &lt;strong&gt;net.Listener&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置一个结束标志，为 &lt;strong&gt;net.Listener&lt;/strong&gt; 的 &lt;code&gt;accept&lt;/code&gt; 设置超时，&lt;strong&gt;net.Listener&lt;/strong&gt; 提供了一个 &lt;code&gt;SetDeadline(t time.Time)&lt;/code&gt; 接口，需要关闭时将标志置为 &lt;strong&gt;true&lt;/strong&gt;，每次超时后检查一下结束标志，如果为 &lt;strong&gt;true&lt;/strong&gt; 则退出。&lt;/li&gt;
&lt;li&gt;在另外一个协程中 &lt;strong&gt;close net.Listener&lt;/strong&gt;，检查 &lt;code&gt;accept&lt;/code&gt; 返回的 &lt;strong&gt;error&lt;/strong&gt; 信息，如果是被 &lt;strong&gt;close&lt;/strong&gt; 的话就退出，其他情况就继续。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个方法很显然不够优雅，在大并发量连接请求时对效率有很大影响，而且退出机制是延迟的，不能及时退出。&lt;/p&gt;

&lt;p&gt;第二个方法的问题就在于如果 &lt;strong&gt;close net.Listener&lt;/strong&gt;，&lt;code&gt;accept&lt;/code&gt; 函数返回的 &lt;strong&gt;error&lt;/strong&gt; 信息只能拿到错误的字符串信息，如果是被 &lt;strong&gt;close&lt;/strong&gt; 的话返回的信息是：&lt;code&gt;use of closed network connection&lt;/code&gt;，这个时候退出监听，如果是其他错误，则继续监听。想法是好的，然而并不能用错误信息的字符串来判断是哪一种类型的错误，有可能以后的版本中错误信息字符串变更也说不定，最好不要在代码中写死。这个 &lt;strong&gt;error&lt;/strong&gt; 其实是有类型的，在标准库中是 &lt;code&gt;errClosing&lt;/code&gt;，开头小写，说明只能在包内部使用，我们没有办法使用这个类型来判断具体是哪一种错误。个人觉得这方面可能还没有 &lt;strong&gt;c语言&lt;/strong&gt; 中通过 &lt;strong&gt;errno&lt;/strong&gt; 的值来判断是哪一种类型的错误来的方便。&lt;/p&gt;

&lt;p&gt;既然不能通过 &lt;strong&gt;error&lt;/strong&gt; 的字符串信息判断是哪一种错误，那么我们只能用类似第一个方法中使用的标志来判断了，先将结束标志置为 &lt;strong&gt;true&lt;/strong&gt;，之后 &lt;strong&gt;close net.Listener&lt;/strong&gt;，&lt;code&gt;accept&lt;/code&gt; 函数返回 &lt;code&gt;error != nil&lt;/code&gt; 时，检查结束标志，如果为 &lt;strong&gt;true&lt;/strong&gt; 就退出，这样相比较第一个方法退出时就没有延迟了，参考代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net&amp;quot;
    &amp;quot;time&amp;quot;
)

var (
    ln        net.Listener
    closeFlag bool = false
)

func startServer() (err error) {
    ln, err = net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:12345&amp;quot;)
    if err != nil {
        return err
    }
    defer ln.Close()

    for {
        conn, err := ln.Accept()
        if err != nil {
            fmt.Printf(&amp;quot;accept error: %v\n&amp;quot;, err)
            if closeFlag {
                break
            } else {
                continue
            }
        } else {
            conn.Close()
        }
    }
    return nil
}

func main() {
    go startServer()
    time.Sleep(1 * time.Second)
    closeFlag = true
    ln.Close()
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>使用godep管理golang项目的第三方包</title>
          <link>http://blog.fatedier.com/2016/01/15/use-godep-to-manage-third-party-packages-of-golang-projects</link>
          <pubDate>Fri, 15 Jan 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2016/01/15/use-godep-to-manage-third-party-packages-of-golang-projects</guid>
          <description>

&lt;p&gt;go语言项目的第三方包资源现在十分丰富，使用起来也非常方便，直接在代码中 import 之后再使用 go get 命令下载到本地即可。但是在合作开发一个golang项目时，经常会遇到每个人在各自的机器上使用 go get 下载的第三方包版本不一致的情况（因为 go get 会下载指定包的最新版本），很有可能会遇到版本不兼容的情况。&lt;/p&gt;

&lt;p&gt;目前 go 自身的包管理体系比较薄弱，go 1.5 以后开始使用 vendor 机制来管理，但是依然缺乏对第三方包的版本的管理。&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;确保已经有go语言的环境并且设置好了 GOPATH 环境变量。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;go get -u github.com/tools/godep&lt;/code&gt; 下载 godep 包并自动安装。&lt;/li&gt;
&lt;li&gt;godep 可执行程序会放在 $GOPATH/bin 目录下。所以想直接用 godep 执行命令的话需要将该路径加入到全局的环境变量 PATH 中，可以将&lt;code&gt;export PATH=&amp;quot;$PATH:$GOPATH/bin&amp;quot;&lt;/code&gt;加入到系统启动脚本中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;进入go项目的根目录，需要该项目已经可以使用 go build 正常编译。&lt;/p&gt;

&lt;h4 id=&#34;godep-save&#34;&gt;godep save&lt;/h4&gt;

&lt;p&gt;执行 &lt;code&gt;godep save&lt;/code&gt; 或者 &lt;code&gt;godep save ./...&lt;/code&gt;，后者会递归地查找所有引用的第三方包。&lt;/p&gt;

&lt;p&gt;如果加上 -r 参数，则会替换原来代码中的第三包的路径为 godep 在该项目下copy过后的路径，例如 &lt;code&gt;C/Godeps/_workspace/src/D&lt;/code&gt;， 这样一来，以后直接执行 &lt;code&gt;go build&lt;/code&gt; 等就可以了，不需要使用 &lt;code&gt;godep go build&lt;/code&gt;。&lt;strong&gt;（这个特性在最新版本中已经被移除了）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个命令做了以下几件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查找项目中所用到的所有的第三方包&lt;/li&gt;
&lt;li&gt;在项目目录下创建 &lt;code&gt;Godeps&lt;/code&gt; 目录，&lt;code&gt;Godeps/Godeps.json&lt;/code&gt; 是依赖文件，包括了go的版本，用到的第三包的引入路径，版本号等信息，json文件需要一并加入到版本控制里。&lt;/li&gt;
&lt;li&gt;所有依赖的第三包的代码会被拷贝到 &lt;code&gt;Godeps/_workspace/src&lt;/code&gt; 下，并且移除了 &lt;code&gt;.git&lt;/code&gt; 这样的版本控制信息。&lt;code&gt;Godeps/_workspace&lt;/code&gt; 里的内容如果加到版本控制里，别人下载代码后可以直接编译，不需要另外再下依赖包，但是项目大小会变大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;godep-restore&#34;&gt;godep restore&lt;/h4&gt;

&lt;p&gt;这个命令是根据 &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; 文件把项目的依赖包下载到 &lt;code&gt;$GOPATH&lt;/code&gt; 目录下，需要注意这个命令是会修改 &lt;code&gt;$GOPATH&lt;/code&gt; 下依赖包的状态的，所以最好还是将 &lt;code&gt;Godeps/_workspace&lt;/code&gt; 里的内容直接加到自己项目的版本控制里。&lt;/p&gt;

&lt;h4 id=&#34;其他命令&#34;&gt;其他命令&lt;/h4&gt;

&lt;p&gt;其他的 go 命令基本上都可以通过 godep 执行，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;godep go build
godep go install
godep go fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;godep 封装的 go 命令其实就是将 Godeps/_workspace 加入到 GOPATH 中，这样编译的时候就会去 Godeps/_workspace 中寻找第三方包。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>go语言中使用smtp发送邮件及smtp协议的相关问题</title>
          <link>http://blog.fatedier.com/2015/08/20/use-smtp-to-sendmail-in-go-and-some-problems-with-smtp</link>
          <pubDate>Thu, 20 Aug 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://blog.fatedier.com/2015/08/20/use-smtp-to-sendmail-in-go-and-some-problems-with-smtp</guid>
          <description>

&lt;p&gt;go 的标准库中有一个 smtp 包提供了一个可以非常方便的使用 smtp 协议发送邮件的函数，通常情况下使用起来简单方便，不过我在使用中却意外遇到了一个会导致邮件发送出错的情况。&lt;/p&gt;

&lt;h3 id=&#34;smtp-协议发送邮件&#34;&gt;smtp 协议发送邮件&lt;/h3&gt;

&lt;h4 id=&#34;sendmail-函数&#34;&gt;sendmail 函数&lt;/h4&gt;

&lt;p&gt;go 标准库的 net/smtp 包提供了一个 SendMail 函数用于发送邮件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SendMail(addr string, a Auth, from string, to []string, msg []byte) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SendMail&lt;/strong&gt;： 连接到 &lt;strong&gt;addr&lt;/strong&gt; 指定的服务器；如果支持会开启 &lt;strong&gt;TLS&lt;/strong&gt;；如果支持会使用 &lt;strong&gt;a(Auth)&lt;/strong&gt; 认证身份；然后以 &lt;strong&gt;from&lt;/strong&gt; 为邮件源地址发送邮件 &lt;strong&gt;msg&lt;/strong&gt; 到目标地址 &lt;strong&gt;to&lt;/strong&gt;。（可以是多个目标地址：群发）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;： 邮件服务器的地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a&lt;/strong&gt;： 身份认证接口，可以由 &lt;code&gt;func PlainAuth(identity, username, password, host string) Auth&lt;/code&gt; 函数创建。&lt;/p&gt;

&lt;h4 id=&#34;简单发送邮件示例&#34;&gt;简单发送邮件示例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/smtp&amp;quot;
    &amp;quot;strings&amp;quot;
)

func main() {
    auth := smtp.PlainAuth(&amp;quot;&amp;quot;, &amp;quot;username@qq.com&amp;quot;, &amp;quot;passwd&amp;quot;, &amp;quot;smtp.qq.com&amp;quot;)
    to := []string{&amp;quot;to-user@qq.com&amp;quot;}
    nickname := &amp;quot;test&amp;quot;
    user := &amp;quot;username@qq.com&amp;quot;
    subject := &amp;quot;test mail&amp;quot;
    content_type := &amp;quot;Content-Type: text/plain; charset=UTF-8&amp;quot;
    body := &amp;quot;This is the email body.&amp;quot;
    msg := []byte(&amp;quot;To: &amp;quot; + strings.Join(to, &amp;quot;,&amp;quot;) + &amp;quot;\r\nFrom: &amp;quot; + nickname +
        &amp;quot;&amp;lt;&amp;quot; + user + &amp;quot;&amp;gt;\r\nSubject: &amp;quot; + subject + &amp;quot;\r\n&amp;quot; + content_type + &amp;quot;\r\n\r\n&amp;quot; + body)
    err := smtp.SendMail(&amp;quot;smtp.qq.com:25&amp;quot;, auth, user, to, msg)
    if err != nil {
        fmt.Printf(&amp;quot;send mail error: %v&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;autu&lt;/strong&gt;： 这里采用简单的明文用户名和密码的认证方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nickname&lt;/strong&gt;： 发送方的昵称。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;subject&lt;/strong&gt;： 邮件主题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;content_type&lt;/strong&gt;： 可以有两种方式，一种 text/plain，纯字符串，不做转义。一种 text/html，会展示成 html 页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt;： 邮件正文内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;msg&lt;/strong&gt;： msg 的内容需要遵循 smtp 协议的格式，参考上例。&lt;/p&gt;

&lt;h3 id=&#34;特定邮件服务器出错&#34;&gt;特定邮件服务器出错&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;certificate signed by unknown authority
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在通过公司内部自己搭建的邮件服务器发送邮件时报了上述错误，看上去是因为认证不通过的问题，检查了一下用户名和密码没有问题。&lt;/p&gt;

&lt;p&gt;我通过抓包以及手动 telnet 执行了一遍 smtp 的过程，发送问题出现在是否加密和身份验证上。&lt;/p&gt;

&lt;h4 id=&#34;smtp-协议&#34;&gt;SMTP 协议&lt;/h4&gt;

&lt;p&gt;smtp 协议开始时客户端主动向邮件服务器发送 &lt;code&gt;EHLO&lt;/code&gt;，服务器会返回支持的所有命令，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;250-PIPELINING
250-SIZE 10240000
250-VRFY
250-ETRN
250-STARTTLS
250-AUTH PLAIN LOGIN
250-AUTH=PLAIN LOGIN
250-ENHANCEDSTATUSCODES
250-8BITMIME
250 DSN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有 &lt;strong&gt;STARTTLS&lt;/strong&gt;，说明支持加密传输，golang 的标准库中会进行判断然后决定是否选择使用 &lt;strong&gt;STARTTLS&lt;/strong&gt; 加密传输。&lt;/p&gt;

&lt;p&gt;如果没有 &lt;strong&gt;AUTH=PLAIN LOGIN&lt;/strong&gt;，说明不支持 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式。&lt;/p&gt;

&lt;p&gt;一共有3种验证方式，可以参考这篇 blog： &lt;a href=&#34;http://blog.csdn.net/mhfh611/article/details/9470599&#34;&gt;http://blog.csdn.net/mhfh611/article/details/9470599&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;starttls-引起的错误&#34;&gt;STARTTLS 引起的错误&lt;/h4&gt;

&lt;p&gt;公司内部的邮件服务器返回了 &lt;strong&gt;STARTTLS&lt;/strong&gt;，但是实际上却不支持加密传输的认证方式，所以就导致了身份认证失败。&lt;/p&gt;

&lt;p&gt;大部分国内的邮件服务器都支持 &lt;strong&gt;LOGIN&lt;/strong&gt; 和 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式，所以我们可以在代码中直接采用 &lt;strong&gt;PLAIN&lt;/strong&gt; 的方式，不过安全性就降低了。&lt;/p&gt;

&lt;p&gt;想要强制使用 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式也不是这么容易的，因为涉及到修改 &lt;strong&gt;net/smtp&lt;/strong&gt; 的 &lt;code&gt;SendMail&lt;/code&gt; 函数，当然标准库我们修改不了，所以只能重新实现一个 &lt;code&gt;SendMail&lt;/code&gt; 函数。&lt;/p&gt;

&lt;p&gt;标准库中 &lt;code&gt;SendMail&lt;/code&gt; 函数代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SendMail(addr string, a Auth, from string, to []string, msg []byte) error {
    c, err := Dial(addr)
    if err != nil {
        return err
    }
    defer c.Close()
    if err = c.hello(); err != nil {
        return err
    }
    if ok, _ := c.Extension(&amp;quot;STARTTLS&amp;quot;); ok {
        config := &amp;amp;tls.Config{ServerName: c.serverName}
        if testHookStartTLS != nil {
            testHookStartTLS(config)
        }
        if err = c.StartTLS(config); err != nil {
            return err
        }
    }
    if a != nil &amp;amp;&amp;amp; c.ext != nil {
        if _, ok := c.ext[&amp;quot;AUTH&amp;quot;]; ok {
            if err = c.Auth(a); err != nil {
                return err
            }
        }
    }
    if err = c.Mail(from); err != nil {
        return err
    }
    for _, addr := range to {
        if err = c.Rcpt(addr); err != nil {
            return err
        }
    }
    w, err := c.Data()
    if err != nil {
        return err
    }
    _, err = w.Write(msg)
    if err != nil {
        return err
    }
    err = w.Close()
    if err != nil {
        return err
    }
    return c.Quit()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点就在于下面这一段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if ok, _ := c.Extension(&amp;quot;STARTTLS&amp;quot;); ok {
    config := &amp;amp;tls.Config{ServerName: c.serverName}
    if testHookStartTLS != nil {
        testHookStartTLS(config)
    }
    if err = c.StartTLS(config); err != nil {
        return err
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逻辑上就是检查服务器端对于 &lt;strong&gt;EHLO&lt;/strong&gt; 命令返回的所支持的命令中是否有 &lt;strong&gt;STARTTLS&lt;/strong&gt;，如果有，则采用加密传输的方式。我们自己实现的函数中直接把这部分去掉。&lt;/p&gt;

&lt;p&gt;我们仿照 &lt;code&gt;SendMail&lt;/code&gt; 函数实现一个 &lt;code&gt;NewSendMail&lt;/code&gt; 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewSendMail(addr string, a smtp.Auth, from string, to []string, msg []byte) error {
    c, err := smtp.Dial(addr)
    if err != nil {
        return err 
    }   
    defer c.Close()
    if err = c.Hello(&amp;quot;localhost&amp;quot;); err != nil {
        return err 
    }   
    err = c.Auth(a)
    if err != nil {
        return err 
    }   

    if err = c.Mail(from); err != nil {
        fmt.Printf(&amp;quot;mail\n&amp;quot;)
        return err 
    }   
    for _, addr := range to {
        if err = c.Rcpt(addr); err != nil {
            return err 
        }   
    }
    w, err := c.Data()
    if err != nil {
        return err
    }
    _, err = w.Write(msg)
    if err != nil {
        return err
    }
    err = w.Close()
    if err != nil {
        return err
    }
    return c.Quit()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个函数发送邮件，则身份认证时不会采用加密的方式，而是直接使用 &lt;strong&gt;PLAIN&lt;/strong&gt; 方式。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
